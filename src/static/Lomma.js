function Lomma(
	render,
	persistence,
	translate,
	userId
) {

var INSERTION = 6
var MaxLineLength = 800
var TabSize = 4
var MaxChars = 40

var CandyColor = "#00ff00"

var MainFont = "14px " + Config.EDITOR_FONT
var HeaderFont = "18px " + Config.EDITOR_FONT
var SmallFont = "12px " + Config.EDITOR_FONT

var tr = translate
var module = this
var RoundedRadius = 8

var MaxLineLength = 800
var MaxLines = 100
var LineHeight = 1.2
var Q_PADDING = 20;

var SpacesInTab = 4

module.storage = null
module.visuals = null
module.render = render
module.persistence = persistence
module.callbacks = {}





// Autogenerated with DRAKON Editor 1.33


function Action_draw(render, item) {
    var format, texId
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "rectangle",
        item.x,
        item.y,
        [item.w, item.h],
        format
    )
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        item
    )
}

function Action_flow(render, item) {
    var tb
    tb = requestSourceFlow(render, item)
    item.tb = tb
    item.w = snapSize(tb.width)
    item.h = snapSize(tb.height)
}

function Address_draw(render, item) {
    var format, pos, texId
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    points = makeAddressPoints(
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        points,
        format
    )
    if (item.mark) {
        var x = 0
        var y = 0
        var w = item.w
        var h = item.h
        var top = y - h
        var middle = top + 2.0 / 3.0 * h
        
        var tx0 = x - w / 2;
        var tx1 = x + w / 2;
        var ty = (top + middle) / 2;
        if (format.lineColor === "none") {
            format = makeLineFormat(format)
        }
        var markFormat = {
        	fillColor: format.lineColor
        }
        var points = [
         tx0, ty,
         x, top,    
         tx1, ty
        ]
        render.drawShape(
        	texId,
        	"poly",
        	item.x,
        	item.y,
        	points,
        	markFormat
        );
    }
    y = item.y + Math.floor(item.h / 3)
    pos = {
        x : item.x,
        y : y,
        w : item.w,
        h : item.h / 3 * 2
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        pos
    )
}

function Branch_draw(render, item) {
    var bottom, format, h, markFormat, middle, points, pos, texId, tx0, tx1, ty, w, x, y
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    points = makeCasePoints(
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        points,
        format
    )
    if (item.mark) {
        x = 0
        y = 0
        w = item.w
        h = item.h
        bottom = y + h
        middle = bottom - 2.0 / 3.0 * h;
        
        tx0 = x - w / 2;
        tx1 = x + w / 2;
        ty = (bottom + middle) / 2;
        if (format.lineColor === "none") {
            format = makeLineFormat(format)
        }
        markFormat = {
        	fillColor: format.lineColor
        }
        points = [
         tx0, ty,
         x, bottom,
         tx1, ty
        ]
        render.drawShape(
        	texId,
        	"poly",
        	item.x,
        	item.y,
        	points,
        	markFormat
        );
    }
    y = item.y - Math.floor(item.h / 3)
    pos = {
        x : item.x,
        y : y,
        w : item.w,
        h : item.h / 3 * 2
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        pos
    )
}

function Branch_flow(render, item) {
    var tb
    tb = requestTextFlow(render, item)
    item.tb = tb
    item.w = snapSize(tb.width)
    item.h = snapSize(tb.height)
    item.h = item.h * 3.0 / 2.0
}

function Case_draw(render, item) {
    var bottom, format, left, middle, points, pos, right, texId, y
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    points = makeCasePoints(
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        points,
        format
    )
    bottom = item.y + item.h
    middle = bottom - 2.0 / 3.0 * item.h - 1
    left = item.x - item.w
    right = item.x + item.w
    format = makeLineFormat(format)
    render.drawShape(
        texId,
        "line",
        left,
        middle,
        [right - 1, middle],
        format
    )
    y = item.y - Math.floor(item.h / 3)
    pos = {
        x : item.x,
        y : y,
        w : item.w,
        h : item.h / 3 * 2
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        pos
    )
}

function Case_flow(render, item) {
    Action_flow(render, item)
    item.h = item.h * 3.0 / 2.0
}

function DoubleQuoter_Created_default(self, msg) {
    self.state = "Created";
}

function DoubleQuoter_Created_operator(self, msg) {
    self.chars = [msg]
    self.state = "Normal";
}

function DoubleQuoter_Escaping_default(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function DoubleQuoter_Escaping_operator(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function DoubleQuoter_Normal_alpha(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function DoubleQuoter_Normal_digit(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function DoubleQuoter_Normal_operator(self, msg) {
    var token
    if (msg === module.DOUBLE_QUOTE) {
        addAnyChar(
            self,
            msg
        )
        token = makeTokenFromChars(
            self,
            "string"
        )
        self.next.completeToken(
            token
        )
        self.state = null;
    } else {
        if (msg === module.BACK) {
            addAnyChar(
                self,
                msg
            )
            self.state = "Escaping";
        } else {
            addAnyChar(
                self,
                msg
            )
            self.state = "Normal";
        }
    }
}

function DoubleQuoter_Normal_whitespace(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function Edge(id, head, tail, vertical) {
    this.id = id
    this.head = head
    this.tail = tail
    this.vertical = vertical
    this.skewer = null
    this.finalTarget = null
    this.source = null
    this.target = null
    this.role = null
    this.links = []
    this.box = null
    this.inner = null
    this.outer = null
}

function Edit(type, table, id, fields) {
    this.type = type;
    this.table = table;
    this.id = id;
    this.fields = fields || {};
    this.undo = null;
}

function Header_draw(render, item) {
    var box, fontHeight, format, labelColor, scenario, sw, texId
    format = getFormatForIcon(
        item.type
    )
    fontHeight = render.getFontHeight()
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h + fontHeight * 2
    )
    render.drawShape(
        texId,
        "beginend",
        item.x,
        item.y,
        [item.w, item.h],
        format
    )
    box = {
        x : item.x,
        y : item.y,
        w : item.w - Config.SNAP * 1,
        h : item.h
    }
    drawCenterTextInRect(
        render,
        texId,
        item.tb,
        box
    )
    if (item.header) {
        if (isScenario()) {
            scenario = translate("MES_SCENARIO")
            render.setDefaultFont(SmallFont)
            sw = render.measureTextWidth(scenario)
            labelColor = getYesColor()
            render.drawText(
            	texId,
            	scenario,
            	item.x - Math.floor(sw / 2),
            	item.y - item.h - 3,
            	labelColor,
            	SmallFont
            )
        } else {
            if (isAlgoprop()) {
                scenario = translate("MES_ALGOPROP")
                render.setDefaultFont(SmallFont)
                sw = render.measureTextWidth(scenario)
                labelColor = getYesColor()
                render.drawText(
                	texId,
                	scenario,
                	item.x - Math.floor(sw / 2),
                	item.y - item.h - 3,
                	labelColor,
                	SmallFont
                )
            }
        }
    }
}

function Header_flow(render, item) {
    var tb
    tb = requestTextFlow(render, item)
    item.tb = tb
    item.w = snapSize(tb.width)
    item.h = snapSize(tb.height)
    item.w += Config.SNAP * 1
}

function InnerCrawler_down_default(self, edge) {
    self.state = "down";
}

function InnerCrawler_down_onEdge(self, edge) {
    var caseNode, left, tail
    tail = edge.tail
    if (tail.down) {
        addInnerEdgeToSub(
            self,
            edge
        )
        if (tail.type == "select") {
            caseNode = getDown(
            	getDown(tail)
            )
            self.state = "down";
            return caseNode.down
        } else {
            if ((tail.type == "address") || (tail.left)) {
                self.state = null;
                return null
            } else {
                self.state = "down";
                return tail.down
            }
        }
    } else {
        if (tail.left) {
            left = getLeft(tail)
            if (left.type == "question") {
                addInnerEdgeToSub(
                    self,
                    edge
                )
                self.state = null;
                return null
            } else {
                if (edge.role == "up") {
                    addInnerEdgeToSub(
                        self,
                        edge
                    )
                }
                self.state = "left";
                return tail.left
            }
        } else {
            addInnerEdgeToSub(
                self,
                edge
            )
            self.state = null;
            return null
        }
    }
}

function InnerCrawler_left_default(self, edge) {
    self.state = "right";
}

function InnerCrawler_left_onEdge(self, edge) {
    addInnerEdgeToSub(
        self,
        edge
    )
    self.state = null;
    return null
}

function InnerCrawler_right_default(self, edge) {
    self.state = "right";
}

function InnerCrawler_right_onEdge(self, edge) {
    var tail
    tail = edge.tail
    if (tail.right) {
        self.state = "right";
        return tail.right
    } else {
        self.state = "down";
        return tail.down
    }
}

function Input_draw(render, item) {
    var b, borderFormat, format, points, pos, pos2, texId, x2, x4, y3, y4
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    points = makeComplexInput(item)
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        points,
        format
    )
    x2 = item.x - item.w + Config.INPUT_LEFT * 2
    x4 = item.x + item.w
    y3 = item.y + getCompY3(item)
    y4 = item.y + item.h
    borderFormat = makeLineFormat(format)
    render.drawShape(
        texId,
        "line",
        x2,
        y3,
        [x4, y3],
        borderFormat
    )
    render.drawShape(
        texId,
        "line",
        x2,
        y3,
        [x2, y4],
        borderFormat
    )
    b = item.h - item.a
    pos2 = {
        x : item.x + Config.INPUT_LEFT,
        y : item.y - item.h + item.a,
        w : item.w,
        h : item.a
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb2,
        pos2
    )
    pos = {
        x : item.x + Config.INPUT_LEFT * 2,
        y : item.y + item.h - b,
        w : item.w,
        h : b
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        pos
    )
}

function Input_flow(render, item) {
    var partWidth, tb, tb2, width
    partWidth = Config.DEF_ICON_WIDTH - 
    	Config.INPUT_LEFT
    tb = flowText(
        render,
        item.text || "",
        partWidth
    )
    tb2 = flowText(
        render,
        item.text2 || "",
        partWidth
    )
    width = Math.max(
        Config.INPUT_LEFT + tb.width,
        Config.INPUT_LEFT + tb2.width
    )
    item.tb = tb
    item.tb2 = tb2
    item.w = snapSize(width)
    item.h = snapSize(tb.height) + snapSize(tb2.height)
    item.a = snapSize(tb2.height)
}

function Insertion_draw(render, item) {
    var format, pos, qformat, texId
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "rectangle",
        item.x,
        item.y,
        [item.w, item.h],
        format
    )
    var hi = Math.floor(INSERTION / 2)
    var left = item.x - item.w + hi
    var right = item.x + item.w - hi
    var le2 = left + hi
    var ri2 = right - hi
    var top = item.y - item.h
    var bottom = item.y + item.h
    qformat = Utils.copyObject(format)
    qformat.fillColor = format.secondaryColor
    render.drawShape(
    	texId,
    	"rectangle",
    	left,
    	item.y,
    	[hi, item.h],
    	qformat
    );
    render.drawShape(
    	texId,
    	"rectangle",
    	right,
    	item.y,
    	[hi, item.h],
    	qformat
    );
    if (format.lineColor === "none") {
        format = makeLineFormat(format)
        render.drawShape(
            texId,
            "line",
            le2,
            top,
            [le2, bottom],
            format
        )
        render.drawShape(
            texId,
            "line",
            ri2,
            top,
            [ri2, bottom],
            format
        )
    }
    pos = {
        x : item.x + INSERTION,
        y : item.y,
        w : item.w,
        h : item.h
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        pos
    )
}

function Insertion_flow(render, item) {
    var tb
    tb = requestSourceFlow(render, item)
    item.tb = tb
    item.w = snapSize(tb.width + INSERTION)
    item.h = snapSize(tb.height)
}

function JsLexer_eol(self) {
    self.next.eol()
    self.state = "Idle"
}

function JsLexer_finish(self) {
    self.next.finish()
    self.state = "Idle"
}

function Link(source, index) {
    this.source = source
    this.index = index
}

function LoopBegin_draw(render, item) {
    var ADD, format, texId, w
    ADD = Math.floor(Config.SNAP / 2)
    w = item.w + ADD
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        w,
        item.h
    )
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        makeLoopBeginPoints(w, item.h),
        format
    )
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        item
    )
}

function LoopBegin_flow(render, item) {
    var ADD, tb
    ADD = Config.SNAP
    tb = requestSourceFlow(render, item)
    item.tb = tb
    item.w = snapSize(tb.width + ADD)
    item.h = snapSize(tb.height)
}

function LoopEnd_draw(render, item) {
    var ADD, format, texId, w
    ADD = Math.floor(Config.SNAP / 2)
    w = item.w + ADD
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        w,
        item.h
    )
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        makeLoopEndPoints(w, item.h),
        format
    )
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        item
    )
}

function MTable(name, keys) {
    this.name = name
    this.rows = {}
    this.count = 0
    this.keys = keys
    this.insert = MTable_insert
    this.get = MTable_get
}

function MTable_get() {
    var current, i, keyPart, keys, table
    table = this
    current = table.rows
    keys = table.keys
    i = 0;
    while (true) {
        if (i < keys.length) {
            
        } else {
            return current
        }
        keyPart = arguments[i]
        if (keyPart) {
            
        } else {
            return current
        }
        current = current[keyPart]
        if (current) {
            
        } else {
            return null
        }
        i++;
    }
}

function MTable_insert(row) {
    var bucket, i, keyName, keyPart, keys, lastKey, message, rows, table
    table = this
    rows = table.rows
    keys = table.keys
    lastKey = keys.length - 1
    i = 0;
    while (true) {
        if (i < lastKey) {
            
        } else {
            keyName = keys[lastKey]
            keyPart = row[keyName]
            if (keyPart) {
                if (keyPart in rows) {
                    message = table.name + 
                     " insert: id not unique. id=" +
                     keyToString(table, row)
                    throw Error(message)
                } else {
                    rows[keyPart] = row
                    table.count++
                }
            } else {
                message = table.name + 
                 " insert: id part is empty. name=" +
                 keyName
                throw Error(message)
            }
            break;
        }
        keyName = keys[i]
        keyPart = row[keyName]
        if (keyPart) {
            
        } else {
            message = table.name + 
             " insert: id part is empty. name=" +
             keyName
            throw Error(message)
        }
        bucket = rows[keyPart]
        if (bucket) {
            
        } else {
            bucket = {}
            rows[keyPart] = bucket
        }
        rows = bucket
        i++;
    }
}

function MachineStack(machines) {
    var prev
    this.first = {
        prev : null,
        next : null
    }
    this.top = function() { return this.first.next }
    prev = this.first
    var _ind1237 = 0;
    var _col1237 = machines;
    var _len1237 = _col1237.length;
    while (true) {
        if (_ind1237 < _len1237) {
            
        } else {
            break;
        }
        var machine = _col1237[_ind1237];
        machine.prev = prev
        prev.next = machine
        prev = machine
        _ind1237++;
    }
}

function Node(id, itemId, type, text) {
    this.id = id
    this.itemId = itemId
    this.type = type
    this.text = text
    this.text2 = null
    this.x = 0
    this.y = 0
    this.w = 0
    this.h = 0
    this.flag1 = 0
    this.a = 0
    this.next = []
    this.prev = []
    this.aprev = []
    this.left = null
    this.up = null
    this.right = null
    this.down = null
    this.mountUp = null
    this.mountRight = null
    this.skewer = null
    this.level = null
    this.finalTarget = null
    this.sources = []
    this.targets = []
    this.role = null
    this.box = null
    this.loops = {}
}

function OneToMany(one, many, oneField, manyField) {
    this.one = one
    this.many = many
    this.oneField = oneField
    this.manyField = manyField
    this.link = OneToMany_link
    this.unlink = OneToMany_unlink
}

function OneToMany_link(manyRow) {
    var bucket, id, oneRow, self
    self = this
    id = manyRow[self.manyField]
    if (id) {
        oneRow = self.one.get(id)
        bucket = oneRow[self.oneField]
        if (bucket) {
            
        } else {
            bucket = []
            oneRow[self.oneField] = bucket
        }
        bucket.push(manyRow)
    }
}

function OneToMany_unlink(manyRow) {
    var bucket, id, oneRow, self
    self = this
    id = manyRow[self.manyField]
    if (id) {
        oneRow = self.one.get(id)
        bucket = oneRow[self.oneField]
        if (bucket) {
            remove(bucket, manyRow)
        }
    }
}

function OperBuilder_Idle_eol(self, token) {
    self.next.eol()
    self.state = "Idle";
}

function OperBuilder_Idle_onToken(self, token) {
    if ((token.type == "operator") && (longOp1(token.text))) {
        addOp(self, token)
        self.state = "One";
    } else {
        self.next.onToken(token)
        self.state = "Idle";
    }
}

function OperBuilder_One_eol(self, token) {
    mergeOps(self)
    self.next.eol()
    self.state = "Idle";
}

function OperBuilder_One_onToken(self, token) {
    if ((token.type == "operator") && (longOp2(
self.tokens[0].text,
token.text))) {
        addOp(self, token)
        self.state = "Two";
    } else {
        mergeOps(self)
        self.next.onToken(token)
        self.state = "Idle";
    }
}

function OperBuilder_Two_eol(self, token) {
    mergeOps(self)
    self.next.eol()
    self.state = "Idle";
}

function OperBuilder_Two_onToken(self, token) {
    if ((token.type == "operator") && (longOp3(
self.tokens[0].text,
self.tokens[1].text,
token.text))) {
        addOp(self, token)
        mergeOps(self)
    } else {
        mergeOps(self)
        self.next.onToken(token)
    }
    self.state = "Idle";
}

function OperatorBuilder_Idle_default(self, msg) {
    self.state = "Idle";
}

function OperatorBuilder_Idle_operator(self, msg) {
    self.chars = [msg]
    self.state = "One";
}

function OperatorBuilder_One_default(self, msg) {
    self.state = "One";
}

function OperatorBuilder_One_operator(self, msg) {
    var text, token
    text = makeChar2Text(
        self,
        msg
    )
    if ((text == "!=") || (text == "==")) {
        self.chars.push(msg)
        self.state = "Two";
    } else {
        if (text in module.longOps) {
            token = new Token("operator")
            token.text = text
            self.next.completeToken(
                token
            )
            self.state = "Idle";
        } else {
            sendChars(self)
            self.chars = [msg]
            self.state = "One";
        }
    }
}

function OperatorBuilder_Two_default(self, msg) {
    self.state = "Two";
}

function OperatorBuilder_Two_operator(self, msg) {
    if (msg == module.EQUALS) {
        self.chars.push(msg)
        completeChars(self)
        self.state = "Idle";
    } else {
        sendChars(self)
        self.chars = [msg]
        self.state = "One";
    }
}

function OuterCrawler_downLoop_default(self, edge) {
    self.state = "downLoop";
}

function OuterCrawler_downLoop_onEdge(self, edge) {
    var tail
    tail = edge.tail
    if (tail.down) {
        self.state = "downLoop";
        return tail.down
    } else {
        self.state = "leftLoop";
        return tail.left
    }
}

function OuterCrawler_down_default(self, edge) {
    self.state = "down";
}

function OuterCrawler_down_onEdge(self, edge) {
    var next, tail
    var _sw85920000_ = 0;
    addArrowPad(
        self.sub,
        edge
    )
    tail = edge.tail
    if (tail.type == "select") {
        addEdgeToSub(
            self,
            edge
        )
        next = crawlSelect(
            tail
        )
        self.state = "down";
        return next.down
    } else {
        if (tail.right) {
            _sw85920000_ = tail.type;
            if (_sw85920000_ === "arrow-loop") {
                addEdgeToSub(
                    self,
                    edge
                )
                planSpace(self, tail)
                self.state = "rightLoop";
                return tail.right
            } else {
                if (_sw85920000_ === "question") {
                    addEdgeToSub(
                        self,
                        edge
                    )
                    planSpace(self, tail)
                    self.state = "right";
                    return tail.right
                } else {
                    self.state = null;
                    return null
                }
            }
        } else {
            if (tail.down) {
                addEdgeToSub(
                    self,
                    edge
                )
                if (tail.type == "address") {
                    markFloor(
                        self,
                        tail
                    )
                    self.state = null;
                    return null
                } else {
                    self.state = "down";
                    return tail.down
                }
            } else {
                addEdgeToSub(
                    self,
                    edge
                )
                if (tail.left) {
                    addLowerCorner(
                        self,
                        tail
                    )
                    self.state = "left";
                    return tail.left
                } else {
                    self.state = null;
                    return null
                }
            }
        }
    }
}

function OuterCrawler_leftLoop_default(self, edge) {
    self.state = "leftLoop";
}

function OuterCrawler_leftLoop_onEdge(self, edge) {
    var head
    head = edge.head
    if (head.left) {
        self.state = "leftLoop";
        return head.left
    } else {
        if (head.down) {
            head.zoned = true
            edge.inner = self.sub
            self.state = "down";
            return head.down
        } else {
            self.state = "down";
            return markInnerSide(
            	self,
            	head
            )
        }
    }
}

function OuterCrawler_left_default(self, edge) {
    self.state = "left";
}

function OuterCrawler_left_onEdge(self, edge) {
    var head
    head = edge.head
    if (head.down) {
        self.state = "down";
        return head.down
    } else {
        self.state = "left";
        return head.left
    }
}

function OuterCrawler_rightLoop_default(self, edge) {
    self.state = "rightLoop";
}

function OuterCrawler_rightLoop_onEdge(self, edge) {
    self.state = "downLoop";
    return edge.tail.down
}

function OuterCrawler_right_default(self, edge) {
    self.state = "right";
}

function OuterCrawler_right_onEdge(self, edge) {
    var tail
    tail = edge.tail
    if (tail.up) {
        self.state = null;
        return null
    } else {
        addUpperCorner(
            self,
            tail
        )
        self.state = "down";
        return tail.down
    }
}

function Params_draw(render, item) {
    var format, left, padding, texId, y
    padding = Config.ICON_PADDING
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "rectangle",
        item.x,
        item.y,
        [item.w, item.h],
        format
    )
    if (item.keyTb) {
        left = item.x - item.w + padding
        y = item.y - item.h + padding
        drawTextLeft(
            render,
            texId,
            item.keyTb.tokens,
            left,
            y
        )
        if (item.tb) {
            y += padding + item.keyTb.height
            drawTextLeft(
                render,
                texId,
                item.tb.tokens,
                left,
                y
            )
        }
    } else {
        if (item.tb) {
            drawLeftTextInRect(
                render,
                texId,
                item.tb,
                item
            )
        }
    }
}

function Params_flow(render, item) {
    var height, keyTb, tb, width
    width = 0
    height = 0
    if (item.keyText) {
        keyTb = flowText(
            render,
            item.keyText,
            Config.DEF_ICON_WIDTH
        )
        keyTb.tokens.forEach(
            setKeywordColor
        )
        width = keyTb.width
        height = keyTb.height
    }
    if (item.text) {
        if (height > 0) {
            height += Config.ICON_PADDING
        }
        tb = requestTextFlow(render, item)
        width = Math.max(width, tb.width)
        height += tb.height
    }
    item.tb = tb
    item.keyTb = keyTb
    item.w = snapSize(width)
    item.h = snapSize(height)
}

function Pause_draw(render, item) {
    var format, points, texId
    format = getFormatForIcon(
        "loopbegin"
    )
    points = makePausePoints(item.w, item.h)
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        points,
        format
    )
    drawCenterTextInRect(
        render,
        texId,
        item.tb,
        item
    )
}

function Pause_flow(render, item) {
    Select_flow(render, item)
}

function Question_draw(render, item) {
    var ADD, box, diaWidth, fontHeight, format, labelColor, leftText, leftWidth, leftX, leftY, rightText, rightWidth, rightX, rightY, shape, texId, wn, wy
    ADD = Config.SNAP
    diaWidth = item.w + ADD
    wy = yesWidth(render) * 1.2
    wn = noWidth(render)
    fontHeight = render.getFontHeight()
    texId = render.createTexture(
    	item.x,
    	item.y,
    	- diaWidth,
    	- item.h,
    	diaWidth * 2 + Math.floor(1.5 * Math.max(wy, wn)),
    	item.h * 2 + fontHeight * 2,
    	"icons"
    )
    shape = makeQuestionPoints(
    	item.w + 2,
    	item.h
    )
    format = getFormatForIcon(item.type)
    render.drawShape(
    	texId,
    	"poly",
    	item.x,
    	item.y,
    	shape,
    	format
    )
    box = {
        x : item.x + Config.SNAP * 1,
        y : item.y,
        w : item.w,
        h : item.h
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        box
    )
    if (item.flag1) {
        leftWidth = wy
        rightWidth = wn
        leftText = yes()
        rightText = no()
    } else {
        leftWidth = wn
        rightWidth = wy
        leftText = no()
        rightText = yes()
    }
    leftX = -leftWidth - Math.floor(fontHeight / 4)
    leftY = item.h + Math.floor(fontHeight * 1.2)
    rightX = item.w + Math.floor(fontHeight * 0.6)
    rightY = -Math.floor(fontHeight * 0.3)
    labelColor = getYesColor()
    render.drawText(
    	texId,
    	leftText,
    	leftX + item.x,
    	leftY + item.y,
    	labelColor
    )
    render.drawText(
    	texId,
    	rightText,
    	rightX + item.x,
    	rightY + item.y,
    	labelColor
    )
}

function Question_flow(render, item) {
    Action_flow(
        render,
        item
    )
    item.w += Config.SNAP * 1
}

function SInput_draw(render, item) {
    var format, points, pos, texId
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    points = makeInputPoints(item.w, item.h)
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        points,
        format
    )
    pos = {
        x : item.x + INSERTION * 2,
        y : item.y,
        w : item.w,
        h : item.h
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        pos
    )
}

function SOutput_draw(render, item) {
    var format, points, pos, texId
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    points = makeOutputPoints(item.w, item.h)
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        points,
        format
    )
    pos = {
        x : item.x,
        y : item.y,
        w : item.w,
        h : item.h
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        pos
    )
}

function Select_draw(render, item) {
    var ADD, format, points, pos, texId
    ADD = Config.SNAP / 2
    format = getFormatForIcon(
        item.type
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    points = makeSelectPoints(
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "poly",
        item.x,
        item.y,
        points,
        format
    )
    pos = {
        x : item.x + ADD,
        y : item.y,
        w : item.w,
        h : item.h
    }
    drawLeftTextInRect(
        render,
        texId,
        item.tb,
        pos
    )
}

function Select_flow(render, item) {
    LoopBegin_flow(render, item)
}

function Selection() {
    this.prims = {}
}

function SingleQuoter_Created_default(self, msg) {
    self.state = "Created";
}

function SingleQuoter_Created_operator(self, msg) {
    self.chars = [msg]
    self.state = "Normal";
}

function SingleQuoter_Escaping_default(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function SingleQuoter_Escaping_operator(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function SingleQuoter_Normal_alpha(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function SingleQuoter_Normal_digit(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function SingleQuoter_Normal_operator(self, msg) {
    var token
    if (msg === module.SINGLE_QUOTE) {
        addAnyChar(
            self,
            msg
        )
        token = makeTokenFromChars(
            self,
            "string"
        )
        self.next.completeToken(
            token
        )
        self.state = null;
    } else {
        if (msg === module.BACK) {
            addAnyChar(
                self,
                msg
            )
            self.state = "Escaping";
        } else {
            addAnyChar(
                self,
                msg
            )
            self.state = "Normal";
        }
    }
}

function SingleQuoter_Normal_whitespace(self, msg) {
    addAnyChar(
        self,
        msg
    )
    self.state = "Normal";
}

function Skewer(vertical) {
    this.id = ""
    this.nodes = []
    this.edges = []
    this.coord = -1
    this.boundary = 0
    this.vertical = vertical
}

function SkewerLink(low, high) {
    this.low = low
    this.high = high
    this.distance = 0
}

function Socket(x, y, op, type) {
    this.id = ""
    this.x = x
    this.y = y
    this.type = type
    this.op = op
    this.on = false
    this.edge = null
    this.node = null
    this.links = []
    this.finalTarget = null
    this.box = Utils.boxFromPoint(
        x,
        y,
        Config.SOCKET_TOUCH_RADIUS,
        Config.SOCKET_TOUCH_RADIUS
    )
}

function SourceFlower_Created_default(self, msg) {
    self.state = "Created";
}

function SourceFlower_Created_init(self, msg) {
    self.render = msg
    self.tokens = []
    self.widths = []
    self.lines = 0
    self.fontHeight = self.render.getFontHeight()
    self.lineHeight = Math.floor(self.fontHeight *
      LineHeight)
    self.height = self.fontHeight
    self.y = self.fontHeight
    self.x = 0
    self.state = "Normal";
}

function SourceFlower_Normal_eol(self, msg) {
    if (self.lines > MaxLines) {
        self.state = null;
    } else {
        addLine(self)
        self.state = "Normal";
    }
}

function SourceFlower_Normal_onToken(self, msg) {
    if (msg.type == "whitespace") {
        advanceOnWhitespace(
            self,
            msg
        )
    } else {
        placeToken(
            self,
            msg
        )
    }
    self.state = "Normal";
}

function Storage(type, name, version) {
    this.type = type
    this.name = name
    this.nextId = 1
    this.items = {}
    this.version = version
    this.keywords = {}
    this.params = ""
}

function Sub() {
    this.id = ""
    this.color = makeRandomColor()
    this.outer = {}
    this.inner = {}
    this.outerArrPads = {}
}

function Table(name) {
    var self
    this.name = name
    this.nextId = 1
    this.rows = {}
    this.count = 0
    self = this
    this.insert = function(row) {
        return Table_insert(self, row)
    }
    this.get = function(id) {
        return Table_get(self, id)
    }
    this.remove = function(id) {
        return Table_remove(self, id)
    }
    this.clear = function() {
        return Table_clear(self)
    }
}

function Table_clear(table) {
    table.nextId = 1
    table.rows = {}
    table.count = 0
}

function Table_get(table, id) {
    var message, row
    if (id) {
        row = table.rows[id]
        if (row) {
            return row
        } else {
            message = table.name + 
             " get: row not found. id=" +
             id
            throw Error(message)
        }
    } else {
        message = table.name + 
         " get: id is null or empty"
        throw Error(message)
    }
}

function Table_insert(table, row) {
    var id, message
    id = row.id
    if (id) {
        
    } else {
        id = table.nextId.toString()
        table.nextId++
        row.id = id
    }
    if (id in table.rows) {
        message = table.name + 
         " insert: id not unique. id=" +
         id
        throw Error(message)
    } else {
        table.rows[id] = row
        table.count++
        return id
    }
}

function Table_remove(table, id) {
    var row
    row = table.rows[id]
    if (row) {
        delete table.rows[id]
        table.count--
        return row
    } else {
        return null
    }
}

function TextLexer_Identifier_default(self, msg) {
    self.next.addChar(msg)
    self.state = "Identifier";
}

function TextLexer_Identifier_whitespace(self, msg) {
    sendWhitespace(
        self,
        msg
    )
    self.state = "Idle";
}

function TextLexer_Idle_alpha(self, msg) {
    self.next.identifier(
        msg
    )
    self.state = "Identifier";
}

function TextLexer_Idle_digit(self, msg) {
    self.next.identifier(
        msg
    )
    self.state = "Identifier";
}

function TextLexer_Idle_operator(self, msg) {
    self.next.identifier(
        msg
    )
    self.state = "Identifier";
}

function TextLexer_Idle_whitespace(self, msg) {
    sendWhitespace(
        self,
        msg
    )
    self.state = "Idle";
}

function Token(type) {
    this.type = type
    this.text = null
}

function TokenBuilder_Building_addChar(self, msg) {
    self.chars.push(
        msg
    )
    self.state = "Building";
}

function TokenBuilder_Building_endToken(self, msg) {
    endToken(self)
    self.state = "Empty";
}

function TokenBuilder_Building_eol(self, msg) {
    endToken(self)
    self.next.eol()
    self.state = "Empty";
}

function TokenBuilder_Building_finish(self, msg) {
    endToken(self)
    self.state = "Empty";
}

function TokenBuilder_Building_identifier(self, msg) {
    endToken(self)
    startToken(
        self,
        "identifier",
        msg
    )
    self.state = "Building";
}

function TokenBuilder_Building_number(self, msg) {
    endToken(self)
    startToken(
        self,
        "number",
        msg
    )
    self.state = "Building";
}

function TokenBuilder_Building_sendToken(self, msg) {
    endToken(self)
    self.next.onToken(
        msg
    )
    self.state = "Empty";
}

function TokenBuilder_Empty_addChar(self, msg) {
    console.error(
    	"unexpected addChar in state" +
    	self.state
    )
    self.state = "Empty";
}

function TokenBuilder_Empty_eol(self, msg) {
    self.next.eol()
    self.state = "Empty";
}

function TokenBuilder_Empty_identifier(self, msg) {
    startToken(
        self,
        "identifier",
        msg
    )
    self.state = "Building";
}

function TokenBuilder_Empty_number(self, msg) {
    startToken(
        self,
        "number",
        msg
    )
    self.state = "Building";
}

function TokenBuilder_Empty_sendToken(self, msg) {
    self.next.onToken(
        msg
    )
    self.state = "Empty";
}

function TraverseStep(node1, node2) {
    this.node1 = node1
    this.node2 = node2
    this.down = true
    this.back = false
}

function Undo() {
    this.next = 0
    this.steps = []
}

function Visuals() {
    this.header = null
    this.end = null
    this.params = null
    this.branches = []
    this.nextId = 1
    this.itemsToNodes = {}
    this.tempEdges = []
    this.nodes = new Table("nodes")
    this.edges = new Table("edges")
    this.skewers = new Table("skewers")
    this.levels = new Table("levels")
    this.sockets = new Table("sockets")
    this.subs = new Table("subs")
    this.byType = {}
    this.skewerLinks = new MTable(
        "skewerLinks",
        ["low", "high"]
    )
    this.levelLinks = new MTable(
        "levelLinks",
        ["low", "high"]
    )
}

function addAnyChar(self, ch) {
    self.chars.push(ch)
}

function addArrowPad(sub, edge) {
    var targetId
    if (edge.role == "down") {
        targetId = edge.finalTarget.itemId
        sub.outerArrPads[targetId] = edge
    }
}

function addBText(lines, id, type, text, one, two) {
    var btext, line, sep
    sep = "|"
    btext = bEncode(text)
    line = id + sep +
    	type + sep +
    	btext
    if (one) {
        line += (sep + one)
    }
    if (two) {
        line += (sep + two)
    }
    lines.push(line)
}

function addBranch(visuals, node) {
    var info
    info = {
        node : node,
        addresses : [],
        topNode : null,
        bottomNode : null
    }
    visuals.branches.push(info)
}

function addBranchToSearch(node, items, visited) {
    var visuals
    visuals = module.visuals
    while (true) {
        if ((node.type == "end") || (node.type == "address")) {
            break;
        }
        if (node.itemId) {
            if (node.itemId in visited) {
                break;
            }
            addNodeToSearch(
                node,
                items,
                visited
            )
        }
        var _ind12390 = 0;
        var _col12390 = node.next;
        var _len12390 = _col12390.length;
        while (true) {
            if (_ind12390 < _len12390) {
                
            } else {
                break;
            }
            var next = _col12390[_ind12390];
            addBranchToSearch(
                next,
                items,
                visited
            )
            _ind12390++;
        }
    }
}

function addCandy(x, y, result) {
    var handle
    handle = {
        x : x,
        y : y
    }
    result.push(handle)
}

function addChar(self, code) {
    self.chars.push(code)
}

function addCharHandler(self, name) {
    self[name] = function(ch) {
        addAnyChar(self, ch)
    }
}

function addCompleteResend(self, name) {
    var method
    method = function(msg) {
        completeResend(self, name, msg)
    }
    self[name] = method
}

function addEdgeSubRecord(records, edge) {
    var record, targetId
    targetId = edge.finalTarget.itemId
    record = {
        type : "edge",
        element : edge,
        targetId : targetId,
        id : edge.id
    }
    records[targetId] = record
}

function addEdgeToSub(crawler, edge) {
    var existing, sub, targetId, visuals
    visuals = module.visuals
    sub = crawler.sub
    targetId = edge.finalTarget.itemId
    existing = sub.outer[targetId]
    if ((existing) && (!(existing.type == "edge"))) {
        
    } else {
        addEdgeSubRecord(
            sub.outer,
            edge
        )
    }
}

function addIfToBText(lines, item) {
    var btext, line, sep
    sep = "|"
    btext = bEncode(item.text)
    line = item.id + sep +
    	item.type + sep +
    	btext + sep
    if (item.flag1) {
        line += "down"
    } else {
        line += "right"
    }
    line += (sep + item.one)
    line += (sep + item.two)
    lines.push(line)
}

function addInnerEdgeToSub(crawler, edge) {
    var sub
    sub = crawler.sub
    addEdgeSubRecord(
        sub.inner,
        edge
    )
}

function addItem(parentBlock, item) {
    var text
    parentBlock.statement.items.push(item)
    parentBlock.prev = item.type
    text = item.text || ""
    parentBlock.seqStart = isSeqStart(item)
}

function addItemWithLength(statement, item) {
    statement.items.push(item)
    statement.length += item.length
}

function addKeyword(keywords, name, output) {
    if (keywords[name]) {
        output.push(name)
    }
}

function addLine(self) {
    self.widths.push(
        self.x
    )
    self.y += self.lineHeight
    self.x = 0
    self.height += self.lineHeight
    self.lines ++
}

function addLongOp(op) {
    var first, longs, second
    var _sw109640000_ = 0;
    longs = module.longOps
    _sw109640000_ = op.length;
    if (_sw109640000_ === 2) {
        first = getCreateObj(
            longs,
            op[0]
        )
        getCreateObj(
            first,
            op[1]
        )
    } else {
        if (_sw109640000_ === 3) {
            
        } else {
            throw "Unexpected switch value: " + _sw109640000_;
        }
        first = getCreateObj(
            longs,
            op[0]
        )
        second = getCreateObj(
            first,
            op[1]
        )
        second.three = true
        getCreateObj(
            second,
            op[2]
        )
    }
}

function addLowerCorner(crawler, node) {
    var existing, oldNode, sub, targetId, visuals
    visuals = module.visuals
    sub = crawler.sub
    targetId = node.finalTarget.itemId
    existing = sub.outer[targetId]
    if ((existing) && (!(existing.type == "edge"))) {
        oldNode = existing.element
        if (oldNode.down) {
            
        } else {
            addNodeSubRecord(
                sub.outer,
                node
            )
        }
    } else {
        addNodeSubRecord(
            sub.outer,
            node
        )
    }
}

function addNoWs(self, token) {
    if ((token.type == "whitespace") || (token.type == "eol")) {
        
    } else {
        if (token.type == "identifier") {
            if (token.text in module.keyOps) {
                token.type = "operator"
            } else {
                if (token.text in module.keywords) {
                    token.type = "keyword"
                }
            }
        }
        self.tokens.push(token)
    }
}

function addNodeSubRecord(records, node) {
    var record, targetId
    targetId = node.finalTarget.itemId
    record = {
        type : "node",
        element : node,
        targetId : targetId,
        id : node.id
    }
    records[targetId] = record
}

function addNodeToSearch(node, items, visited) {
    var item, text, tokens
    if (node) {
        visited[node.itemId] = true
        if (node.text) {
            text = node.text
            tokens = lexSearch(text)
            item = {
                id : node.itemId,
                type : node.type,
                tokens : tokens.tokens,
                tokensLow : tokens.tokensLow,
                text : text,
                textLow : text.toLowerCase(),
                occurences : []
            }
            items.push(item)
        }
    }
}

function addOccurence(item, begin, end) {
    var occurence, ordinal, search
    search = module.search
    ordinal = item.occurences.length
    occurence = {
        item : item,
        id : item.id,
        begin : begin,
        end : end,
        before : "",
        match : "",
        after : "",
        active : true,
        ordinal : ordinal
    }
    search.occurences.push(
        occurence
    )
    item.occurences.push(
        occurence
    )
    updateOccurence(
        occurence
    )
}

function addOne(headNode, node) {
    var selection
    selection = module.selection
    if (node.id in selection.prims) {
        return headNode
    } else {
        selection.prims[node.id] = "node"
        if ((headNode) && (!(node.y < headNode.y))) {
            return headNode
        } else {
            return node
        }
    }
}

function addOp(self, token) {
    self.tokens.push(token)
}

function addParameters() {
    var edits
    if (module.visuals.params) {
        
    } else {
        edits = addParamsEdits()
        editAndSave(edits)
    }
}

function addParamsEdits() {
    var edits
    edits = []
    createItem(
        edits,
        {type: "params"}
    )
    return edits
}

function addParamsSocket() {
    var header, socket, visuals
    visuals = module.visuals
    header = visuals.header
    if (visuals.params) {
        
    } else {
        socket = new Socket(
            header.x + header.w,
            header.y,
            "params"
        )
        visuals.sockets.insert(
            socket
        )
    }
}

function addParamsToSearch(node, items) {
    var item, text, tokens
    if ((node) && (node.params)) {
        text = node.params
        tokens = lexSearch(text)
        item = {
            id : node.itemId,
            type : node.type,
            tokens : tokens.tokens,
            tokensLow : tokens.tokensLow,
            text : text,
            textLow : text.toLowerCase(),
            occurences : []
        }
        items.push(item)
    }
}

function addPropertiesItem(node, menu) {
    var _sw128990000_ = 0;
    _sw128990000_ = node.type;
    if ((_sw128990000_ === "params") || (_sw128990000_ === "header")) {
        pushSeparator(menu)
        pushMenuItem(
            menu,
            "MES_PROPERTIES",
            null,
            changeDiagramProperties
        )
    }
}

function addRange(from, to) {
    if (from) {
        var _ind6012 = 0;
        var _col6012 = from;
        var _len6012 = _col6012.length;
        while (true) {
            if (_ind6012 < _len6012) {
                
            } else {
                break;
            }
            var item = _col6012[_ind6012];
            to.push(item)
            _ind6012++;
        }
    }
}

function addReplaceCommand(edits, id, type, newText) {
    if (type == "params") {
        updateDiagram(
            edits,
            {params: newText}
        )
    } else {
        updateItem(
            edits,
            id,
            {text:newText}
        )
    }
}

function addSearchToken(self, token) {
    var tokenLow
    tokenLow = {
        pos : token.pos,
        text : token.text.toLowerCase()
    }
    self.tokens.push(token)
    self.tokensLow.push(tokenLow)
}

function addSelectToBText(lines, item) {
    var btext, caseIcon, items, line, sep
    items = module.storage.items
    sep = "|"
    btext = bEncode(item.text)
    line = item.id + sep +
    	item.type + sep +
    	btext
    caseIcon = items[item.one]
    while (true) {
        line += (sep + caseIcon.one + sep +
        	bEncode(caseIcon.text))
        if (caseIcon.two) {
            
        } else {
            break;
        }
        caseIcon = items[caseIcon.two]
    }
    lines.push(line)
}

function addSingleItem(parentBlock, item) {
    if (isSeparator(item)) {
        addItem(
            parentBlock,
            item
        )
        startStatement(
            parentBlock
        )
    } else {
        if (isNewStart(parentBlock.prev, item)) {
            startStatement(
                parentBlock
            )
            addItem(
                parentBlock,
                item
            )
        } else {
            addItem(
                parentBlock,
                item
            )
            if (isSingleComment(item)) {
                addItem(
                    parentBlock,
                    createEol()
                )
            }
        }
    }
}

function addSpaces(block) {
    var block2, statement2
    block2 = createBlock2(block.seq)
    var _ind11359 = 0;
    var _col11359 = block.statements;
    var _len11359 = _col11359.length;
    while (true) {
        if (_ind11359 < _len11359) {
            
        } else {
            break;
        }
        var statement = _col11359[_ind11359];
        statement2 = addSpacesToStatement(
            statement
        )
        block2.statements.push(statement2)
        block2.length += statement2.length
        _ind11359++;
    }
    block2.length += (block2.statements.length - 1)
    return block2
}

function addSpacesToStatement(statement) {
    var item2, result, state
    var _sw114000000_ = 0;
    var _sw128220000_ = 0;
    var _sw114360000_ = 0;
    result = createStatement()
    state = "operator"
    var _ind11397 = 0;
    var _col11397 = statement.items;
    var _len11397 = _col11397.length;
    while (true) {
        if (_ind11397 < _len11397) {
            
        } else {
            break;
        }
        var item = _col11397[_ind11397];
        _sw114000000_ = item.type;
        if (_sw114000000_ === "operator") {
            item.length = item.text.length
            if (item.text in module.noSpaces) {
                addItemWithLength(
                    result,
                    item
                )
                state = "identifier"
            } else {
                _sw128220000_ = item.text;
                if (_sw128220000_ === ":") {
                    addItemWithLength(
                        result,
                        item
                    )
                    addItemWithLength(
                        result,
                        createSpace()
                    )
                } else {
                    if (_sw128220000_ === ".") {
                        addItemWithLength(
                            result,
                            createBreak()
                        )
                        addItemWithLength(
                            result,
                            item
                        )
                    } else {
                        if ((_sw128220000_ === "++") || (_sw128220000_ === "--")) {
                            addItemWithLength(
                                result,
                                item
                            )
                        } else {
                            if (((_sw128220000_ === "-") && (item.text == "-")) && ((state == "operator") || (state == "keyword"))) {
                                addItemWithLength(
                                    result,
                                    item
                                )
                            } else {
                                addItemWithLength(
                                    result,
                                    createSpace()
                                )
                                addItemWithLength(
                                    result,
                                    item
                                )
                                addItemWithLength(
                                    result,
                                    createSpace()
                                )
                            }
                        }
                    }
                }
                state = item.type
            }
        } else {
            if (_sw114000000_ === "keyword") {
                item.length = item.text.length
                _sw114360000_ = item.text;
                if (((_sw114360000_ === "else") || (_sw114360000_ === "finally")) || (_sw114360000_ === "catch")) {
                    addItemWithLength(
                        result,
                        createSpace()
                    )
                    addItemWithLength(
                        result,
                        item
                    )
                    addItemWithLength(
                        result,
                        createSpace()
                    )
                } else {
                    if (_sw114360000_ === "try") {
                        addItemWithLength(
                            result,
                            item
                        )
                        addItemWithLength(
                            result,
                            createSpace()
                        )
                    } else {
                        if ((_sw114360000_ === "this") || (_sw114360000_ === "super")) {
                            addItemWithLength(
                                result,
                                item
                            )
                        } else {
                            addItemWithLength(
                                result,
                                item
                            )
                            addItemWithLength(
                                result,
                                createSpace()
                            )
                        }
                    }
                }
            } else {
                item2 = computeLength(item)
                addItemWithLength(
                    result,
                    item2
                )
            }
            state = item.type
        }
        _ind11397++;
    }
    return result
}

function addToList(newItem, existing) {
    var prev
    prev = existing.prev
    prev.next = newItem
    newItem.prev = prev
    newItem.next = existing
    existing.prev = newItem
}

function addToSelection(node) {
    var head, selection, wayDown, wayUp
    selection = module.selection
    if (selection.head) {
        head = getNode(selection.head)
    } else {
        head = null
    }
    wayUp = findWayUp(
        node,
        head
    )
    if (wayUp.length) {
        selectPath(wayUp, head)
        redrawCanvas()
        return true
    } else {
        wayDown = findWayUp(
            head,
            node
        )
        if (wayDown.length) {
            selectPath(wayDown, head)
            redrawCanvas()
            return true
        } else {
            return false
        }
    }
}

function addToUndoCore(undo, before, commands, after) {
    var newSteps, step
    newSteps = undo.steps.slice(
        0,
        undo.next
    )
    step = {
        before : before,
        commands : commands,
        after : after,
        info : CallTrace.peek()
    }
    newSteps.push(step)
    undo.steps = newSteps
    undo.next = newSteps.length
}

function addTrace(name, args) {
    CallTrace.add(name, args)
}

function addUpperCorner(crawler, node) {
    var sub
    sub = crawler.sub
    addNodeSubRecord(
        sub.outer,
        node
    )
}

function addressDestinations(node, menu) {
    var makeItem, notCurrent, selected
    notCurrent = function(branch) {
        return branch.node != node.branch
    }
    selected = module.visuals.branches.filter(
        notCurrent
    )
    makeItem = function(branch) {
        makePointToItem(node, branch, menu)
    }
    selected.forEach(
        makeItem
    )
}

function adjacentToAddress(record, source) {
    if ((record.element.noBranch) && (source.tail.type == "address")) {
        return true
    } else {
        return false
    }
}

function advanceOnWhitespace(self, msg) {
    var x, x2
    x = self.x
    if (msg.text == "\t") {
        x2 = getTabPosition(
            self,
            x
        )
    } else {
        x2 = getSpaceWidth(self) + x
    }
    self.x = x2
}

function arrayFrom(array) {
    var result
    result = []
    if (array) {
        var _ind12728 = 0;
        var _col12728 = array;
        var _len12728 = _col12728.length;
        while (true) {
            if (_ind12728 < _len12728) {
                
            } else {
                break;
            }
            var item = _col12728[_ind12728];
            result.push(item)
            _ind12728++;
        }
    }
    return result
}

function arrayToSet(array) {
    var result
    result = {}
    var _ind13094 = 0;
    var _col13094 = array;
    var _len13094 = _col13094.length;
    while (true) {
        if (_ind13094 < _len13094) {
            
        } else {
            break;
        }
        var key = _col13094[_ind13094];
        result[key] = true
        _ind13094++;
    }
    return result
}

function arrowDown(ctrl, shift, visibleBox) {
    var first, node, nodes
    nodes = getNodesFromSelection()
    if (nodes.length == 0) {
        
    } else {
        first = nodes[0]
        if (first.down) {
            node = getDown(first)
            selectNode(node)
        } else {
            node = findClosestNode(function(n) {
            	return n.y > first.y
            }, first, true)
            if (node) {
                selectNode(node)
            }
        }
    }
}

function arrowLeft(ctrl, shift, visibleBox) {
    var first, node, nodes
    nodes = getNodesFromSelection()
    if (nodes.length == 0) {
        
    } else {
        first = nodes[0]
        if (first.left) {
            node = getLeft(first)
            selectNode(node)
        } else {
            node = findClosestNode(function(n) {
            	return n.x < first.x
            }, first, false)
            if (node) {
                selectNode(node)
            }
        }
    }
}

function arrowRight(ctrl, shift, visibleBox) {
    var first, node, nodes
    nodes = getNodesFromSelection()
    if (nodes.length == 0) {
        
    } else {
        first = nodes[0]
        if (first.right) {
            node = getRight(first)
            selectNode(node)
        } else {
            node = findClosestNode(function(n) {
            	return n.x > first.x
            }, first, false)
            if (node) {
                selectNode(node)
            }
        }
    }
}

function arrowUp(ctrl, shift, visibleBox) {
    var first, node, nodes
    nodes = getNodesFromSelection()
    if (nodes.length == 0) {
        
    } else {
        first = nodes[0]
        if (first.up) {
            node = getUp(first)
            selectNode(node)
        } else {
            node = findClosestNode(function(n) {
            	return n.y < first.y
            }, first, true)
            if (node) {
                selectNode(node)
            }
        }
    }
}

function autoFormat(type, text) {
    var tokens
    if ((shouldAutoformat(type)) && (!(isHuman()))) {
        tokens = lexSource(text)
        tokens = prettify(tokens, type)
        return printTokens(tokens)
    } else {
        return text
    }
}

function autoSizeIcons() {
    
}

function bEncode(text) {
    var c, i, result
    text = text || ""
    result = ""
    i = 0;
    while (true) {
        if (i < text.length) {
            
        } else {
            break;
        }
        c = text[i]
        if (c == "\n") {
            result += "\\n"
        } else {
            if (c == "|") {
                result += "\\|"
            } else {
                result += c
            }
        }
        i++;
    }
    return result
}

function beginBlockSelect() {
    unselectEdges()
}

function blockSelect(box) {
    var changed, visuals
    visuals = module.visuals
    changed = false
    var _ind9776 = 0;
    var _col9776 = visuals.nodes.rows;
    var _keys9776 = Object.keys(_col9776); 
    var _len9776 = _keys9776.length;
    while (true) {
        if (_ind9776 < _len9776) {
            
        } else {
            break;
        }
        var id = _keys9776[_ind9776]; var node = _col9776[id];
        if ((((isSelected(id)) || (!(canSelectNode(node)))) || (!(Utils.boxesIntersect(node.box, box)))) || (!(addToSelection(node)))) {
            
        } else {
            changed = true
        }
        _ind9776++;
    }
    return changed
}

function branchInsert(socket) {
    var branchId
    branchId = getSocketBranchId(socket)
    return branchInsertAt(branchId)
}

function branchInsertAt(branchId) {
    var edits, fields, items, name, newId, oldTargets, targetId
    edits = moveBranchIdsRight(
        branchId
    )
    targetId = getBranchItemId(
        branchId
    )
    name = nextBranchName()
    fields = {
        type : "branch",
        branchId : branchId,
        text : name,
        one : targetId
    }
    newId = createItem(
        edits,
        fields
    )
    items = module.storage.items
    oldTargets = {}
    oldTargets[targetId] = true
    redirectBranch(
        items,
        oldTargets,
        newId,
        edits
    )
    return edits
}

function branchInsertEnd() {
    var branchId, branches, edits, endId, fields, name
    branches = module.visuals.branches
    edits = []
    branchId = branches.length + 1
    endId = createItem(
        edits,
        {type: "end"}
    )
    name = nextBranchName()
    fields = {
        type : "branch",
        branchId : branchId,
        text : name,
        one : endId
    }
    createItem(
        edits,
        fields
    )
    return edits
}

function branchInsertL(node) {
    var branchId
    branchId = node.branchId
    return branchInsertAt(branchId)
}

function branchInsertR(node) {
    var branchId
    branchId = node.branchId + 1
    return branchInsertAt(branchId)
}

function branchLabel() {
    return translate("DIA_BRANCH")
}

function branchMenu(node, menu) {
    var isLast, lowest
    isLast = module.visuals.branches.length == node.branchId
    pushMenuItem(
        menu,
        "MES_INSERT_BRANCH_LEFT",
        "branch.png",
        brutal(branchInsertL, node)
    )
    if (isLast) {
        lowest = goDown(node)
        if (lowest.type == "end") {
            
        } else {
            pushMenuItem(
                menu,
                "MES_INSERT_BRANCH_RIGHT",
                "branch.png",
                brutal(branchInsertR, node)
            )
            pushMenuItem(
                menu,
                "MES_INSERT_END_BRANCH",
                "end.png",
                brutal(branchInsertEnd, null)
            )
        }
    } else {
        pushMenuItem(
            menu,
            "MES_INSERT_BRANCH_RIGHT",
            "branch.png",
            brutal(branchInsertR, node)
        )
    }
}

function brutal(action, node) {
    return function() {
    	var edits = action(node)
    	brutalChange(edits)
    }
}

function brutalChange(edits) {
    if (edits.length) {
        deselectAll()
        editAndSave(edits)
    }
}

function buildArrowUp(visuals, loop) {
    var arrow, next1, top
    top = createJunction(
        visuals,
        loop
    )
    arrow = createEdge(
        visuals,
        loop,
        top,
        false
    )
    arrow.role = "arrow"
    next1 = loop.next[0]
    makeDownEdge(
        visuals,
        loop,
        next1,
        next1
    )
    return next1
}

function buildBackgroundMenu() {
    var menu, type
    menu = []
    if (module.readonly) {
        
    } else {
        type = getClipboardType()
        if ((type) && (!(type == "text"))) {
            pushMenuItem(
                menu,
                "MES_PASTE",
                null,
                paste
            )
        }
    }
    return menu
}

function buildBlockMenu() {
    var menu = [];
    pushMenuItem(
        menu,
        "MES_COPY",
        null,
        easy(copy, null)
    )
    if (module.readonly) {
        
    } else {
        pushMenuItem(
            menu,
            "MES_CUT",
            null,
            easy(cut, null)
        )
        pushSeparator(menu)
        pushMenuItem(
            menu,
            "MES_DELETE",
            null,
            easy(deleteSelection, null)
        )
    }
    return menu;
}

function buildBoxes(visuals) {
    var bottom, edges, left, nodes, right, top, tr
    tr = Config.SOCKET_TOUCH_RADIUS
    nodes = visuals.nodes
    var _ind4799 = 0;
    var _col4799 = nodes.rows;
    var _keys4799 = Object.keys(_col4799); 
    var _len4799 = _keys4799.length;
    while (true) {
        if (_ind4799 < _len4799) {
            
        } else {
            break;
        }
        var id = _keys4799[_ind4799]; var node = _col4799[id];
        if (isDrawableNode(node)) {
            node.x = getX(node)
            node.y = getY(node)
            if ((node.type == "junction") || (node.type == "arrow-loop")) {
                node.box = Utils.boxFromPoint(
                    node.x,
                    node.y,
                    tr,
                    tr
                )
            } else {
                node.box = Utils.boxFromPoint(
                    node.x,
                    node.y,
                    node.w,
                    node.h
                )
            }
        }
        _ind4799++;
    }
    edges = visuals.edges
    var _ind4809 = 0;
    var _col4809 = edges.rows;
    var _keys4809 = Object.keys(_col4809); 
    var _len4809 = _keys4809.length;
    while (true) {
        if (_ind4809 < _len4809) {
            
        } else {
            break;
        }
        var id = _keys4809[_ind4809]; var edge = _col4809[id];
        if (edge.vertical) {
            left = edge.head.x - tr
            top = edge.head.y
            right = edge.head.x + tr
            bottom = edge.tail.y
        } else {
            left = edge.head.x
            top = edge.head.y - tr
            right = edge.tail.x
            bottom = edge.head.y + tr
        }
        edge.box = new Utils.Box(
            left,
            top,
            right,
            bottom
        )
        _ind4809++;
    }
}

function buildDoubleQuoter() {
    var machine
    machine = new DoubleQuoter()
    machine.eol = function() {
        errorOnEol(machine)
    }
    machine.finish = function() {
        errorOnFinish(machine)
    }
    return machine
}

function buildDrnCandies(item) {
    var bottom, candies, left, right, top
    candies = []
    left = item.x - item.w
    right = item.x + item.w
    top = item.y - item.h
    bottom = item.y + item.h
    addCandy(
        left,
        top,
        candies
    )
    addCandy(
        left,
        item.y,
        candies
    )
    addCandy(
        left,
        bottom,
        candies
    )
    addCandy(
        right,
        top,
        candies
    )
    addCandy(
        right,
        item.y,
        candies
    )
    addCandy(
        right,
        bottom,
        candies
    )
    addCandy(
        item.x,
        top,
        candies
    )
    addCandy(
        item.x,
        bottom,
        candies
    )
    return candies
}

function buildManhattan(visuals, startNode) {
    var bottom, jun2, jun3, mountRight, mountUp, node1, node2, stack, step, top
    stack = []
    planNextSteps(
        visuals,
        stack,
        startNode
    )
    while (true) {
        if (stack.length == 0) {
            break;
        }
        step = stack.pop()
        node1 = step.node1
        node2 = step.node2
        if (step.back) {
            if (step.down) {
                if (node2.rightEdge) {
                    jun2 = splitRight(
                        visuals,
                        node2.rightEdge
                    )
                    makeDownEdge(
                        visuals,
                        node1,
                        jun2,
                        node2
                    )
                } else {
                    turn180up(
                        visuals,
                        node1,
                        node2
                    )
                }
            } else {
                top = getRight(node2)
                if (node2.upEdge) {
                    bottom = splitVerticalUp(
                        visuals,
                        node2.upEdge
                    )
                } else {
                    bottom = createJunction(
                        visuals,
                        node2
                    )
                    makeUpEdge(
                        visuals,
                        top,
                        bottom,
                        node2
                    )
                }
                node2.rightEdge = makeRightEdge(
                    visuals,
                    node1,
                    bottom,
                    node2
                )
            }
        } else {
            if (step.down) {
                
            } else {
                node1 = turnDown(
                    visuals,
                    node1,
                    node2
                )
            }
            if ((node2.prev.length == 1) || (!(node2.up))) {
                makeDownEdge(
                    visuals,
                    node1,
                    node2,
                    node2
                )
                planNextSteps(
                    visuals,
                    stack,
                    node2
                )
            } else {
                mountUp = node2.mountUp
                mountRight = node2.mountRight
                if (mountUp) {
                    makeDownEdge(
                        visuals,
                        node1,
                        mountUp,
                        node2
                    )
                    if (mountUp == node2.mountUp) {
                        node2.mountUp = null
                    }
                } else {
                    jun2 = createLeftUp(
                        visuals,
                        node2,
                        node2
                    )
                    makeDownEdge(
                        visuals,
                        node1,
                        jun2,
                        node2
                    )
                    if (mountRight) {
                        makeLeftEdge(
                            visuals,
                            mountRight,
                            jun2,
                            node2
                        )
                    } else {
                        jun3 = splitVertical(
                            visuals,
                            node2
                        )
                        makeLeftEdge(
                            visuals,
                            jun3,
                            jun2,
                            node2
                        )
                    }
                }
            }
        }
    }
}

function buildMenuAt(x, y) {
    var draggable, item, menu, node, nodes
    menu = []
    item = null
    draggable = findVisualItem(
        x,
        y
    )
    if (draggable) {
        if (draggable.elType == "node") {
            node = getNode(draggable.id)
            if ((node.type == "end") || (node.type == "junction")) {
                
            } else {
                nodes = getNodesFromSelection()
                if (nodes.length > 1) {
                    menu = buildBlockMenu()
                } else {
                    if (module.readonly) {
                        menu = buildMenuByTypeRo(node)
                    } else {
                        menu = buildMenuByType(node)
                    }
                }
                item = {
                    type : node.type,
                    id : node.itemId,
                    text : node.text
                }
                item.tokens = getNodeTokens(node)
                if (item.tokens) {
                    
                } else {
                    item.lines = getNodeLines(node)
                }
            }
        }
    } else {
        menu = buildBackgroundMenu()
    }
    return {
        menu : menu,
        item : item
    }
}

function buildMenuByType(node) {
    var cf, left, menu
    var _sw78450000_ = 0;
    menu = []
    if (canEditNodeText(node)) {
        if (node.type == "input") {
            pushMenuItem(
                menu,
                "MES_CHANGE_UPPER",
                null,
                function() {startEditUpperText(node.id)}
            )
        }
        pushMenuItem(
            menu,
            "MES_CHANGE_TEXT",
            null,
            function() {startEditText(node.id)}
        )
        pushSeparator(menu)
    }
    cf = getCopyFunction(node)
    if (cf) {
        pushMenuItem(
            menu,
            "MES_COPY",
            null,
            easy(copy, null)
        )
        if (canDelete(node)) {
            pushMenuItem(
                menu,
                "MES_CUT",
                null,
                easy(cutOneItem, node)
            )
        }
    }
    pushSeparator(menu)
    if (canEditNodeText(node)) {
        pushMenuItem(
            menu,
            "MES_COPY_TEXT",
            null,
            easy(copyText, node)
        )
    }
    if (getClipboardType() == "text") {
        pushMenuItem(
            menu,
            "MES_PASTE_TEXT",
            null,
            easy(pasteText, node)
        )
    }
    pushSeparator(menu)
    _sw78450000_ = node.type;
    if (_sw78450000_ === "header") {
        
    } else {
        if (_sw78450000_ === "question") {
            pushMenuItem(
                menu,
                "MES_SWAP_YES_NO",
                null,
                mild(swapYesNo, node)
            )
        } else {
            if (_sw78450000_ === "case") {
                left = getLeftCase(node)
                pushMenuItem(
                    menu,
                    "MES_INSERT_CASE_RIGHT",
                    "case.png",
                    brutal(caseInsertCore, node)
                )
                if (left == null) {
                    pushMenuItem(
                        menu,
                        "MES_INSERT_CASE_LEFT",
                        "case.png",
                        brutal(firstCaseInsertCore, node)
                    )
                } else {
                    pushMenuItem(
                        menu,
                        "MES_INSERT_CASE_LEFT",
                        "case.png",
                        brutal(caseInsertCore, left)
                    )
                }
            } else {
                if (_sw78450000_ === "address") {
                    addressDestinations(
                        node,
                        menu
                    )
                } else {
                    if (_sw78450000_ === "branch") {
                        branchMenu(
                            node,
                            menu
                        )
                    }
                }
            }
        }
    }
    if (canDelete(node)) {
        pushSeparator(menu)
        pushMenuItem(
            menu,
            "MES_DELETE",
            null,
            brutal(deleteOne, node)
        )
    }
    addPropertiesItem(node, menu)
    return menu
}

function buildMenuByTypeRo(node) {
    var copy, menu
    menu = []
    if (canEditNodeText(node)) {
        pushMenuItem(
            menu,
            "MES_CHANGE_TEXT",
            null,
            function() {startEditText(node.id)}
        )
        pushSeparator(menu)
    }
    copy = getCopyFunction(node)
    if (copy) {
        pushMenuItem(
            menu,
            "MES_COPY",
            null,
            easy(copy, node)
        )
    }
    pushSeparator(menu)
    if (canEditNodeText(node)) {
        pushMenuItem(
            menu,
            "MES_COPY_TEXT",
            null,
            easy(copyText, node)
        )
    }
    addPropertiesItem(node, menu)
    return menu
}

function buildSingleQuoter() {
    var machine
    machine = new SingleQuoter()
    machine.eol = function() {
        errorOnEol(machine)
    }
    machine.finish = function() {
        errorOnFinish(machine)
    }
    return machine
}

function buildSkewers(visuals) {
    var _ind3861 = 0;
    var _col3861 = visuals.nodes.rows;
    var _keys3861 = Object.keys(_col3861); 
    var _len3861 = _keys3861.length;
    while (true) {
        if (_ind3861 < _len3861) {
            
        } else {
            break;
        }
        var id = _keys3861[_ind3861]; var node = _col3861[id];
        if (((node.up) || (!(node.down))) || (node.skewer)) {
            
        } else {
            traceSkewer(
                visuals,
                node
            )
        }
        _ind3861++;
    }
    var _ind3945 = 0;
    var _col3945 = visuals.nodes.rows;
    var _keys3945 = Object.keys(_col3945); 
    var _len3945 = _keys3945.length;
    while (true) {
        if (_ind3945 < _len3945) {
            
        } else {
            break;
        }
        var id = _keys3945[_ind3945]; var node = _col3945[id];
        if (node.left) {
            
        } else {
            traceLevel(
                visuals,
                node
            )
        }
        _ind3945++;
    }
}

function buildSubspaces() {
    var visuals
    visuals = module.visuals
    if (visuals.branches.length == 1) {
        crawlSubdiagram(
            visuals.header.down
        )
    } else {
        var _ind8588 = 0;
        var _col8588 = visuals.branches;
        var _len8588 = _col8588.length;
        while (true) {
            if (_ind8588 < _len8588) {
                
            } else {
                break;
            }
            var branch = _col8588[_ind8588];
            crawlSubdiagram(
                branch.node.down
            )
            _ind8588++;
        }
    }
}

function buildTextBoxes() {
    
}

function buildTextLexer() {
    var self
    self = new TextLexer()
    self.eol = function() {
        JsLexer_eol(self)
    }
    self.finish = function() {
        JsLexer_finish(self)
    }
    return self
}

function buildVisuals() {
    var byBranchId, context, node, render, storage, visuals
    var _sw36740000_ = 0;
    storage = module.storage
    render = module.render
    visuals = new Visuals()
    visuals.header = createNode(
        visuals,
        null,
        "header",
        storage.name,
        "header"
    )
    visuals.header.header = true
    flowIcon(render, visuals.header)
    visuals.params = createParamsNode(
        storage,
        visuals
    )
    var _ind3008 = 0;
    var _col3008 = storage.items;
    var _keys3008 = Object.keys(_col3008); 
    var _len3008 = _keys3008.length;
    while (true) {
        if (_ind3008 < _len3008) {
            
        } else {
            break;
        }
        var id = _keys3008[_ind3008]; var item = _col3008[id];
        node = nodeFromItem(
            visuals,
            item
        )
        flowIcon(render, node)
        _sw36740000_ = item.type;
        if (_sw36740000_ === "branch") {
            addBranch(visuals, node)
        } else {
            if (_sw36740000_ === "end") {
                visuals.end = node
            }
        }
        _ind3008++;
    }
    byBranchId = function(branch) {
        return branch.node.branchId
    }
    Utils.sort(
        visuals.branches,
        byBranchId
    )
    var _ind3032 = 0;
    var _col3032 = visuals.branches;
    var _len3032 = _col3032.length;
    while (true) {
        if (_ind3032 < _len3032) {
            
        } else {
            break;
        }
        var branch = _col3032[_ind3032];
        context = {
            visuals : visuals,
            addresses : []
        }
        linkNodeToChildren(
            context,
            branch.node.itemId
        )
        branch.addresses = context.addresses
        _ind3032++;
    }
    if (visuals.branches.length > 1) {
        layoutSilhouette(visuals)
    } else {
        layoutPrimitive(visuals)
    }
    buildSkewers(
        visuals
    )
    var _ind3922 = 0;
    var _col3922 = visuals.skewers.rows;
    var _keys3922 = Object.keys(_col3922); 
    var _len3922 = _keys3922.length;
    while (true) {
        if (_ind3922 < _len3922) {
            
        } else {
            break;
        }
        var id = _keys3922[_ind3922]; var skewer = _col3922[id];
        setSameWidth(skewer)
        _ind3922++;
    }
    setSameHeight(visuals)
    positionSkewers(
        visuals
    )
    positionLevels(
        visuals
    )
    drawParams(
        visuals
    )
    removeTempEdges(
        visuals
    )
    buildBoxes(
        visuals
    )
    forType(
        visuals,
        "address",
        putCycleMark
    )
    return visuals
}

function buildVisualsForEdit() {
    var visuals
    visuals = buildVisuals()
    module.visuals = visuals
    precacheEdgesLinks(
        visuals
    )
    buildSubspaces()
    connectLoops()
    traceLoops()
    forType(
        visuals,
        "arrow-loop",
        markArrow
    )
}

function builderOperatorBuilder() {
    var machine
    machine = new OperatorBuilder()
    addCompleteResend(machine, "alpha")
    addCompleteResend(machine, "digit")
    addCompleteResend(machine, "whitespace")
    addCompleteResend(machine, "eol")
    addCompleteResend(machine, "finish")
    return machine
}

function calculateCommandUndo(storage, command) {
    var items, old, undo
    var _sw51020000_ = 0;
    if (command.type === "insert") {
        
    } else {
        items = storage.items
        _sw51020000_ = command.table;
        if (_sw51020000_ === "items") {
            old = items[command.id]
            if (command.type === "update") {
                undo = takeOldValues(
                    command.fields,
                    old
                )
            } else {
                undo = Utils.copyObject(old)
            }
        } else {
            if (_sw51020000_ === "diagrams") {
                
            } else {
                throw "Unexpected switch value: " + _sw51020000_;
            }
            undo = takeOldValues(
                command.fields,
                storage
            )
        }
        command.undo = undo
    }
}

function calculateSkewerPos(skewers, links, skewer, pos) {
    var closest, next, nextPos
    if (skewer.coord < pos) {
        skewer.coord = pos
        closest = links.get(skewer.id)
        if (closest) {
            var _ind4133 = 0;
            var _col4133 = closest;
            var _keys4133 = Object.keys(_col4133); 
            var _len4133 = _keys4133.length;
            while (true) {
                if (_ind4133 < _len4133) {
                    
                } else {
                    break;
                }
                var _ = _keys4133[_ind4133]; var link = _col4133[_];
                nextPos = pos + link.distance
                next = skewers.get(
                    link.high
                )
                calculateSkewerPos(
                    skewers,
                    links,
                    next,
                    nextPos
                )
                _ind4133++;
            }
        }
    }
}

function calculateUndo(edits) {
    var storage
    storage = module.storage
    var _ind5070 = 0;
    var _col5070 = edits;
    var _len5070 = _col5070.length;
    while (true) {
        if (_ind5070 < _len5070) {
            
        } else {
            break;
        }
        var command = _col5070[_ind5070];
        calculateCommandUndo(
            storage,
            command
        )
        _ind5070++;
    }
}

function callEditMethod(name, method, args) {
    if (module.readonly) {
        return undefined
    } else {
        addTrace(name, args)
        return method.apply(
            undefined,
            args
        )
    }
}

function callMethod(self, methodName, argArray) {
    var method
    method = self[methodName]
    if (method) {
        return method.apply(
            self,
            argArray
        )
    } else {
        return null
    }
}

function canComeBackTo(src, loops) {
    var context
    context = {
        visited : {},
        finished : false,
        success : false,
        loops : loops
    }
    canComeBackToStep(
        context,
        src
    )
    return context.success
}

function canComeBackToStep(context, node) {
    var loops, visited
    loops = context.loops
    visited = context.visited
    if (context.finished) {
        
    } else {
        if (node.itemId in loops) {
            context.finished = true
        } else {
            if (node.id in visited) {
                
            } else {
                visited[node.id] = true
                if (isSubset(node.loops, loops)) {
                    context.finished = true
                    context.success = true
                } else {
                    var _ind8061 = 0;
                    var _col8061 = node.prev;
                    var _len8061 = _col8061.length;
                    while (true) {
                        if (_ind8061 < _len8061) {
                            
                        } else {
                            break;
                        }
                        var prev = _col8061[_ind8061];
                        canComeBackToStep(
                            context,
                            prev
                        )
                        _ind8061++;
                    }
                }
            }
        }
    }
}

function canDelete(node) {
    var _sw48990000_ = 0;
    _sw48990000_ = node.type;
    if (((((_sw48990000_ === "junction") || (_sw48990000_ === "header")) || (_sw48990000_ === "arrow-loop")) || (_sw48990000_ === "address")) || (_sw48990000_ === "end")) {
        return false
    } else {
        if (_sw48990000_ === "branch") {
            return canDeleteBranch()
        } else {
            if (_sw48990000_ === "case") {
                return canDeleteCase(node)
            } else {
                return true
            }
        }
    }
}

function canDeleteBranch() {
    return module.visuals.branches.length > 2
}

function canDeleteCase(caseNode) {
    var select
    select = caseNode.select
    if ((select.cases.length > 2) && (!(select.cases[0] == caseNode))) {
        return true
    } else {
        return false
    }
}

function canEditNodeText(node) {
    var noText
    noText = {
        junction : true,
        end : true,
        "arrow-loop" : true,
        address : true
    }
    if (node.type in noText) {
        return false
    } else {
        return true
    }
}

function canEditText(x, y) {
    var node, prim
    prim = findVisualItem(
        x,
        y
    )
    if (((prim) && (prim.id)) && (prim.elType == "node")) {
        node = getNode(prim.id)
        if (canEditNodeText(node)) {
            return prim.id
        } else {
            return null
        }
    } else {
        return null
    }
}

function canOuterToInner(record, source) {
    var sourceBottom, sourceStop, targetNode, targetStop, targetTop
    if (record.type == "node") {
        targetNode = record.element
        targetTop = goUp(targetNode)
        if (targetTop.y <= source.head.y) {
            targetStop = goDown(targetNode)
            sourceBottom = goDown(source.head)
            sourceStop = goLeft(sourceBottom)
            if (sourceStop == targetStop) {
                return false
            } else {
                return true
            }
        } else {
            return false
        }
    } else {
        if (record.element.vertical) {
            targetNode = record.element.tail
            targetTop = goUp(targetNode)
            if (targetTop.y <= source.head.y) {
                targetStop = goDown(targetNode)
                sourceBottom = goDown(source.head)
                sourceStop = goLeft(sourceBottom)
                if (sourceStop == targetStop) {
                    return false
                } else {
                    return true
                }
            } else {
                return false
            }
        } else {
            return true
        }
    }
}

function canSelectNode(node) {
    return node.type in module.selectable
}

function canStartRegex(self) {
    if ((self.prev) && (((((((self.prev.type == "number") || (self.prev.type == "string")) || (self.prev.type == "identifier")) || (self.prev.type == "regex")) || (self.prev.text == ")")) || (self.prev.text == "]")) || (self.prev.text == "}"))) {
        return false
    } else {
        return true
    }
}

function canTransplant(targetId, source) {
    if ((source.finalTarget.itemId == targetId) || (!(sameLoop(source.links, targetId)))) {
        return false
    } else {
        return true
    }
}

function caseInsert(socket) {
    var existing
    existing = socket.node
    return caseInsertCore(existing)
}

function caseInsertCore(existing, item) {
    var caseId, edits, fields, right, targetId
    edits = []
    targetId = existing.next[0].itemId
    item = item || {}
    fields = Utils.copyObject(item)
    fields.one = targetId
    fields.type = "case"
    if (existing.next.length == 2) {
        right = existing.next[1]
        fields.two = right.itemId
    } else {
        fields.two = null
    }
    caseId = createItem(
        edits,
        fields
    )
    updateItem(
        edits,
        existing.itemId,
        {two:caseId}
    )
    return edits
}

function changeDiagramProperties() {
    var hide, machine, name, props, ro, set, show, storage
    show = module.callbacks.showChangeDiaProps
    hide = module.callbacks.hideCentral
    if ((show) && (hide)) {
        set = function(props) {
        	module.callbacks.hideCentral()
        	setProperties(props)
        }
        machine = {
            onData : set,
            cancel : hide
        }
        storage = module.storage
        ro = module.readonly
        name = storage.name
        props = {
            keywords : storage.keywords,
            params : storage.params,
            language : module.language
        }
        show(
            machine,
            name,
            props,
            ro
        )
    } else {
        return null;
    }
}

function changeSearch(input) {
    var search
    search = module.search
    search.input = Utils.copyObject(input)
    performSearch()
    if (search.occurences.length == 0) {
        search.output.current = -1
    } else {
        search.output.current = 0
    }
    updateSearchOutput()
    return getSearchState()
}

function checkInputText(text) {
    if (module.readonly) {
        return "ERR_READONLY"
    } else {
        if ((text) && (text.length > Config.MAX_TEXT)) {
            return "ERR_TEXT_TOO_LONG"
        } else {
            return null
        }
    }
}

function classifyChar(code) {
    if (code == 10) {
        return "eol"
    } else {
        if (isDigit(code)) {
            return "digit"
        } else {
            if (isOperator(code)) {
                return "operator"
            } else {
                if (isWhitespace(code)) {
                    return "whitespace"
                } else {
                    return "alpha"
                }
            }
        }
    }
}

function clearFormat(ids, format) {
    
}

function clearSockets() {
    module.visuals.sockets.clear()
}

function clearUndo() {
    module.undo = new Undo()
    rebuildSearchState()
}

function clickArrowSocket(socket) {
    var edits, item, newId
    edits = []
    item = {
        type : "arrow-loop",
        one : socket.target
    }
    newId = createItem(
        edits,
        item
    )
    redirectUpperItems(
        edits,
        socket.links,
        newId
    )
    redirectUpperItems(
        edits,
        socket.edge.links,
        newId
    )
    return edits
}

function clickLianaSocket(socket) {
    var edits
    edits = []
    redirectUpperItems(
        edits,
        socket.links,
        socket.target
    )
    if (socket.arrow) {
        popFromSkewer(
            edits,
            socket.arrow.finalTarget
        )
    }
    return edits
}

function clickSocket(socketId) {
    var action, edits, socket
    var _sw43680000_ = 0;
    socket = module.visuals.sockets.get(
        socketId
    )
    _sw43680000_ = socket.op;
    if (_sw43680000_ === "insert") {
        action = getActionForInsert(
            socket.type
        )
        edits = action(socket)
        brutalChange(edits)
    } else {
        if (_sw43680000_ === "paste") {
            edits = pasteInSocket(socket)
            brutalChange(edits)
        } else {
            if (_sw43680000_ === "arrow") {
                edits = clickArrowSocket(socket)
                brutalChange(edits)
            } else {
                if (_sw43680000_ === "liana") {
                    edits = clickLianaSocket(socket)
                    brutalChange(edits)
                } else {
                    if (_sw43680000_ === "params") {
                        
                    } else {
                        throw "Unexpected switch value: " + _sw43680000_;
                    }
                    clearSockets()
                    redrawCanvas()
                    changeDiagramProperties()
                }
            }
        }
    }
}

function clusterComplete(context) {
    if ((context.arrows == 0) && (context.paths == 0)) {
        return true
    } else {
        return false
    }
}

function collectLevels(visuals, branch) {
    var getLevel, levelIds, node, visited
    visited = {}
    visited[branch.node.id] = true
    scanManhattan(
        visited,
        getDown(branch.node)
    )
    delete visited[branch.node.id]
    levelIds = {}
    var _ind8544 = 0;
    var _col8544 = visited;
    var _keys8544 = Object.keys(_col8544); 
    var _len8544 = _keys8544.length;
    while (true) {
        if (_ind8544 < _len8544) {
            
        } else {
            break;
        }
        var nodeId = _keys8544[_ind8544]; var _ = _col8544[nodeId];
        node = visuals.nodes.get(nodeId)
        levelIds[node.level.id] = true
        _ind8544++;
    }
    getLevel = function(levelId) {
        return visuals.levels.get(levelId)
    }
    return Object.keys(levelIds).map(
        getLevel
    )
}

function completeChars(self) {
    var token
    token = makeTokenFromChars(
        self,
        "operator"
    )
    self.next.completeToken(
        token
    )
}

function completeResend(self, name, msg) {
    var next
    next = self.next
    completeChars(self)
    callMethod(next, name, [msg])
}

function computeLength(item) {
    var length, text
    var _sw113700000_ = 0;
    _sw113700000_ = item.type;
    if (_sw113700000_ === "block") {
        return addSpaces(item)
    } else {
        if (_sw113700000_ === "eol") {
            length = 1
        } else {
            text = item.text || ""
            length = text.length
        }
        item.length = length
        return item
    }
}

function connectBranch(visuals, branch, upper, lower) {
    var branchLower, floor
    branch.topNode = createJunction(
        visuals,
        null
    )
    createEdge(
        visuals,
        upper,
        branch.topNode,
        false
    )
    createEdge(
        visuals,
        branch.topNode,
        branch.node,
        true
    )
    if (branch.addresses.length) {
        var _ind8387 = 0;
        var _col8387 = branch.addresses;
        var _len8387 = _col8387.length;
        while (true) {
            if (_ind8387 < _len8387) {
                
            } else {
                break;
            }
            var address = _col8387[_ind8387];
            branchLower = createJunction(
                visuals,
                null
            )
            floor = createEdge(
                visuals,
                lower,
                branchLower,
                false
            )
            floor.role = "floor"
            createEdge(
                visuals,
                address,
                branchLower,
                true
            )
            lower = branchLower
            _ind8387++;
        }
    } else {
        createEdge(
            visuals,
            lower,
            visuals.end,
            false
        )
    }
    branch.bottomNode = lower
}

function connectLoops() {
    var visuals
    visuals = module.visuals
    var _ind6186 = 0;
    var _col6186 = visuals.nodes.rows;
    var _keys6186 = Object.keys(_col6186); 
    var _len6186 = _keys6186.length;
    while (true) {
        if (_ind6186 < _len6186) {
            
        } else {
            break;
        }
        var id = _keys6186[_ind6186]; var node = _col6186[id];
        if (node.type == "loopend") {
            findLoopStart(node)
        }
        _ind6186++;
    }
}

function contains(list, item) {
    var index
    if (list) {
        index = list.indexOf(item)
        if (index == -1) {
            return false
        } else {
            return true
        }
    } else {
        return false
    }
}

function copy() {
    var copyType
    copyType = copyCore()
    if (copyType) {
        showPasteSockets(
            copyType
        )
    }
}

function copyBlock(startId, items) {
    var block
    block = {
        start : startId,
        items : items
    }
    copyToClipboard(
        "block",
        block
    )
    return "block"
}

function copyBranch(node) {
    var block, branchNodes, end, items, targets
    branchNodes = {}
    scanBranchItems(
        node,
        branchNodes
    )
    end = module.visuals.end
    if (end) {
        delete branchNodes[end.itemId]
    }
    items = []
    targets = {}
    var _ind9674 = 0;
    var _col9674 = branchNodes;
    var _keys9674 = Object.keys(_col9674); 
    var _len9674 = _keys9674.length;
    while (true) {
        if (_ind9674 < _len9674) {
            
        } else {
            break;
        }
        var itemId = _keys9674[_ind9674]; var bnode = _col9674[itemId];
        var _ind9676 = 0;
        var _col9676 = bnode.next;
        var _len9676 = _col9676.length;
        while (true) {
            if (_ind9676 < _len9676) {
                
            } else {
                break;
            }
            var next = _col9676[_ind9676];
            if (next.itemId in branchNodes) {
                
            } else {
                targets[next.itemId] = next.text
            }
            _ind9676++;
        }
        items.push(copyItem(itemId))
        _ind9674++;
    }
    block = {
        start : node.itemId,
        items : items,
        targets : targets
    }
    copyToClipboard(
        "branch",
        block
    )
    return "branch"
}

function copyCase(node) {
    var block, copy
    copy = copyItem(node.itemId)
    copy.one = "finish"
    copy.two = null
    block = {
        start : node.itemId,
        items : [copy]
    }
    copyToClipboard(
        "case",
        block
    )
    return "case"
}

function copyCore() {
    var copyType, nodes
    var _sw102440000_ = 0;
    nodes = getNodesFromSelection()
    _sw102440000_ = nodes.length;
    if (_sw102440000_ === 0) {
        copyType = null
    } else {
        if (_sw102440000_ === 1) {
            copyType = copyOneItem(nodes[0])
        } else {
            copyType = copyManyItems(nodes)
        }
    }
    return copyType
}

function copyEdgeLinks(socket) {
    var edge
    edge = socket.edge
    socket.target = edge.finalTarget.itemId
    addRange(
        edge.links,
        socket.links
    )
}

function copyItem(itemId) {
    var copy, item
    item = module.storage.items[itemId]
    copy = Utils.copyObject(item)
    return copy
}

function copyItems() {
    var items, storage
    storage = module.storage
    items = []
    var _ind2883 = 0;
    var _col2883 = storage.items;
    var _keys2883 = Object.keys(_col2883); 
    var _len2883 = _keys2883.length;
    while (true) {
        if (_ind2883 < _len2883) {
            
        } else {
            break;
        }
        var id = _keys2883[_ind2883]; var item = _col2883[id];
        items.push(
            Utils.copyObject(item)
        )
        _ind2883++;
    }
    return items
}

function copyLoop(node) {
    var end, loop
    loop = copyItem(node.itemId)
    loop.one = node.loopEnd.itemId
    end = copyItem(node.loopEnd.itemId)
    end.one = "finish"
    return copyBlock(
        node.itemId,
        [ loop, end ]
    )
}

function copyLoopEnd(node) {
    return copyLoop(node.loopStart)
}

function copyManyItems(nodes) {
    var items
    items = nodes.map(
        copySelectedItem
    )
    return copyBlock(
        module.selection.head,
        items
    )
}

function copyOneItem(node) {
    var copy
    copy = getCopyFunction(node)
    if (copy) {
        return copy(node)
    } else {
        return null
    }
}

function copyQuestion(node) {
    var copy
    copy = copyItem(node.itemId)
    copy.one = "finish"
    copy.two = "finish"
    return copyBlock(
        node.itemId,
        [ copy ]
    )
}

function copySelect(node) {
    var caseItem, items
    items = []
    items.push(copyItem(node.itemId))
    var _ind9466 = 0;
    var _col9466 = node.cases;
    var _len9466 = _col9466.length;
    while (true) {
        if (_ind9466 < _len9466) {
            
        } else {
            break;
        }
        var caseNode = _col9466[_ind9466];
        caseItem = copyItem(caseNode.itemId)
        caseItem.one = "finish"
        items.push(caseItem)
        _ind9466++;
    }
    return copyBlock(
        node.itemId,
        items
    )
}

function copySelectedItem(node) {
    var item
    item = copyItem(node.itemId)
    item.one = getCopyTarget(node, 0)
    item.two = getCopyTarget(node, 1)
    return item
}

function copySimple(node) {
    var copy
    copy = copyItem(node.itemId)
    copy.one = "finish"
    return copyBlock(
        node.itemId,
        [ copy ]
    )
}

function copyText(node) {
    if (node.text) {
        copyToClipboard(
            "text",
            node.text
        )
    }
}

function copyToClipboard(type, subgraph) {
    var fun = module.callbacks.copyToClipboard
    if (fun) {
        fun(type, subgraph);
    }
}

function crawl(crawler, startEdge) {
    var edge
    edge = startEdge
    while (true) {
        edge[crawler.side] = crawler.sub
        edge = crawler.onEdge(edge)
        if (edge) {
            
        } else {
            break;
        }
    }
    var _ind7475 = 0;
    var _col7475 = crawler.plan;
    var _len7475 = _col7475.length;
    while (true) {
        if (_ind7475 < _len7475) {
            
        } else {
            break;
        }
        var node = _col7475[_ind7475];
        createQSubspace(
            crawler,
            node
        )
        _ind7475++;
    }
}

function crawlNode(crawler, node) {
    if (node.right) {
        if (node.down) {
            crawler.rt(node)
        } else {
            crawler.ut(node)
        }
        return crawler.nextNode
    } else {
        if (node.left) {
            if (node.down) {
                if (node.up) {
                    crawler.lt(node)
                } else {
                    crawler.ld(node)
                }
            } else {
                if (node.up) {
                    crawler.lu(node)
                } else {
                    throw new Error(
                        "Unexpected node: left only"
                    )
                }
            }
            return crawler.nextNode
        } else {
            if (node.down) {
                crawler.dd(node)
                return crawler.nextNode
            } else {
                return false
            }
        }
    }
}

function crawlSelect(select) {
    var cases, i, inner, jun, left, outer, right, sub
    cases = select.cases
    i = 0;
    while (true) {
        if (i < cases.length - 1) {
            
        } else {
            break;
        }
        left = cases[i]
        right = cases[i + 1]
        jun = getUp(left)
        if (jun.zoned) {
            
        } else {
            sub = createSubspace()
            outer = createOuter("down", sub)
            inner = createInner("down", sub)
            crawl(outer, left.down)
            crawl(inner, right.down)
        }
        i++;
    }
    return cases[cases.length - 1]
}

function crawlSubdiagram(startEdge) {
    var innerCrawler, innerSub, outerCrawler, outerSub
    outerSub = createSubspace()
    innerSub = createSubspace()
    outerCrawler = createOuter("down", outerSub)
    innerCrawler = createInner("down", innerSub)
    crawl(
        outerCrawler,
        startEdge
    )
    crawl(
        innerCrawler,
        startEdge
    )
}

function createArrowSocket(element, source) {
    var socket, srcLoops, targetId, targetLoops
    targetId = element.finalTarget.itemId
    if ((((isArrowLoop(element.head)) || (isArrowLoop(element.tail))) || (!(canTransplant(targetId, source)))) || (!(element.tail.x < source.tail.x))) {
        
    } else {
        targetLoops = element.finalTarget.loops
        srcLoops = source.finalTarget.loops
        if ((withinSameLoop(source, element, 0)) && (!(hasOtherEntries(source, element.tail)))) {
            socket = createSocketFromEdge(
                element,
                "arrow",
                null
            )
            addRange(
                source.links,
                socket.links
            )
        }
    }
}

function createBlock(seq) {
    return {
        type : "block",
        statements : [],
        prev : "operator",
        statement : createStatement(),
        length : 0,
        seq : seq,
        seqStart : false
    }
}

function createBlock2(seq) {
    return {
        type : "block",
        statements : [],
        length : 0,
        seq : seq
    }
}

function createBreak() {
    var token
    token = createToken(
        "break",
        ""
    )
    token.length = 0
    return token
}

function createDiagram(diagram) {
    var edit, edit1, edit3, edits, emptyBranch, storage
    addTrace(
        "createDiagram",
        [diagram.type, diagram.name]
    )
    storage = createStorage(
        diagram,
        Config.DIAGRAM_VERSION
    )
    edits = []
    edit1 = new Edit(
        "insert",
        "items",
        "1",
        {type: "end"}
    )
    edits.push(
        edit1
    )
    edit3 = new Edit(
        "insert",
        "items",
        "3",
        {type: "action", one: "1"}
    )
    edits.push(
        edit3
    )
    emptyBranch = {
        type : "branch",
        branchId : 0,
        one : "3"
    }
    edit = new Edit(
        "insert",
        "items",
        "2",
        emptyBranch
    )
    edits.push(
        edit
    )
    performLocalChange(
        edits,
        false
    )
    persistChanges(
        edits,
        false
    )
    recalculateNextId()
    buildVisualsForEdit()
    clearUndo()
}

function createEdge(visuals, head, tail, vertical) {
    var edge, id
    id = "e" + getNextId(visuals)
    edge = new Edge(
        id,
        head,
        tail,
        vertical
    )
    if (vertical) {
        if (head.down) {
            throw Error("head.down is busy")
        } else {
            if (tail.up) {
                throw Error("tail.up is busy")
            } else {
                head.down = edge
                tail.up = edge
            }
        }
    } else {
        if (head.right) {
            throw Error("head.right is busy")
        } else {
            if (tail.left) {
                throw Error("tail.left is busy")
            } else {
                head.right = edge
                tail.left = edge
            }
        }
    }
    visuals.edges.insert(edge)
    return edge
}

function createEol() {
    return createToken("eol", "")
}

function createInner(state, sub) {
    var crawler
    crawler = new InnerCrawler()
    crawler.sub = sub
    crawler.state = state
    crawler.side = "inner"
    crawler.plan = []
    return crawler
}

function createItem(edits, fields) {
    var edit, id
    id = getNextStorageId()
    edit = new Edit(
        "insert",
        "items",
        id,
        fields
    )
    edits.push(
        edit
    )
    return id
}

function createJunction(visuals, finalTarget) {
    var node
    node = createNode(
        visuals,
        null,
        "junction",
        ""
    )
    node.finalTarget = finalTarget
    return node
}

function createKeywordsText(storage) {
    var keyText, keywords
    keywords = []
    addKeyword(storage.keywords, "export", keywords)
    addKeyword(storage.keywords, "async", keywords)
    if (keywords.length == 0) {
        keyText = ""
    } else {
        keyText = keywords.join(" ")
    }
    return keyText
}

function createLeftDown(visuals, finalTarget) {
    var result
    result = createJunction(
        visuals,
        finalTarget
    )
    return result
}

function createLeftUp(visuals, node2, finalTarget) {
    var result
    result = createJunction(
        visuals,
        finalTarget
    )
    node2.mountRight = result
    return result
}

function createLevel(visuals) {
    var skewer
    skewer = new Skewer(false)
    visuals.levels.insert(
        skewer
    )
    return skewer
}

function createLianaSocket(record, source) {
    var socket
    if ((canTransplant(record.targetId, source)) && (!(adjacentToAddress(record, source)))) {
        if (record.type == "node") {
            socket = createNodeSocket(
                record.element,
                source
            )
        } else {
            socket = createSocketFromEdge(
                record.element,
                "liana",
                null
            )
        }
        socket.arrow = source.arrow
        addRange(
            source.links,
            socket.links
        )
    }
}

function createNode(visuals, itemId, type, text, id) {
    var node, sameType
    if (id) {
        
    } else {
        id = "n" + getNextId(visuals)
    }
    node = new Node(
        id,
        itemId,
        type,
        text
    )
    visuals.nodes.insert(node)
    if (itemId) {
        visuals.itemsToNodes[itemId] = node
    }
    sameType = getCreateList(
        visuals.byType,
        type
    )
    sameType.push(node)
    return node
}

function createNodeSocket(node, source) {
    var socket
    socket = new Socket(
        node.x,
        node.y,
        "liana",
        null
    )
    socket.node = node
    socket.target = node.finalTarget.itemId
    module.visuals.sockets.insert(
        socket
    )
    return socket
}

function createOuter(state, sub) {
    var crawler
    crawler = new OuterCrawler()
    crawler.sub = sub
    crawler.state = state
    crawler.side = "outer"
    crawler.plan = []
    return crawler
}

function createParamsNode(storage, visuals) {
    var keyText, node, text
    keyText = createKeywordsText(storage)
    text = storage.params
    if ((text) || (keyText)) {
        node = createNode(
            visuals,
            "params",
            "params",
            text,
            "params"
        )
        node.keyText = keyText
        flowIcon(render, node)
        node.params = storage.params
        return node
    } else {
        return null
    }
}

function createParsingState(tokens) {
    var state
    state = {
        tokens : tokens,
        index : 0,
        current : tokens[0]
    }
    return state
}

function createPastedItem(edits, item) {
    var edit
    edit = new Edit(
        "insert",
        "items",
        item.id,
        item
    )
    edits.push(
        edit
    )
    return item.id
}

function createQSubspace(self, question) {
    var inner, outer, sub
    if (question.zoned) {
        
    } else {
        sub = createSubspace()
        outer = createOuter("down", sub)
        inner = createInner("right", sub)
        crawl(outer, question.down)
        crawl(inner, question.right)
    }
}

function createRawFlower() {
    return {
        tokens : [],
        max : MaxChars,
        current : 0
    }
}

function createSearchLexer() {
    var handlers, result
    handlers = {
        idle : handleIdle,
        building : handleBuilding
    }
    result = {
        handlers : handlers,
        top : "idle",
        chars : []
    }
    result.onChar = function(op, cat, code, pos) {
        onLexChar(result, op, cat, code, pos)
    }
    return result
}

function createSearchTokens() {
    var self
    self = {
        tokens : [],
        tokensLow : []
    }
    self.onToken = function(token) {
        addSearchToken(self, token)
    }
    return self
}

function createSkewer(visuals) {
    var skewer
    skewer = new Skewer(true)
    visuals.skewers.insert(
        skewer
    )
    return skewer
}

function createSocketFromEdge(edge, op, type) {
    var Min, head, hh, hw, socket, tail, th, tw, x, x1, x2, y, y1, y2
    head = edge.head
    tail = edge.tail
    Min = 10
    hw = Math.max(Min, head.w)
    hh = Math.max(Min, head.h)
    tw = Math.max(Min, tail.w)
    th = Math.max(Min, tail.h)
    if (edge.vertical) {
        x1 = getX(head)
        y1 = getY(head) + hh
        x2 = x1
        y2 = getY(tail) - th
    } else {
        x1 = getX(head) + hw
        y1 = getY(head)
        x2 = getX(tail) - tw
        y2 = y1
    }
    x = (x1 + x2) / 2
    y = (y1 + y2) / 2
    socket = new Socket(
        x,
        y,
        op,
        type
    )
    socket.edge = edge
    socket.target = edge.finalTarget.itemId
    module.visuals.sockets.insert(
        socket
    )
    return socket
}

function createSourceFlower(render, source) {
    var flower
    flower = new SourceFlower()
    flower.maxLength = MaxLineLength
    flower.init(render)
    flower.source = source
    return flower
}

function createSpace() {
    var token
    token = createToken(
        "whitespace",
        " "
    )
    token.length = token.text.length
    return token
}

function createStatement() {
    return {
        type : "statement",
        items : [],
        length : 0
    }
}

function createStorage(diagram, version) {
    module.storage = new Storage(
        diagram.type,
        diagram.name,
        version
    )
    module.storage.keywords = diagram.keywords || {}
    module.storage.params = diagram.params || ""
    module.language = diagram.language
    resetSelection()
    return module.storage
}

function createSubspace() {
    var sub, visuals
    visuals = module.visuals
    sub = new Sub()
    visuals.subs.insert(sub)
    return sub
}

function createTempEdge(visuals, node, leftBottom) {
    var edge, leftTop, parNext, parTop, tmpJun
    leftTop = goUp(node)
    parTop = getLeft(leftTop)
    parNext = getDown(parTop)
    if (parNext.type == "case") {
        parNext = getDown(parNext)
    }
    tmpJun = splitVertical(
        visuals,
        parNext
    )
    edge = createEdge(
        visuals,
        tmpJun,
        leftBottom,
        false
    )
    visuals.tempEdges.push(edge)
}

function createToken(type, text) {
    return {
        type : type,
        text : text
    }
}

function createTokenCollection() {
    var self
    self = {
        tokens : []
    }
    self.onToken = function(token) {
    	addNoWs(self, token)
    }
    self.eol = function() {
    
    }
    return self
}

function createTreeLexer() {
    var handlers, result
    handlers = {
        normal : handleNormal,
        choose : handleChoose,
        single : handleSingle,
        quote : handleQuote,
        backtick : handleBacktick,
        one : handleOne,
        multi : handleMulti,
        regex : handleRegex
    }
    result = {
        handlers : handlers,
        top : "",
        tt : "",
        escaping : false,
        part : 0,
        chars : [],
        prev : undefined
    }
    result.onChar = function(op, cat, code, pos) {
        onChar(result, op, cat, code)
    }
    setTop(result, "normal")
    return result
}

function createUpDown(visuals, node2, finalTarget) {
    var result
    result = createJunction(
        visuals,
        finalTarget
    )
    node2.mountRight = result
    return result
}

function cut() {
    var copyType, nodes
    copyType = copyCore()
    if (copyType) {
        nodes = getNodesFromSelection()
        deleteSelectionCore(nodes)
        showPasteSockets(
            copyType
        )
    }
}

function cutOneItem(node) {
    var edits
    copyOneItem(node)
    edits = deleteOne(node)
    brutalChange(edits)
    paste()
}

function darkenSocket(socketId) {
    var socket
    socket = module.visuals.sockets.get(
        socketId
    )
    socket.on = false
    redrawCanvas()
}

function defineIcon(type, draw, flow) {
    var icon
    icon = {}
    module.icons[type] = icon
    icon.draw = function(render, item) {
        draw(render, item)
    }
    icon.flow = function(render, item) {
        flow(render, item)
    }
}

function deleteBlock(nodes) {
    var addDeletion, bottomId, edits, head, selection
    selection = module.selection
    bottomId = findSelectionBottom()
    head = getNode(selection.head)
    edits = []
    redirectUpperItems(
        edits,
        head.up.links,
        bottomId
    )
    addDeletion = function(node) {
        deleteItem(edits, node.itemId)
    }
    nodes.forEach(
        addDeletion
    )
    return edits
}

function deleteBranch(node) {
    var ditch, edits, next, remaining, toDelete
    edits = moveBranchIdsLeft(
        node.branchId
    )
    next = getBranchById(
        node.branchId + 1
    )
    if (next) {
        
    } else {
        next = getBranchById(1)
    }
    toDelete = {}
    scanBranchItems(
        node,
        toDelete
    )
    remaining = subtract(
        module.storage.items,
        toDelete
    )
    redirectBranch(
        remaining,
        toDelete,
        next.node.itemId,
        edits
    )
    ditch = function(itemId) {
        deleteItem(edits, itemId)
    }
    Object.keys(toDelete).forEach(
        ditch
    )
    return edits
}

function deleteCase(node) {
    var below, edits, left, right, toKeep
    edits = []
    left = node.prev[0]
    if (left == node.select) {
        right = node.next[1]
        updateItem(
            edits,
            left.itemId,
            {one:right.itemId}
        )
    } else {
        if (node.next.length == 2) {
            right = node.next[1]
            updateItem(
                edits,
                left.itemId,
                {two:right.itemId}
            )
        } else {
            updateItem(
                edits,
                left.itemId,
                {two:null}
            )
        }
    }
    deleteItem(
        edits,
        node.itemId
    )
    toKeep = markOtherCasesToStay(node)
    below = node.next[0]
    toKeep[node.itemId] = true
    markToDelete(
        toKeep,
        node,
        below.itemId,
        edits
    )
    return edits
}

function deleteItem(edits, id) {
    var edit
    edit = new Edit(
        "delete",
        "items",
        id,
        null
    )
    edits.push(
        edit
    )
}

function deleteLoop(node) {
    var beforeEnd, beginItem, edgeUp, edgeUp2, edits, end, endItem, items
    edits = []
    edgeUp = node.up
    end = node.loopEnd
    items = module.storage.items
    beginItem = items[node.itemId]
    endItem = items[end.itemId]
    beforeEnd = getUp(end)
    if (beforeEnd == node) {
        redirectUpperItems(
            edits,
            edgeUp.links,
            endItem.one
        )
    } else {
        redirectUpperItems(
            edits,
            edgeUp.links,
            beginItem.one
        )
        edgeUp2 = end.up
        redirectUpperItems(
            edits,
            edgeUp2.links,
            endItem.one
        )
    }
    deleteItem(
        edits,
        node.itemId
    )
    deleteItem(
        edits,
        end.itemId
    )
    return edits
}

function deleteOne(node) {
    var _sw49150000_ = 0;
    if (canDelete(node)) {
        _sw49150000_ = node.type;
        if (_sw49150000_ === "question") {
            return deleteQuestion(node)
        } else {
            if (_sw49150000_ === "loopbegin") {
                return deleteLoop(node)
            } else {
                if (_sw49150000_ === "loopend") {
                    return deleteLoop(node.loopStart)
                } else {
                    if (_sw49150000_ === "params") {
                        return deleteParams()
                    } else {
                        if (_sw49150000_ === "case") {
                            return deleteCase(node)
                        } else {
                            if (_sw49150000_ === "select") {
                                return deleteSelect(node)
                            } else {
                                if (_sw49150000_ === "branch") {
                                    return deleteBranch(node)
                                } else {
                                    return deleteSimple(node)
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        return []
    }
}

function deleteParams() {
    var edits, visuals
    visuals = module.visuals
    edits = []
    updateDiagram(
        edits,
        {params: "", keywords: {}}
    )
    return edits
}

function deleteQuestion(node) {
    var edits, one, toKeep, two
    edits = []
    popFromSkewer(
        edits,
        node
    )
    toKeep = {}
    toKeep[node.itemId] = true
    one = node.next[0]
    markToStay(
        node,
        one.itemId,
        toKeep
    )
    two = node.next[1]
    markToDelete(
        toKeep,
        node,
        two.itemId,
        edits
    )
    return edits
}

function deleteSelect(node) {
    var below, edgeUp, edits, first, toKeep
    edits = []
    first = firstCase(node)
    below = first.next[0]
    edgeUp = node.up
    redirectUpperItems(
        edits,
        edgeUp.links,
        below.itemId
    )
    deleteItem(
        edits,
        node.itemId
    )
    toKeep = {}
    toKeep[node.itemId] = true
    markToStay(
        null,
        below.itemId,
        toKeep
    )
    markToDelete(
        toKeep,
        node,
        first.itemId,
        edits
    )
    return edits
}

function deleteSelection() {
    var nodes
    nodes = getNodesFromSelection()
    deleteSelectionCore(nodes)
}

function deleteSelectionCore(nodes) {
    var edits
    var _sw94760000_ = 0;
    _sw94760000_ = nodes.length;
    if (_sw94760000_ === 0) {
        edits = []
    } else {
        if (_sw94760000_ === 1) {
            edits = deleteOne(nodes[0])
        } else {
            edits = deleteBlock(nodes)
        }
    }
    brutalChange(edits)
}

function deleteSimple(node) {
    var edits
    edits = []
    popFromSkewer(
        edits,
        node
    )
    return edits
}

function deselect() {
    
}

function deselectAll() {
    clearSockets()
    resetSelection()
}

function diagramToJson() {
    var sane, storage
    storage = module.storage
    sane = {
        name : storage.name,
        type : storage.type,
        keywords : storage.keywords,
        params : storage.params,
        nodes : {}
    }
    var _ind10300 = 0;
    var _col10300 = storage.items;
    var _keys10300 = Object.keys(_col10300); 
    var _len10300 = _keys10300.length;
    while (true) {
        if (_ind10300 < _len10300) {
            
        } else {
            break;
        }
        var id = _keys10300[_ind10300]; var item = _col10300[id];
        sane.nodes[item.id] = Utils.copyObject(
            item
        )
        _ind10300++;
    }
    return JSON.stringify(sane, null, 2)
}

function doReplace(newNeedle) {
    var edits, newText, occ, output, search
    search = module.search
    output = search.output
    occ = search.occurences[output.current]
    newText = replaceOccurence(occ, newNeedle)
    edits = []
    addReplaceCommand(
        edits,
        occ.id,
        occ.item.type,
        newText
    )
    editAndSave(
        edits,
        true
    )
}

function doReplaceAll(newNeedle) {
    var count, edits, search
    search = module.search
    edits = []
    count = 0
    var _ind12652 = 0;
    var _col12652 = search.items;
    var _len12652 = _col12652.length;
    while (true) {
        if (_ind12652 < _len12652) {
            
        } else {
            break;
        }
        var item = _col12652[_ind12652];
        count += replaceAllInItem(
            item,
            newNeedle,
            edits
        )
        _ind12652++;
    }
    editAndSave(
        edits,
        false
    )
    return count
}

function drawCandies(visuals, render) {
    var _ind4518 = 0;
    var _col4518 = visuals.sockets.rows;
    var _keys4518 = Object.keys(_col4518); 
    var _len4518 = _keys4518.length;
    while (true) {
        if (_ind4518 < _len4518) {
            
        } else {
            break;
        }
        var id = _keys4518[_ind4518]; var socket = _col4518[id];
        drawSocket(
            socket,
            render
        )
        _ind4518++;
    }
    var _ind4671 = 0;
    var _col4671 = module.selection.prims;
    var _keys4671 = Object.keys(_col4671); 
    var _len4671 = _keys4671.length;
    while (true) {
        if (_ind4671 < _len4671) {
            
        } else {
            break;
        }
        var id = _keys4671[_ind4671]; var type = _col4671[id];
        drawCandy(
            visuals,
            id,
            type,
            render
        )
        _ind4671++;
    }
}

function drawCandy(visuals, id, type, render) {
    var edge, node
    if (type == "node") {
        node = visuals.nodes.get(id)
        if ((node.type == "junction") || (node.type == "arrow-loop")) {
            juncCandy(
                node,
                render
            )
        } else {
            standardCandy(
                node,
                render
            )
        }
    } else {
        edge = visuals.edges.get(id)
        if (edge.vertical) {
            verticalCandy(
                edge,
                render
            )
        } else {
            horizontalCandy(
                edge,
                render
            )
        }
    }
}

function drawCenterTextInRect(render, texId, tb, box) {
    var left, padding, top
    padding = Config.ICON_PADDING
    left = Math.floor(box.x - tb.width / 2)
    top = Math.floor(box.y - tb.height / 2)
    drawTextLeft(
        render,
        texId,
        tb.tokens,
        left,
        top
    )
}

function drawEdge(render, edge) {
    var format, h, w, x1, x2, y1, y2
    x1 = getX(edge.head)
    y1 = getY(edge.head)
    x2 = getX(edge.tail)
    y2 = getY(edge.tail)
    format = getDiaLineFormat(
        edge
    )
    if (edge.vertical) {
        if (edge.head.skewer.main) {
            format.lineThickness += 1
        }
        h = y2 - y1
        render.createVertical(
            x1,
            y1,
            h,
            null,
            format,
            "lines"
        )
    } else {
        w = x2 - x1
        render.createHorizontal(
            x1,
            y1,
            w,
            edge.role,
            format,
            "lines"
        )
    }
}

function drawHorizontalSubEdge(edge, shift, render, color) {
    var format
    format = {
    	fillColor: color
    }
    render.createRectangle(
        edge.head.x,
        edge.head.y + shift,
        edge.tail.x - edge.head.x,
        5,
        format,
        "guides"
    )
}

function drawIcon(render, item) {
    var engine
    engine = getIconEngine(
        item.type
    )
    if (engine) {
        setFontFromIcon(
            render,
            item
        )
        engine.draw(
            render,
            item
        )
    }
}

function drawInnerSubItem(record, render, color) {
    var edge
    if (record.type == "node") {
        
    } else {
        edge = record.element
        if (edge.vertical) {
            drawVerticalSubEdge(
                edge,
                -10,
                render,
                color
            )
        } else {
            drawHorizontalSubEdge(
                edge,
                -10,
                render,
                color
            )
        }
    }
}

function drawLeftTextInRect(render, texId, tb, box) {
    var left, padding, top
    padding = Config.ICON_PADDING
    left = box.x - box.w + padding
    top = Math.floor(box.y - tb.height / 2)
    drawTextLeft(
        render,
        texId,
        tb.tokens,
        left,
        top
    )
    return top + tb.height
}

function drawOuterSubItem(record, render, color) {
    var edge
    if (record.type == "node") {
        drawSubNode(
            record.element,
            render,
            color
        )
    } else {
        edge = record.element
        if (edge.vertical) {
            drawVerticalSubEdge(
                edge,
                10,
                render,
                color
            )
        } else {
            drawHorizontalSubEdge(
                edge,
                -10,
                render,
                color
            )
        }
    }
}

function drawParams(visuals) {
    var delta, header, hx, hy, level, params, skewer, x, y
    if (visuals.params) {
        skewer = createSkewer(visuals)
        header = visuals.header
        params = visuals.params
        level = header.level
        hx = getX(header)
        hy = getY(header)
        x = hx + header.w + Config.METRE +
        	params.w
        if (params.h > header.h) {
            delta = params.h - header.h
            y = hy - delta
        } else {
            y = header.y
        }
        level.coord = y
        skewer.coord = x
        params.level = level
        params.skewer = skewer
        createEdge(
            visuals,
            header,
            params,
            false
        )
    }
}

function drawSocket(socket, render) {
    render.addSocket(
        socket.x,
        socket.y,
        socket.on
    )
}

function drawSubNode(node, render, color) {
    var format
    format = {
    	fillColor: color
    }
    render.createRectangle(
        node.x - 5,
        node.y - 5,
        10,
        10,
        format,
        "guides"
    )
}

function drawSubspaces(visuals, render) {
    var _ind5667 = 0;
    var _col5667 = visuals.subs.rows;
    var _keys5667 = Object.keys(_col5667); 
    var _len5667 = _keys5667.length;
    while (true) {
        if (_ind5667 < _len5667) {
            
        } else {
            break;
        }
        var id = _keys5667[_ind5667]; var sub = _col5667[id];
        var _ind5669 = 0;
        var _col5669 = sub.inner;
        var _keys5669 = Object.keys(_col5669); 
        var _len5669 = _keys5669.length;
        while (true) {
            if (_ind5669 < _len5669) {
                
            } else {
                break;
            }
            var itemId = _keys5669[_ind5669]; var record = _col5669[itemId];
            drawInnerSubItem(
                record,
                render,
                sub.color
            )
            _ind5669++;
        }
        var _ind5672 = 0;
        var _col5672 = sub.outer;
        var _keys5672 = Object.keys(_col5672); 
        var _len5672 = _keys5672.length;
        while (true) {
            if (_ind5672 < _len5672) {
                
            } else {
                break;
            }
            var itemId = _keys5672[_ind5672]; var record = _col5672[itemId];
            drawOuterSubItem(
                record,
                render,
                sub.color
            )
            _ind5672++;
        }
        _ind5667++;
    }
}

function drawTextLeft(render, texId, tokens, left, top) {
    var _ind2540 = 0;
    var _col2540 = tokens;
    var _len2540 = _col2540.length;
    while (true) {
        if (_ind2540 < _len2540) {
            
        } else {
            break;
        }
        var prim = _col2540[_ind2540];
        render.drawText(
            texId,
            prim.text,
            prim.x + left,
            prim.y + top,
            prim.color
        )
        _ind2540++;
    }
}

function drawToOtherRender(render) {
    
}

function drawVerticalSubEdge(edge, shift, render, color) {
    var format
    format = {
    	fillColor: color
    }
    render.createRectangle(
        edge.head.x + shift,
        edge.head.y,
        5,
        edge.tail.y - edge.head.y,
        format,
        "guides"
    )
}

function drawVisuals(visuals, render) {
    var _ind4240 = 0;
    var _col4240 = visuals.edges.rows;
    var _keys4240 = Object.keys(_col4240); 
    var _len4240 = _keys4240.length;
    while (true) {
        if (_ind4240 < _len4240) {
            
        } else {
            break;
        }
        var id = _keys4240[_ind4240]; var edge = _col4240[id];
        drawEdge(
            render,
            edge
        )
        _ind4240++;
    }
    var _ind4207 = 0;
    var _col4207 = visuals.nodes.rows;
    var _keys4207 = Object.keys(_col4207); 
    var _len4207 = _keys4207.length;
    while (true) {
        if (_ind4207 < _len4207) {
            
        } else {
            break;
        }
        var id = _keys4207[_ind4207]; var node = _col4207[id];
        if (isDrawableNode(node)) {
            drawIcon(
                render,
                node
            )
        }
        _ind4207++;
    }
}

function easy(action, node) {
    return function() {
    	action(node)
    }
}

function editAndSave(edits, keepSearch) {
    calculateUndo(edits)
    addToUndoCore(
        module.undo,
        null,
        edits,
        null
    )
    editAndSaveCore(edits, false, keepSearch)
}

function editAndSaveCore(edits, isUndo, keepSearch) {
    performLocalChange(
        edits,
        isUndo
    )
    buildVisualsForEdit()
    redrawCanvas()
    persistChanges(
        edits,
        isUndo
    )
    if (keepSearch) {
        
    } else {
        rebuildSearchState()
    }
}

function editMethod(name, method) {
    var wrapped
    wrapped = function() {
    	var args = arrayFrom(arguments)
    	return callEditMethod(name, method, args)
    }
    module[name] = wrapped
}

function end() {
    return translateLabel("end", "DIA_END")
}

function endToken(self) {
    self.token.text = Utils.arrayToString(
        self.chars
    )
    self.next.onToken(
        self.token
    )
}

function endVisualDrag() {
    
}

function errorOnEol(self) {
    var next, token
    token = makeTokenFromChars(
        self,
        "error"
    )
    next = self.next
    next.completeToken(
        token
    )
    next.eol()
}

function errorOnFinish(self) {
    var next, token
    token = makeTokenFromChars(
        self,
        "error"
    )
    next = self.next
    next.completeToken(
        token
    )
    next.finish()
}

function filterMap(obj, filter) {
    var result
    result = []
    if (obj) {
        var _ind11982 = 0;
        var _col11982 = obj;
        var _keys11982 = Object.keys(_col11982); 
        var _len11982 = _keys11982.length;
        while (true) {
            if (_ind11982 < _len11982) {
                
            } else {
                break;
            }
            var key = _keys11982[_ind11982]; var value = _col11982[key];
            if (filter(value)) {
                result.push(value)
            }
            _ind11982++;
        }
    }
    return result
}

function findClosestNode(filter, srcNode, vertical) {
    var best, current, distance, selected
    selected = filterMap(
        module.visuals.nodes.rows,
        filter
    )
    best = undefined
    distance = 10000000000
    var _ind11975 = 0;
    var _col11975 = selected;
    var _len11975 = _col11975.length;
    while (true) {
        if (_ind11975 < _len11975) {
            
        } else {
            break;
        }
        var node = _col11975[_ind11975];
        current = getDistance(
            node,
            srcNode,
            vertical
        )
        if (current < distance) {
            best = node
            distance = current
        }
        _ind11975++;
    }
    return best
}

function findDraggable(x, y) {
    var edge, node, socketId
    socketId = findSocket(x, y)
    if (socketId) {
        return {
            type : Const.DRN_SOCKET
        }
    } else {
        node = findNode(x, y)
        if (node) {
            if (inTextArea(node, x, y)) {
                return {
                    id : node.id,
                    type : Const.TEXT,
                    elType : "node"
                }
            } else {
                return {
                    id : node.id,
                    type : Const.DRN_MOVE,
                    elType : "node"
                }
            }
        } else {
            edge = findEdge(x, y)
            if (edge) {
                return {
                    id : edge.id,
                    type : Const.DRN_MOVE,
                    elType : "edge"
                }
            } else {
                return null
            }
        }
    }
}

function findEdge(x, y) {
    return findElementAt(
        module.visuals.edges,
        x,
        y
    )
}

function findEdgeLinks(visuals, startEdge, edge) {
    var itemId, link, source
    source = edge.source
    if (source) {
        if (source.type == "junction") {
            var _ind4331 = 0;
            var _col4331 = source.sources;
            var _len4331 = _col4331.length;
            while (true) {
                if (_ind4331 < _len4331) {
                    
                } else {
                    break;
                }
                var prevEdge = _col4331[_ind4331];
                findEdgeLinks(
                    visuals,
                    startEdge,
                    prevEdge
                )
                _ind4331++;
            }
        } else {
            itemId = getEffectiveItemId(
                visuals,
                source
            )
            link = new Link(
                itemId,
                edge.vertical ? 0 : 1
            )
            startEdge.links.push(link)
        }
    }
}

function findElementAt(table, x, y) {
    var _ind4852 = 0;
    var _col4852 = table.rows;
    var _keys4852 = Object.keys(_col4852); 
    var _len4852 = _keys4852.length;
    while (true) {
        if (_ind4852 < _len4852) {
            
        } else {
            return null
        }
        var id = _keys4852[_ind4852]; var element = _col4852[id];
        if ((element.box) && (Utils.hitBox(element.box, x, y))) {
            return element
        }
        _ind4852++;
    }
}

function findForInsertion() {
    var edges, result, targetId, visuals
    visuals = module.visuals
    edges = visuals.edges.rows
    result = []
    var _ind4422 = 0;
    var _col4422 = edges;
    var _keys4422 = Object.keys(_col4422); 
    var _len4422 = _keys4422.length;
    while (true) {
        if (_ind4422 < _len4422) {
            
        } else {
            break;
        }
        var id = _keys4422[_ind4422]; var edge = _col4422[id];
        if ((edge.finalTarget) && (edge.role)) {
            targetId = edge.finalTarget.itemId
            if ((edge.role == "down") || ((edge.role == "right") && (edge.tail.up))) {
                result.push(edge)
            }
        }
        _ind4422++;
    }
    return result
}

function findLeftLinks(visuals, skewer) {
    var boundary, corner, finish, head, hskewer, left, node, rightJ, start, tail
    var _sw40750000_ = 0;
    head = skewerHead(skewer)
    tail = skewerTail(skewer)
    if ((head.left) && (tail.left)) {
        start = getNextDown(head)
        finish = getNextUp(tail)
        linkSkewers(
            visuals,
            start.skewer,
            skewer,
            start.w + Config.METRE
        )
        node = getDown(start)
        boundary = getBoundary(skewer)
        linkSkewers(
            visuals,
            finish.skewer,
            skewer,
            boundary
        )
        while (true) {
            if (node == finish) {
                break;
            }
            _sw40750000_ = node.type;
            if (_sw40750000_ === "question") {
                rightJ = getRight(node)
                if (rightJ.up) {
                    linkSkewers(
                        visuals,
                        node.skewer,
                        skewer,
                        node.w + boundary + Config.METRE
                    )
                    node = getDown(node)
                } else {
                    linkSkewers(
                        visuals,
                        rightJ.skewer,
                        skewer,
                        boundary
                    )
                    corner = goRight(node)
                    node = getDown(corner)
                }
            } else {
                if (_sw40750000_ === "arrow-loop") {
                    rightJ = getRight(node)
                    linkSkewers(
                        visuals,
                        rightJ.skewer,
                        skewer,
                        boundary
                    )
                    node = getDown(node)
                } else {
                    if (_sw40750000_ === "junction") {
                        linkSkewers(
                            visuals,
                            node.skewer,
                            skewer,
                            node.w + boundary
                        )
                        if (node.down) {
                            node = getDown(node)
                        } else {
                            node = goLeft(node)
                        }
                    } else {
                        if (_sw40750000_ === "select") {
                            linkSkewers(
                                visuals,
                                node.skewer,
                                skewer,
                                node.w + boundary
                            )
                            node = lastCase(node)
                        } else {
                            linkSkewers(
                                visuals,
                                node.skewer,
                                skewer,
                                node.w + boundary
                            )
                            node = getDown(node)
                        }
                    }
                }
            }
        }
        if (node.type == "question") {
            linkSkewers(
                visuals,
                node.skewer,
                skewer,
                node.w + boundary + Config.METRE
            )
        }
    }
    if (visuals.branches.length == 1) {
        
    } else {
        left = getSilCorner(visuals)
        hskewer = visuals.header.skewer
        boundary = hskewer.boundary + 
        	Config.METRE
        linkSkewers(
            visuals,
            left.skewer,
            hskewer,
            boundary
        )
    }
}

function findLianaSource(prim) {
    var beneath, edge, node
    var _sw57530000_ = 0;
    _sw57530000_ = prim.elType;
    if (_sw57530000_ === "node") {
        node = getNode(prim.id)
        if (node.arrow) {
            return node.arrow
        } else {
            if (node.type == "junction") {
                if (isLeftDown(node)) {
                    beneath = getDown(node)
                    if ((beneath.type == "junction") && (!(isRightT(beneath)))) {
                        return node.down
                    } else {
                        return null
                    }
                } else {
                    if (isRightUp(node)) {
                        if (node.right.role == "floor") {
                            return null
                        } else {
                            return node.up
                        }
                    } else {
                        if (((((isCaseJun(node)) || (isBranchJun(node))) || (isAddressJun(node))) || (!(node.left))) || (!(node.up))) {
                            return null
                        } else {
                            if (node.down) {
                                return node.left
                            } else {
                                return node.up
                            }
                        }
                    }
                }
            } else {
                if (isSimpleItem(node)) {
                    if (node.down) {
                        beneath = getDown(node)
                        if ((beneath.type == "junction") && (!(isRightT(beneath)))) {
                            return node.down
                        } else {
                            return null
                        }
                    } else {
                        return null
                    }
                } else {
                    if ((node.type == "address") && (!(node.skewer.main))) {
                        return node.up
                    } else {
                        return null
                    }
                }
            }
        }
    } else {
        if (_sw57530000_ === "edge") {
            edge = getEdge(prim.id)
            if (edge.arrow) {
                return edge.arrow
            } else {
                if (((edge.role) && (!(edge.role == "floor"))) && (!(edge.role == "rarrow"))) {
                    if (edge.vertical) {
                        if ((edge.tail.type == "junction") && (!(isRightT(edge.tail)))) {
                            return edge
                        } else {
                            return null
                        }
                    } else {
                        if (isLeftUp(edge.tail)) {
                            return edge.tail.up
                        } else {
                            if (isRightUp(edge.head)) {
                                return edge.head.up
                            } else {
                                if (edge.head.type == "junction") {
                                    return edge
                                } else {
                                    if ((edge.head.type == "question") && (edge.tail.up)) {
                                        return edge
                                    } else {
                                        return null
                                    }
                                }
                            }
                        }
                    }
                } else {
                    return null
                }
            }
        } else {
            return null
        }
    }
}

function findLoopStart(end) {
    var depth, node
    depth = 0
    node = getUp(end);
    while (true) {
        if (node) {
            
        } else {
            break;
        }
        if (node.type == "loopend") {
            depth++
        } else {
            if (node.type == "loopbegin") {
                if (depth == 0) {
                    node.loopEnd = end
                    end.loopStart = node
                    break;
                }
                depth--
            }
        }
        node = getUp(node);
    }
}

function findNode(x, y) {
    return findElementAt(
        module.visuals.nodes,
        x,
        y
    )
}

function findReplaceAll(input) {
    var number, search, state
    search = module.search
    if (search.output.canReplaceAll) {
        number = doReplaceAll(input.replace)
        updateSearchOutput()
    } else {
        number = 0
    }
    state = getSearchState()
    state.output.number = number
    return state
}

function findSelectionBottom() {
    var next, node, selection
    selection = module.selection
    node = getNode(selection.head)
    while (true) {
        next = node.next[0]
        if (next.id in selection.prims) {
            
        } else {
            break;
        }
        node = next
    }
    return next.itemId
}

function findSocket(x, y) {
    var sockets
    sockets = module.visuals.sockets.rows
    var _ind4527 = 0;
    var _col4527 = sockets;
    var _keys4527 = Object.keys(_col4527); 
    var _len4527 = _keys4527.length;
    while (true) {
        if (_ind4527 < _len4527) {
            
        } else {
            return null;
        }
        var id = _keys4527[_ind4527]; var socket = _col4527[id];
        if (Utils.hitBox(socket.box, x, y)) {
            return id;
        }
        _ind4527++;
    }
}

function findTokens(haystack, needle, start) {
    var i
    i = start;
    while (true) {
        if (i < haystack.length) {
            
        } else {
            return -1
        }
        if (isPart(haystack, i, needle)) {
            return i
        }
        i++;
    }
}

function findVisualItem(x, y) {
    var item = findDraggable(x, y)
    if ((item) && (!(item.type == Const.DRN_SOCKET))) {
        return item
    } else {
        return null
    }
}

function findWayUp(lowNode, highNode) {
    var context
    if (highNode) {
        context = {
            visited : {},
            leak : false
        }
        findWayUpStep(
            context,
            lowNode,
            highNode
        )
        if ((highNode.id in context.visited) && (!(context.leak))) {
            return Utils.objectValues(
                context.visited
            )
        } else {
            return []
        }
    } else {
        return [lowNode]
    }
}

function findWayUpStep(context, node, highNode) {
    var nextStep, visited
    visited = context.visited
    if (node.type == "branch") {
        context.leak = true
    } else {
        if (node.id in visited) {
            
        } else {
            visited[node.id] = node
            if (node == highNode) {
                
            } else {
                if (node.type == "case") {
                    findWayUpStep(
                        context,
                        node.select,
                        highNode
                    )
                } else {
                    nextStep = function(prev) {
                        findWayUpStep(context, prev, highNode)
                    }
                    node.prev.forEach(nextStep)
                }
            }
        }
    }
}

function finishSToken(self) {
    if (self.chars.length == 0) {
        
    } else {
        sendSToken(
            self,
            self.pos,
            self.chars
        )
        self.chars = []
    }
    self.top = "idle"
}

function finishToken(self) {
    if (self.chars.length == 0) {
        
    } else {
        sendToken(
            self,
            self.tt,
            self.chars
        )
    }
}

function fireSocket(socketId) {
    var socket
    socket = module.visuals.sockets.get(
        socketId
    )
    socket.on = true
    redrawCanvas()
}

function firstBranchNode(visuals) {
    return visuals.branches[0].node
}

function firstCase(select) {
    return select.cases[0]
}

function firstCaseInsert(socket) {
    var existing
    existing = socket.node
    return firstCaseInsertCore(existing)
}

function firstCaseInsertCore(existing, item) {
    var caseId, edits, fields, targetId
    edits = []
    targetId = existing.next[0].itemId
    item = item || {}
    fields = Utils.copyObject(item)
    fields.one = targetId
    fields.type = "case"
    fields.two = existing.itemId
    caseId = createItem(
        edits,
        fields
    )
    updateItem(
        edits,
        existing.select.itemId,
        {one:caseId}
    )
    return edits
}

function firstChar(text) {
    return text.charCodeAt(0)
}

function firstDigit(text) {
    var c, i, last
    last = text.length - 1
    i = last;
    while (true) {
        if (i >= 0) {
            
        } else {
            return 0
        }
        c = text.charCodeAt(i)
        if (isDigit(c)) {
            
        } else {
            if (i == last) {
                return -1
            } else {
                return i + 1
            }
            break;
        }
        i--;
    }
}

function flowIcon(render, item) {
    var engine
    engine = getIconEngine(
        item.type
    )
    if (engine) {
        setFontFromIcon(
            render,
            item
        )
        engine.flow(
            render,
            item
        )
        item.w = Math.max(
            item.w,
            Config.MIN_ICON_WIDTH
        )
    }
}

function flowSourceCode(render, node, source) {
    var flower, text, tokens
    text = node.text
    tokens = lexSource(text)
    if ((source) && (shouldAutoformat(node.type))) {
        tokens = prettify(tokens, node.type)
        node.text = printTokens(tokens)
        node.tokens = tokens
    }
    flower = createSourceFlower(
        render,
        source
    )
    sendTokens(tokens, flower)
    return {
        tokens : flower.tokens,
        height : getFlowerHeight(flower),
        width : getFlowerWidth(flower)
    }
}

function flowText(render, text, width) {
    var flower, lexer, machineList, machines, tb
    lexer = buildTextLexer()
    tb = new TokenBuilder()
    flower = new SourceFlower()
    flower.maxLength = width * 2
    flower.init(render)
    flower.source = false
    machineList = [
    	lexer,
    	tb,
    	flower
    ]
    machines = new MachineStack(
        machineList
    )
    toTokens(
        machines,
        text
    )
    return {
        tokens : flower.tokens,
        height : getFlowerHeight(flower),
        width : getFlowerWidth(flower)
    }
}

function forType(visuals, type, action) {
    var nodes
    nodes = getCreateList(
        visuals.byType,
        type
    )
    var _ind7521 = 0;
    var _col7521 = nodes;
    var _len7521 = _col7521.length;
    while (true) {
        if (_ind7521 < _len7521) {
            
        } else {
            break;
        }
        var node = _col7521[_ind7521];
        action(node)
        _ind7521++;
    }
}

function foreachInsert(socket) {
    var begin, beginId, edits, end, endId
    edits = []
    end = {
        type : "loopend",
        text : "",
        one : socket.target
    }
    endId = createItem(
        edits,
        end
    )
    begin = {
        type : "loopbegin",
        text : "",
        one : endId
    }
    beginId = createItem(
        edits,
        begin
    )
    redirectUpperItems(
        edits,
        socket.links,
        beginId
    )
    return edits
}

function generateNewIds(items) {
    var id, oldToNew
    oldToNew = {}
    var _ind9611 = 0;
    var _col9611 = items;
    var _len9611 = _col9611.length;
    while (true) {
        if (_ind9611 < _len9611) {
            
        } else {
            break;
        }
        var item = _col9611[_ind9611];
        id = getNextStorageId()
        oldToNew[item.id] = id
        item.id = id
        _ind9611++;
    }
    return oldToNew
}

function getActionForInsert(type) {
    return module.insertActions[type] || null
}

function getBoundary(skewer) {
    var boundary
    boundary = skewer.boundary +
      Config.METRE
    if (skewer.main) {
        boundary += Config.METRE
    }
    return boundary
}

function getBranchById(branchId) {
    var branches
    branches = module.visuals.branches
    var _ind8980 = 0;
    var _col8980 = branches;
    var _len8980 = _col8980.length;
    while (true) {
        if (_ind8980 < _len8980) {
            
        } else {
            return null
        }
        var branch = _col8980[_ind8980];
        if (branch.node.branchId == branchId) {
            return branch
        }
        _ind8980++;
    }
}

function getBranchByName(name) {
    var branches
    branches = module.visuals.branches
    var _ind9651 = 0;
    var _col9651 = branches;
    var _len9651 = _col9651.length;
    while (true) {
        if (_ind9651 < _len9651) {
            
        } else {
            return null
        }
        var branch = _col9651[_ind9651];
        if (branch.node.text == name) {
            return branch
        }
        _ind9651++;
    }
}

function getBranchItemId(branchId) {
    var branches, rightBranch
    branches = module.visuals.branches
    rightBranch = getBranchById(branchId)
    if (rightBranch) {
        return rightBranch.node.itemId
    } else {
        return branches[0].node.itemId
    }
}

function getClipboard(type) {
    if (getClipboardType() == type) {
        return getClipboardCore()
    } else {
        return null;
    }
}

function getClipboardCore(type) {
    var fun
    fun = module.callbacks.getClipboard
    if (fun) {
        return fun();
    } else {
        return null;
    }
}

function getClipboardType() {
    var fun
    fun = module.callbacks.getClipboardType
    if (fun) {
        return fun();
    } else {
        return null;
    }
}

function getCompX1(item) {
    return -item.w
}

function getCompX2(item) {
    return -item.w + Config.INPUT_LEFT
}

function getCompX3(item) {
    return item.w - Config.INPUT_LEFT * 2
}

function getCompX4(item) {
    return item.w - Config.INPUT_LEFT * 1.4
}

function getCompX5(item) {
    return item.w
}

function getCompY1(item) {
    return -item.h
}

function getCompY2(item) {
    var y1 = getCompY1(item)
    var y4 = getCompY4(item)
    return (y1 + y4) / 2
}

function getCompY3(item) {
    return -item.h + item.a * 2
}

function getCompY4(item) {
    return getCompY3(item) + Config.INPUT_OVERLAP
}

function getCompY5(item) {
    return item.h
}

function getCopyFunction(node) {
    var _sw91830000_ = 0;
    _sw91830000_ = node.type;
    if (_sw91830000_ === "header") {
        return null
    } else {
        if (_sw91830000_ === "question") {
            return copyQuestion
        } else {
            if (_sw91830000_ === "case") {
                return copyCase
            } else {
                if (_sw91830000_ === "address") {
                    return null
                } else {
                    if (_sw91830000_ === "params") {
                        return null
                    } else {
                        if (_sw91830000_ === "junction") {
                            return null
                        } else {
                            if (_sw91830000_ === "branch") {
                                return copyBranch
                            } else {
                                if (_sw91830000_ === "select") {
                                    return copySelect
                                } else {
                                    if (_sw91830000_ === "loopbegin") {
                                        return copyLoop
                                    } else {
                                        if (_sw91830000_ === "loopend") {
                                            return copyLoopEnd
                                        } else {
                                            return copySimple
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

function getCopyTarget(node, ordinal) {
    var next
    if (ordinal >= node.next.length) {
        return ""
    } else {
        next = node.next[ordinal]
        if (next.id in module.selection.prims) {
            return next.itemId
        } else {
            return "finish"
        }
    }
}

function getCreateList(dict, key) {
    var list
    list = dict[key]
    if (list) {
        
    } else {
        list = []
        dict[key] = list
    }
    return list
}

function getCreateObj(dict, key) {
    var obj
    obj = dict[key]
    if (obj) {
        
    } else {
        obj = {}
        dict[key] = obj
    }
    return obj
}

function getDiaLineFormat(item) {
    var format = {}
    format.lineColor = Theme.get("line")
    format.lineThickness = Theme.get("thickness")
    return format
}

function getDiagramAsItems() {
    var items, storage
    items = copyItems()
    storage = module.storage
    return {
        name : storage.name,
        type : storage.type,
        items : items
    }
}

function getDistance(n1, n2, vertical) {
    var dx, dy
    dx = n1.x - n2.x
    dy = n1.y - n2.y
    if (vertical) {
        dx *= 4
    } else {
        dy *= 4
    }
    return Math.sqrt(dx * dx + dy * dy)
}

function getDown(node) {
    return node.down.tail
}

function getEdge(edgeId) {
    var visuals
    visuals = module.visuals
    return visuals.edges.get(edgeId)
}

function getEditItem(id) {
    return module.storage.items[id]
}

function getEffectiveItemId(visuals, node) {
    if (node.itemId) {
        return node.itemId
    } else {
        return firstBranchNode(visuals).itemId
    }
}

function getFlowerHeight(self) {
    return self.height
}

function getFlowerWidth(self) {
    var width
    width = self.x
    var _ind2273 = 0;
    var _col2273 = self.widths;
    var _len2273 = _col2273.length;
    while (true) {
        if (_ind2273 < _len2273) {
            
        } else {
            break;
        }
        var lineWidth = _col2273[_ind2273];
        width = Math.max(width, lineWidth)
        _ind2273++;
    }
    return width
}

function getFont() {
    return null
}

function getFonts(diagram) {
    return []
}

function getFontsForItems(ids) {
    return []
}

function getFormat(ids) {
    return {}
}

function getFormatForIcon(type) {
    var format
    format = {}
    format.fillColor = Theme.icon(type, "iconback")
    format.lineColor = Theme.icon(type, "iconline")
    format.lineThickness = Theme.icon(type, "thickness")
    format.lineStyle = Theme.icon(type, "style")
    format.shadow = Theme.icon(type, "shadow")
    return format
}

function getIconCount(graph) {
    var result = 0;
    return result;
}

function getIconEngine(type) {
    var engine
    engine = module.icons[type]
    if (engine) {
        return engine
    } else {
        return null
    }
}

function getItem(id) {
    var node
    node = getNodeByItem(
        module.visuals,
        id
    )
    if (node) {
        return {
            id : node.itemId,
            x : node.x,
            y : node.y,
            text : node.text,
            type : node.type
        }
    } else {
        return null
    }
}

function getItemRect(id) {
    
}

function getLeft(node) {
    return node.left.head
}

function getLeftCase(caseIcon) {
    var index, select
    select = caseIcon.select
    index = select.cases.indexOf(caseIcon)
    if (index == 0) {
        return null
    } else {
        return select.cases[index - 1]
    }
}

function getLeftHeight(node) {
    var left
    if ((node.type == "junction") && (node.left)) {
        left = getLeft(node)
        if (left.type == "question") {
            return left.h
        } else {
            return 0
        }
    } else {
        return 0
    }
}

function getLowestLevel(visuals) {
    var bottom
    if (visuals.end) {
        return visuals.end.level
    } else {
        bottom = goDown(visuals.header)
        return bottom.level
    }
}

function getNextBranch(branchNode) {
    var branches, index
    branches = module.visuals.branches
    if (branchNode.branchId == branches.length) {
        index = 0
    } else {
        index = branchNode.branchId
    }
    return branches[index]
}

function getNextDown(node) {
    while (true) {
        node = getLeft(node)
        if (node.down) {
            break;
        }
    }
    return node
}

function getNextId(visuals) {
    var id
    id = visuals.nextId.toString()
    visuals.nextId++
    return id
}

function getNextOccurence() {
    var current, occ, search, total
    search = module.search
    total = search.occurences.length
    current = search.output.current
    if (total == 0) {
        return -1
    } else {
        while (true) {
            current++
            if (current >= total) {
                return -1
            }
            occ = search.occurences[current]
            if (occ.active) {
                return current
            }
        }
    }
}

function getNextStorageId() {
    var id, storage
    storage = module.storage
    id = storage.nextId.toString()
    storage.nextId++
    return id
}

function getNextUp(node) {
    while (true) {
        node = getLeft(node)
        if (node.up) {
            break;
        }
    }
    return node
}

function getNode(nodeId) {
    var visuals
    visuals = module.visuals
    return visuals.nodes.get(nodeId)
}

function getNodeByItem(visuals, itemId) {
    return visuals.itemsToNodes[itemId]
}

function getNodeInfo(context, node) {
    var nodeInfo
    if (node.id in context.nodes) {
        nodeInfo = context.nodes[node.id]
    } else {
        nodeInfo = {
            node : node,
            include : false,
            remaining : node.prev.length,
            aremaining : node.aprev.length
        }
        context.nodes[node.id] = nodeInfo
    }
    return nodeInfo
}

function getNodeLines(node) {
    var txt = node.text || ""
    var lines1 = txt.split("\n")
    var isNotEmpty = function(text) {
    	return text.trim() != ""
    }
    return lines1.filter(isNotEmpty)
}

function getNodeTokens(node) {
    var identifiers, isIdentifier, takeText
    isIdentifier = function(token) {
        return token.type == "identifier"
    }
    if (node.tokens) {
        identifiers = node.tokens.filter(
            isIdentifier
        )
        if (identifiers.length == 0) {
            return undefined
        } else {
            takeText = function(token) {
                return token.text
            }
            return identifiers.map(
                takeText
            )
        }
    } else {
        return undefined
    }
}

function getNodesFromSelection() {
    var node, result, selection
    result = []
    selection = module.selection
    var _ind4883 = 0;
    var _col4883 = selection.prims;
    var _keys4883 = Object.keys(_col4883); 
    var _len4883 = _keys4883.length;
    while (true) {
        if (_ind4883 < _len4883) {
            
        } else {
            break;
        }
        var id = _keys4883[_ind4883]; var prim = _col4883[id];
        if (prim == "node") {
            node = getNode(id)
            result.push(node)
        }
        _ind4883++;
    }
    return result
}

function getNumberPart(text) {
    var first, tail
    text = text || ""
    first = firstDigit(text)
    if (first == -1) {
        return 0
    } else {
        tail = text.substring(
            first,
            text.length
        )
        return parseInt(tail)
    }
}

function getPrevOccurence() {
    var current, occ, search, total
    search = module.search
    total = search.occurences.length
    current = search.output.current
    if (total == 0) {
        return -1
    } else {
        while (true) {
            current--
            if (current < 0) {
                return -1
            }
            occ = search.occurences[current]
            if (occ.active) {
                return current
            }
        }
    }
}

function getRight(node) {
    return node.right.tail
}

function getSearchState() {
    var search
    search = module.search
    return {
        output : Utils.copyObject(search.output),
        input : Utils.copyObject(search.input)
    }
}

function getSelection() {
    
}

function getSilCorner(visuals) {
    var beneath, left
    beneath = getDown(visuals.header)
    left = getLeft(beneath)
    return left
}

function getSocketBranchId(socket) {
    var branchId
    if (socket.left) {
        branchId = socket.node.branchId
    } else {
        branchId = socket.node.branchId + 1
    }
    return branchId
}

function getSocketElement(socket) {
    var element
    if (socket.edge) {
        element = socket.edge
    } else {
        element = socket.node
    }
    return element
}

function getSpaceWidth(self) {
    if (self.spaceWidth) {
        
    } else {
        self.spaceWidth = render.measureTextWidth(
            "n"
        )
    }
    return self.spaceWidth
}

function getTabPosition(self, x) {
    var currentTabCount, spaceWidth, tabWidth, targetTabCount
    spaceWidth = getSpaceWidth(self)
    tabWidth = spaceWidth * SpacesInTab
    currentTabCount = Math.floor(x / tabWidth)
    targetTabCount = currentTabCount + 1
    return targetTabCount * tabWidth
}

function getTokenColor(token, source) {
    var type
    if (source) {
        if ((token.type == "identifier") && ((token.text in module.keywords) || (token.text in module.keyValues))) {
            type = "keyword"
        } else {
            type = token.type
        }
        return Theme.get(type)
    } else {
        return Theme.get("identifier")
    }
}

function getUp(node) {
    return node.up.head
}

function getX(node) {
    return node.skewer.coord
}

function getY(node) {
    return node.level.coord
}

function getYesColor() {
    return Theme.get("backtext")
}

function goDown(node) {
    while (true) {
        if (node.down) {
            
        } else {
            break;
        }
        node = getDown(node)
    }
    return node
}

function goLeft(node) {
    while (true) {
        if (node.left) {
            
        } else {
            break;
        }
        node = getLeft(node)
    }
    return node
}

function goRight(node) {
    while (true) {
        if (node.right) {
            
        } else {
            break;
        }
        node = getRight(node)
    }
    return node
}

function goUp(node) {
    while (true) {
        if (node.up) {
            
        } else {
            break;
        }
        node = getUp(node)
    }
    return node
}

function handleBacktick(self, op, cat, code) {
    if (op === "char") {
        if (self.escaping) {
            handleEscape(
                self,
                code
            )
            self.escaping = false
        } else {
            if (code === module.BACKTICK) {
                addChar(self, code)
                sendToken(
                    self,
                    "string",
                    self.chars
                )
                setTop(self, "normal")
            } else {
                if (code === module.BACK) {
                    self.escaping = true
                } else {
                    addChar(self, code)
                }
            }
        }
    } else {
        if (op === "eol") {
            sendToken(
                self,
                "string",
                self.chars
            )
        } else {
            if (op === "finish") {
                
            } else {
                throw "Unexpected switch value: " + op;
            }
            sendToken(
                self,
                "error",
                self.chars
            )
        }
    }
}

function handleBuilding(self, op, cat, code, pos) {
    if (op == "char") {
        if ((cat === "digit") || (cat === "alpha")) {
            addChar(self, code)
        } else {
            if (cat === "operator") {
                finishSToken(self)
                sendSToken(
                    self,
                    pos,
                    [code]
                )
            } else {
                finishSToken(self)
            }
        }
    } else {
        finishSToken(self)
    }
}

function handleChoose(self, op, cat, code) {
    if (op == "char") {
        if (code === module.SLASH) {
            addChar(self, code)
            setTop(self, "one")
        } else {
            if (code === module.STAR) {
                addChar(self, code)
                setTop(self, "multi")
            } else {
                if ((cat == "whitespace") || (!(canStartRegex(self)))) {
                    sendToken(
                        self,
                        "operator",
                        self.chars
                    )
                    setTop(self, "normal")
                    self.onChar(
                        op,
                        cat,
                        code
                    )
                } else {
                    addChar(self, code)
                    setTop(self, "regex")
                }
            }
        }
    } else {
        sendToken(
            self,
            "operator",
            self.chars
        )
        setTop(self, "normal")
    }
}

function handleEscape(self, code) {
    addChar(self, module.BACK)
    addChar(self, code)
}

function handleIdle(self, op, cat, code, pos) {
    if (op == "char") {
        if ((cat === "digit") || (cat === "alpha")) {
            self.pos = pos
            addChar(self, code)
            self.top = "building"
        } else {
            if (cat === "operator") {
                sendSToken(
                    self,
                    pos,
                    [code]
                )
            }
        }
    }
}

function handleMulti(self, op, cat, code) {
    if (op === "char") {
        addChar(self, code)
        if (self.escaping) {
            if (code == module.SLASH) {
                sendToken(
                    self,
                    "comment",
                    self.chars
                )
                setTop(self, "normal")
            } else {
                self.escaping = false
            }
        } else {
            if (code == module.STAR) {
                self.escaping = true
            }
        }
    } else {
        if (op === "eol") {
            sendToken(
                self,
                "comment",
                self.chars
            )
        } else {
            if (op === "finish") {
                
            } else {
                throw "Unexpected switch value: " + op;
            }
            sendToken(
                self,
                "error",
                self.chars
            )
        }
    }
}

function handleNormal(self, op, cat, code) {
    if (op == "char") {
        if (cat == "operator") {
            if (((self.tt == "number") && (self.part == 1)) && (code == module.DOT)) {
                addChar(self, code)
                self.part = 2
            } else {
                finishToken(self)
                if (code === module.SINGLE_QUOTE) {
                    setTop(self, "single")
                    addChar(self, code)
                } else {
                    if (code === module.DOUBLE_QUOTE) {
                        setTop(self, "quote")
                        addChar(self, code)
                    } else {
                        if (code === module.BACKTICK) {
                            setTop(self, "backtick")
                            addChar(self, code)
                        } else {
                            if (code === module.SLASH) {
                                setTop(self, "choose")
                                addChar(self, code)
                            } else {
                                sendToken(
                                    self,
                                    "operator",
                                    [code]
                                )
                            }
                        }
                    }
                }
            }
        } else {
            if (self.tt == "idle") {
                if (cat === "digit") {
                    addChar(self, code)
                    setTt(self, "number")
                } else {
                    if (cat === "alpha") {
                        addChar(self, code)
                        setTt(self, "identifier")
                    } else {
                        if (cat === "whitespace") {
                            
                        } else {
                            throw "Unexpected switch value: " + cat;
                        }
                        sendToken(
                            self,
                            "whitespace",
                            [code]
                        )
                    }
                }
            } else {
                if ((cat === "digit") || (cat === "alpha")) {
                    addChar(self, code)
                } else {
                    if (cat === "whitespace") {
                        
                    } else {
                        throw "Unexpected switch value: " + cat;
                    }
                    finishToken(self)
                    sendToken(
                        self,
                        "whitespace",
                        [code]
                    )
                }
            }
        }
    } else {
        finishToken(self)
    }
}

function handleOne(self, op, cat, code) {
    if (op == "char") {
        addChar(self, code)
    } else {
        sendToken(
            self,
            "comment",
            self.chars
        )
        setTop(self, "normal")
    }
}

function handleQuote(self, op, cat, code, quote) {
    handleString(
        self,
        op,
        cat,
        code,
        module.DOUBLE_QUOTE
    )
}

function handleRegex(self, op, cat, code, quote) {
    if (op == "char") {
        if (self.part == 1) {
            if (self.escaping) {
                handleEscape(
                    self,
                    code
                )
                self.escaping = false
            } else {
                if (code === module.SLASH) {
                    addChar(self, code)
                    self.part = 2
                } else {
                    if (code === module.BACK) {
                        self.escaping = true
                    } else {
                        addChar(self, code)
                    }
                }
            }
        } else {
            if (cat == "alpha") {
                addChar(self, code)
            } else {
                sendToken(
                    self,
                    "number",
                    self.chars
                )
                setTop(self, "normal")
                self.onChar(
                    op,
                    cat,
                    code
                )
            }
        }
    } else {
        if (self.part == 1) {
            sendToken(
                self,
                "error",
                self.chars
            )
        } else {
            sendToken(
                self,
                "number",
                self.chars
            )
            setTop(self, "normal")
        }
    }
}

function handleSingle(self, op, cat, code, quote) {
    handleString(
        self,
        op,
        cat,
        code,
        module.SINGLE_QUOTE
    )
}

function handleString(self, op, cat, code, quote) {
    if (op == "char") {
        if (self.escaping) {
            handleEscape(
                self,
                code
            )
            self.escaping = false
        } else {
            if (code === quote) {
                addChar(self, code)
                sendToken(
                    self,
                    "string",
                    self.chars
                )
                setTop(self, "normal")
            } else {
                if (code === module.BACK) {
                    self.escaping = true
                } else {
                    addChar(self, code)
                }
            }
        }
    } else {
        sendToken(
            self,
            "error",
            self.chars
        )
    }
}

function hasOtherEntries(source, higher) {
    var context, node, visuals
    visuals = module.visuals
    context = {
        found : false,
        visited : {}
    }
    var _ind7050 = 0;
    var _col7050 = source.links;
    var _len7050 = _col7050.length;
    while (true) {
        if (_ind7050 < _len7050) {
            
        } else {
            break;
        }
        var link = _col7050[_ind7050];
        node = getNodeByItem(
            visuals,
            link.source
        )
        hasOtherEntriesStep(
            node,
            higher,
            context
        )
        _ind7050++;
    }
    return context.found
}

function hasOtherEntriesStep(lower, higher, context) {
    if (((context.found) || (lower == higher)) || (lower.id in context.visited)) {
        
    } else {
        context.visited[lower.id] = true
        if (lower.prev.length == 0) {
            context.found = true
        } else {
            var _ind7042 = 0;
            var _col7042 = lower.prev;
            var _len7042 = _col7042.length;
            while (true) {
                if (_ind7042 < _len7042) {
                    
                } else {
                    break;
                }
                var prev = _col7042[_ind7042];
                hasOtherEntriesStep(
                    prev,
                    higher,
                    context
                )
                _ind7042++;
            }
        }
    }
}

function hasUntouchedArrows(visited, node) {
    var _ind7756 = 0;
    var _col7756 = node.aprev;
    var _len7756 = _col7756.length;
    while (true) {
        if (_ind7756 < _len7756) {
            
        } else {
            return false
        }
        var prev = _col7756[_ind7756];
        if (prev.itemId in visited) {
            
        } else {
            return true
        }
        _ind7756++;
    }
}

function hasUntouchedUpstream(visited, node) {
    if (node.type == "case") {
        return false
    } else {
        var _ind5040 = 0;
        var _col5040 = node.prev;
        var _len5040 = _col5040.length;
        while (true) {
            if (_ind5040 < _len5040) {
                
            } else {
                return false
            }
            var prev = _col5040[_ind5040];
            if (prev.itemId in visited) {
                
            } else {
                return true
            }
            _ind5040++;
        }
    }
}

function hexByteToString(value) {
    return ("00" + value.toString(16)).substr(-2)
}

function hideSockets() {
    clearSockets()
}

function hit(pos) {
    return false;
}

function horizontalCandy(edge, render) {
    var head, headX, headY, left, right, tail, tailX, w, x, y
    head = edge.head
    tail = edge.tail
    headX = getX(head)
    headY = getY(head)
    tailX = getX(tail)
    x = headX
    y = headY
    w = tailX - headX
    left = x + head.w
    right = tailX
    render.createHCandy(
        x,
        y,
        w,
        false,
        left,
        right,
        "line_candies"
    )
}

function iconsInit() {
    var icons, noop
    icons = {}
    module.icons = icons
    defineIcon(
        "action",
        Action_draw,
        Action_flow
    )
    defineIcon(
        "question",
        Question_draw,
        Question_flow
    )
    defineIcon(
        "header",
        Header_draw,
        Header_flow
    )
    defineIcon(
        "end",
        Header_draw,
        Header_flow
    )
    defineIcon(
        "loopbegin",
        LoopBegin_draw,
        LoopBegin_flow
    )
    defineIcon(
        "loopend",
        LoopEnd_draw,
        LoopBegin_flow
    )
    defineIcon(
        "params",
        Params_draw,
        Params_flow
    )
    defineIcon(
        "select",
        Select_draw,
        Select_flow
    )
    defineIcon(
        "case",
        Case_draw,
        Case_flow
    )
    noop = function () {}
    defineIcon(
        "arrow-loop",
        noop,
        noop
    )
    defineIcon(
        "branch",
        Branch_draw,
        Branch_flow
    )
    defineIcon(
        "address",
        Address_draw,
        Branch_flow
    )
    defineIcon(
        "insertion",
        Insertion_draw,
        Insertion_flow
    )
    defineIcon(
        "input",
        Input_draw,
        Input_flow
    )
    defineIcon(
        "sinput",
        SInput_draw,
        Insertion_flow
    )
    defineIcon(
        "soutput",
        SOutput_draw,
        Action_flow
    )
    defineIcon(
        "pause",
        Pause_draw,
        Pause_flow
    )
}

function inTextArea(node, x, y) {
    if (canEditNodeText(node)) {
        return false
    } else {
        return false
    }
}

function init() {
    module.userSettings = {}
    lexInit()
    iconsInit()
    initColors()
    initSockets()
    module.widthNodes = {
        "end" : true,
        "header" : true,
        "junction" : true,
        "pause" : true
    }
    module.selectable = {
        action : true,
        insertion : true,
        question : true,
        "arrow-loop" : true,
        loopbegin : true,
        loopend : true,
        select : true,
        "case" : true,
        input : true,
        pause : true,
        sinput : true,
        soutput : true
    }
    module.search = {
    	input: {
    		find: "",
    		replace: "",
    		sensitive: false,
    		whole: false
    	},
    	output: {
    		canPrev: false,
    		canNext: false,
    		canReplace: false,
    		current: -1,
    		total: 0,
    		before: "",
    		match: "",
    		after: ""
    	},
    	items: [],
    	occurences: []
    }
}

function initColors() {
    module.colors = {}
    module.colors.iconFill = "#000000"
    module.colors.iconBorder = "#ffffff"
    module.colors.background = "#303000"
}

function initSockets() {
    module.insertActions = {}
    module.insertActions.action = function(socket) {
        return simpleInsert(socket, "action")
    }
    module.insertActions.insertion = function(socket) {
        return simpleInsert(socket, "insertion")
    }
    module.insertActions.input = function(socket) {
        return simpleInsert(socket, "input")
    }
    module.insertActions.sinput = function(socket) {
        return simpleInsert(socket, "sinput")
    }
    module.insertActions.soutput = function(socket) {
        return simpleInsert(socket, "soutput")
    }
    module.insertActions.pause = function(socket) {
        return simpleInsert(socket, "pause")
    }
    module.insertActions.select = selectInsert
    module.insertActions["case"] = caseInsert
    module.insertActions["first-case"] = firstCaseInsert
    module.insertActions.question = questionInsert
    module.insertActions["foreach"] = foreachInsert
    module.insertActions.branch = branchInsert
}

function insertFreeItem(x, y, type, subtype) {
    
}

function isActive(occ) {
    return occ.active
}

function isAddressJun(node) {
    var above
    if (node.up) {
        above = getUp(node)
        if ((above.type == "address") || ((node.right) && (node.right.role == "floor"))) {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function isAlgoprop() {
    return !!module.storage.keywords.algoprop
}

function isArrowLoop(node) {
    return node.type == "arrow-loop"
}

function isBackLink(lower, upper) {
    if ((isArrowLoop(upper)) && (contains(upper.aprev, lower))) {
        return true
    } else {
        return false
    }
}

function isBranchJun(node) {
    var below
    if (node.down) {
        below = getDown(node)
        if (below.type == "branch") {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function isCaseJun(node) {
    var below
    if (node.down) {
        below = getDown(node)
        if (below.type == "case") {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function isClosing(state, finish) {
    if ((state.current.type == "operator") && (state.current.text == finish)) {
        return true
    } else {
        return false
    }
}

function isDegQuestion(edge) {
    if (((edge.vertical) || (!(edge.head.type == "question"))) || (!(edge.tail.up))) {
        return false
    } else {
        return true
    }
}

function isDigit(c) {
    if ((c >= module.ZERO) && (c <= module.NINE)) {
        return true
    } else {
        return false
    }
}

function isDrawableNode(node) {
    if (node.skewer) {
        return true
    } else {
        return false
    }
}

function isEnd(state) {
    return state.current.type == "end"
}

function isHuman() {
    return module.language == "LANG_HUMAN"
}

function isLeftDown(node) {
    if (((((node.type == "junction") && (node.left)) && (!(node.up))) && (!(node.right))) && (node.down)) {
        return true
    } else {
        return false
    }
}

function isLeftUp(node) {
    if (((((node.type == "junction") && (node.left)) && (node.up)) && (!(node.right))) && (!(node.down))) {
        return true
    } else {
        return false
    }
}

function isLower(record, source) {
    if (record.type == "node") {
        return record.element.y > source.tail.y
    } else {
        return record.element.tail.y > source.tail.y
    }
}

function isNewStart(prev, item) {
    if (item.type == "operator") {
        return false
    } else {
        if (((noBreakKeyword(item)) || (prev == "operator")) || (prev == "keyword")) {
            return false
        } else {
            return true
        }
    }
}

function isOperator(c) {
    if (module.opChars[c]) {
        return true
    } else {
        return false
    }
}

function isPart(haystack, start, needle) {
    var end, htoken, i, ntoken
    end = start + needle.length
    if (end > haystack.length) {
        return false
    } else {
        i = 0;
        while (true) {
            if (i < needle.length) {
                
            } else {
                return true
            }
            htoken = haystack[i + start]
            ntoken = needle[i]
            if (htoken.text == ntoken.text) {
                
            } else {
                return false
            }
            i++;
        }
    }
}

function isRightT(node) {
    if (((((node.type == "junction") && (!(node.left))) && (node.up)) && (node.right)) && (node.down)) {
        return true
    } else {
        return false
    }
}

function isRightUp(node) {
    if (((((node.type == "junction") && (!(node.left))) && (node.up)) && (node.right)) && (!(node.down))) {
        return true
    } else {
        return false
    }
}

function isScenario() {
    return !!module.storage.keywords.scenario
}

function isSelected(id) {
    return id in module.selection.prims
}

function isSeparator(item) {
    if ((item.text == ",") || (item.text == ";")) {
        return true
    } else {
        return false
    }
}

function isSeqStart(item) {
    var _sw115000000_ = 0;
    _sw115000000_ = item.type;
    if (_sw115000000_ === "operator") {
        if ((item.text == ")") || (item.text == "=>")) {
            return true
        } else {
            return false
        }
    } else {
        if (_sw115000000_ === "keyword") {
            return true
        } else {
            return false
        }
    }
}

function isSilhouette() {
    return module.visuals.branches.length > 1
}

function isSimpleItem(node) {
    var _sw57660000_ = 0;
    _sw57660000_ = node.type;
    if (((((((_sw57660000_ === "header") || (_sw57660000_ === "end")) || (_sw57660000_ === "junction")) || (_sw57660000_ === "select")) || (_sw57660000_ === "question")) || (_sw57660000_ === "address")) || ((_sw57660000_ === "case") && (firstCase(node.select) == node))) {
        return false
    } else {
        return true
    }
}

function isSingleComment(item) {
    if ((item.type == "comment") && (item.text.substring(0, 2) == "//")) {
        return true
    } else {
        return false
    }
}

function isSubset(larger, smaller) {
    if (larger) {
        var _ind6241 = 0;
        var _col6241 = smaller;
        var _keys6241 = Object.keys(_col6241); 
        var _len6241 = _keys6241.length;
        while (true) {
            if (_ind6241 < _len6241) {
                
            } else {
                return true
            }
            var smallKey = _keys6241[_ind6241]; var _ = _col6241[smallKey];
            if (smallKey in larger) {
                
            } else {
                return false
            }
            _ind6241++;
        }
    } else {
        return false
    }
}

function isUpstream(lower, upper) {
    var context
    context = {
        found : false,
        visited : {}
    }
    isUpstreamStep(
        lower,
        upper,
        context
    )
    return context.found
}

function isUpstreamStep(lower, upper, context) {
    if (context.found) {
        
    } else {
        if (lower == upper) {
            context.found = true
        } else {
            if (lower.id in context.visited) {
                
            } else {
                context.visited[lower.id] = true
                var _ind7129 = 0;
                var _col7129 = lower.prev;
                var _len7129 = _col7129.length;
                while (true) {
                    if (_ind7129 < _len7129) {
                        
                    } else {
                        break;
                    }
                    var prev = _col7129[_ind7129];
                    isUpstreamStep(
                        prev,
                        upper,
                        context
                    )
                    _ind7129++;
                }
            }
        }
    }
}

function isWhitespace(c) {
    if (((((c >= 9) && (c <= 13)) || (c == 32)) || (c == 133)) || (c == 160)) {
        return true
    } else {
        return false
    }
}

function itemToBText(lines, item) {
    var type
    var _sw127560000_ = 0;
    _sw127560000_ = item.type;
    if (_sw127560000_ === "branch") {
        type = "branch" + item.branchId
        addBText(
            lines,
            item.id,
            type,
            item.text,
            item.one,
            item.two
        )
    } else {
        if (_sw127560000_ === "select") {
            addSelectToBText(
                lines,
                item
            )
        } else {
            if (_sw127560000_ === "question") {
                addIfToBText(
                    lines,
                    item
                )
            } else {
                if (_sw127560000_ === "case") {
                    
                } else {
                    type = item.type
                    addBText(
                        lines,
                        item.id,
                        type,
                        item.text,
                        item.one,
                        item.two
                    )
                }
            }
        }
    }
}

function juncCandy(node, render) {
    render.createJCandy(
        node.x,
        node.y,
        CandyColor,
        "icon_candies"
    )
}

function keyToString(table, row) {
    var result
    result = ""
    var _ind3212 = 0;
    var _col3212 = table.keys;
    var _len3212 = _col3212.length;
    while (true) {
        if (_ind3212 < _len3212) {
            
        } else {
            break;
        }
        var part = _col3212[_ind3212];
        result += "|" + row[part]
        _ind3212++;
    }
    return result
}

function lastCase(select) {
    return select.cases[select.cases.length - 1]
}

function lastElement(array) {
    if (array.length == 0) {
        return null
    } else {
        return array[array.length - 1]
    }
}

function layoutPrimitive(visuals) {
    var branch, header
    branch = firstBranchNode(visuals)
    header = visuals.header
    header.next = branch.next
    buildManhattan(
        visuals,
        header
    )
}

function layoutSelect(visuals, stack, select) {
    var i, jun, left, node
    select.cases = []
    node = select.next[0]
    while (true) {
        node.select = select
        select.cases.push(node)
        if (node.next.length == 2) {
            
        } else {
            break;
        }
        node = node.next[1]
    }
    left = null
    var _ind6544 = 0;
    var _col6544 = select.cases;
    var _len6544 = _col6544.length;
    while (true) {
        if (_ind6544 < _len6544) {
            
        } else {
            break;
        }
        var caseNode = _col6544[_ind6544];
        jun = createJunction(
            visuals,
            null
        )
        makeDownEdgeCore(
            visuals,
            jun,
            caseNode,
            null
        )
        if (left) {
            createEdge(
                visuals,
                left,
                jun,
                false
            )
        }
        left = jun
        _ind6544++;
    }
    makeDownEdgeCore(
        visuals,
        select,
        getUp(select.cases[0]),
        null
    )
    i = select.cases.length - 1;
    while (true) {
        if (i >= 0) {
            
        } else {
            break;
        }
        node = select.cases[i]
        planStep(
            stack,
            node,
            node.next[0]
        )
        i--;
    }
}

function layoutSilhouette(visuals) {
    var first, leftDown, leftUp, lower, upper
    leftUp = createJunction(
        visuals,
        null
    )
    leftDown = createJunction(
        visuals,
        null
    )
    createEdge(
        visuals,
        leftUp,
        leftDown,
        true
    )
    upper = leftUp
    lower = leftDown
    var _ind8331 = 0;
    var _col8331 = visuals.branches;
    var _len8331 = _col8331.length;
    while (true) {
        if (_ind8331 < _len8331) {
            
        } else {
            break;
        }
        var branch = _col8331[_ind8331];
        buildManhattan(
            visuals,
            branch.node
        )
        connectBranch(
            visuals,
            branch,
            upper,
            lower
        )
        upper = branch.topNode
        lower = branch.bottomNode
        _ind8331++;
    }
    leftUp.right.role = "rarrow"
    first = visuals.branches[0]
    createEdge(
        visuals,
        visuals.header,
        first.topNode,
        true
    )
}

function lexInit() {
    module.opChars = []
    var i = 0;
    while (true) {
        if (i < 256) {
            
        } else {
            break;
        }
        module.opChars.push(false)
        i++;
    }
    saveOpChar("!")
    saveOpChar(";")
    saveOpChar("?")
    saveOpChar("=")
    saveOpChar("<")
    saveOpChar(">")
    saveOpChar("-")
    saveOpChar("+")
    saveOpChar("/")
    saveOpChar("\\")
    saveOpChar("*")
    saveOpChar("%")
    saveOpChar("(")
    saveOpChar(")")
    saveOpChar("(")
    saveOpChar(")")
    saveOpChar("{")
    saveOpChar("}")
    saveOpChar("[")
    saveOpChar("]")
    saveOpChar(":")
    saveOpChar(".")
    saveOpChar("#")
    saveOpChar(",")
    saveOpChar("^")
    saveOpChar("|")
    saveOpChar("&")
    saveOpChar("'")
    saveOpChar("\"")
    saveOpChar("`")
    module.ZERO = firstChar("0")
    module.NINE = firstChar("9")
    module.UNDER = firstChar("_")
    module.DOT = firstChar(".")
    module.BACK = firstChar("\\")
    module.ESCAPE_X = firstChar("x")
    module.ESCAPE_R = firstChar("r")
    module.ESCAPE_T = firstChar("t")
    module.ESCAPE_N = firstChar("n")
    module.DOUBLE_QUOTE = firstChar("\"")
    module.SINGLE_QUOTE = firstChar("\'")
    module.EQUALS = firstChar("=")
    module.SLASH = firstChar("/")
    module.STAR = firstChar("*")
    module.BACKTICK = firstChar("`")
    module.R = firstChar("r")
    module.N = firstChar("n")
    module.T = firstChar("t")
    module.longOps = {}
    addLongOp("==")
    addLongOp("===")
    addLongOp("...")
    addLongOp("!==")
    addLongOp(">>>")
    addLongOp("!=")
    addLongOp("<=")
    addLongOp(">=")
    addLongOp("&&")
    addLongOp("||")
    addLongOp("+=")
    addLongOp("-=")
    addLongOp("/=")
    addLongOp("*=")
    addLongOp("|=")
    addLongOp("^=")
    addLongOp("&=")
    addLongOp("=>")
    addLongOp("++")
    addLongOp("--")
    module.keywords = arrayToSet([
    "abstract", "arguments", "boolean", "break", "byte", "case", "catch",
    "char", "class", "const", "continue", "debugger", "default", "delete",
    "do", "double", "else", "enum", "eval", "export", "extends",
    "final", "finally", "float", "for", "function", "goto", "if",
    "implements", "import", "in", "instanceof", "int", "interface",
    "let", "long", "native", "new", "package", "private", "protected",
    "public", "return", "short", "static", "super",
    "switch", "synchronized", "throw", "throws", "transient", "try", "typeof", "var",
    "void", "volatile", "while", "yield", "async", "await"])
    module.keyOps = {}
    module.keyOps["in"] = true
    module.keyOps["instanceof"] = true
    module.keyOps["typeof"] = true
    module.noSpaces = {}
    module.noSpaces[";"] = true
    module.noSpaces[","] = true
    module.noSpaces[")"] = true
    module.noSpaces["]"] = true
    module.noSpaces["}"] = true
    module.noSpaces["("] = true
    module.noSpaces["["] = true
    module.noSpaces["{"] = true
    module.noSpaces["!"] = true
    module.keyValues = arrayToSet(["true", "false", "null", "undefined", "this"])
}

function lexSearch(text) {
    var lexer, machineList, machines, tcollection
    text = text || ""
    lexer = createSearchLexer()
    tcollection = createSearchTokens()
    machineList = [
    	lexer,
    	tcollection
    ]
    machines = new MachineStack(
        machineList
    )
    toTokens2(
        machines,
        text
    )
    return tcollection
}

function lexSource(text) {
    var lexer, machineList, machines, ob, tcollection
    text = text  || ""
    lexer = createTreeLexer()
    tcollection = createTokenCollection()
    ob = new OperBuilder()
    ob.tokens = []
    ob.finish = function() {mergeOps(ob)}
    machineList = [
    	lexer,
    	ob,
    	tcollection
    ]
    machines = new MachineStack(
        machineList
    )
    toTokens2(
        machines,
        text
    )
    tcollection.tokens.push(
        {type:"end", text:""}
    )
    return tcollection.tokens
}

function linkEdgeToSkewer(skewer, edge) {
    edge.skewer = skewer
    skewer.edges.push(edge)
}

function linkLevels(visuals, above, below, distance) {
    linkSkewersGeneric(
        visuals.levelLinks,
        above,
        below,
        distance
    )
}

function linkNext(context, node1, nextItemId) {
    var address, node2, prevCount, visuals
    visuals = context.visuals
    if (nextItemId) {
        node2 = getNodeByItem(
            visuals,
            nextItemId
        )
        if (node2.type == "branch") {
            address = lastElement(context.addresses)
            if ((address) && (address.branch == node2)) {
                
            } else {
                address = createNode(
                    visuals,
                    null,
                    "address",
                    node2.text,
                    null
                )
                flowIcon(
                    module.render,
                    address
                )
                address.branch = node2
                address.itemId = node2.itemId
                context.addresses.push(address)
            }
            node1.next.push(address)
            address.prev.push(node1)
        } else {
            if ((isArrowLoop(node2)) && (isUpstream(node1, node2))) {
                node1.next.push(node2)
                node2.aprev.push(node1)
            } else {
                prevCount = node2.prev.length
                node1.next.push(node2)
                node2.prev.push(node1)
                if (prevCount == 0) {
                    linkNodeToChildren(
                        context,
                        nextItemId
                    )
                }
            }
        }
    }
}

function linkNodeToChildren(context, itemId) {
    var item, items, node
    items = module.storage.items
    item = items[itemId]
    node = getNodeByItem(
        context.visuals,
        itemId
    )
    linkNext(
        context,
        node,
        item.one
    )
    linkNext(
        context,
        node,
        item.two
    )
}

function linkNodeToLevel(level, node) {
    node.level = level
    level.nodes.push(node)
}

function linkNodeToSkewer(skewer, node) {
    node.skewer = skewer
    skewer.nodes.push(node)
}

function linkSkewers(visuals, left, right, distance) {
    linkSkewersGeneric(
        visuals.skewerLinks,
        left,
        right,
        distance
    )
}

function linkSkewersGeneric(links, low, high, distance) {
    var link
    link = links.get(
        low.id,
        high.id
    )
    if (link) {
        
    } else {
        link = new SkewerLink(
            low.id,
            high.id
        )
        links.insert(
            link
        )
    }
    link.distance = Math.max(
        link.distance,
        distance
    )
}

function loadDiagram(diagram) {
    var storage
    addTrace(
        "loadDiagram",
        [diagram.type, diagram.name]
    )
    storage = createStorage(
        diagram,
        diagram.version || 1
    )
    var _ind2957 = 0;
    var _col2957 = diagram.items;
    var _len2957 = _col2957.length;
    while (true) {
        if (_ind2957 < _len2957) {
            
        } else {
            break;
        }
        var item = _col2957[_ind2957];
        storage.items[item.id] = item
        _ind2957++;
    }
    recalculateNextId()
    buildVisualsForEdit()
    clearUndo()
}

function longOp1(text) {
    return text in module.longOps
}

function longOp2(text1, text2) {
    var part1
    part1 = module.longOps[text1]
    if (part1) {
        return text2 in part1
    } else {
        return false
    }
}

function longOp3(text1, text2, text3) {
    var part1, part2
    part1 = module.longOps[text1]
    if (part1) {
        part2 = part1[text2]
        if (part2) {
            return text3 in part2
        } else {
            return false
        }
    } else {
        return false
    }
}

function loopBoundaryCheck(depth, node) {
    if (node.type == "loopbegin") {
        depth--
    } else {
        if (node.type == "loopend") {
            depth++
        }
    }
    return depth
}

function makeAddressPoints(w, h) {
    var x = 0
    var y = 0
    var x0 = x - w;
    var x1 = x;
    var x2 = x + w;
    var top = y - h;
    var bottom = y + h;
    var middle = top + 2.0 / 3.0 * h;
    return [
     x0, middle,
     x1, top,    
     x2, middle,
     x2, bottom,
     x0, bottom
    ]
}

function makeCasePoints(w, h) {
    var x = 0
    var y = 0
    var x0 = x - w;
    var x1 = x;
    var x2 = x + w;
    var top = y - h;
    var bottom = y + h;
    var middle = bottom - 2.0 / 3.0 * h;
    return [
    	x0, top,
    	x2, top,
    	x2, middle,
    	x1, bottom,
    	x0, middle
    ]
}

function makeChar2Text(self, char2) {
    return Utils.arrayToString(
        [self.chars[0], char2]
    )
}

function makeComplexInput(item) {
    var x1 = -item.w
    var x2 = -item.w + Config.INPUT_LEFT * 1.4
    var x3 = -item.w + Config.INPUT_LEFT * 2
    var x4 = item.w - Config.INPUT_LEFT
    var x5 = item.w
    var y1 = getCompY1(item)
    var y2 = getCompY2(item)
    var y3 = getCompY3(item)
    var y4 = getCompY4(item)
    var y5 = getCompY5(item)
    return [
    	x1, y1,
    	x4, y1,
    	x4, y3,
    	x5, y3,
    
    	x5, y5,
    	x3, y5,
    	x3, y4,
    
    	x1, y4,
    	x2, y2
    ]
}

function makeComplexLower2(item) {
    var x1 = getCompX1(item)
    var x3 = getCompX3(item)
    var x1 = -item.w + Config.INPUT_LEFT * 2
    var x3 = item.w
    var y3 = getCompY3(item)
    var y5 = getCompY5(item)
    return [
    	x1, y5,
    	x1, y3,
    	x3, y3,
    	x3, y5
    ]
}

function makeCustomTexture(render, x, y, w, h) {
    var texId = render.createTexture(
    	x,
    	y,
    	- w,
    	- h,
    	w * 2,
    	h * 2,
    	"icons"
    );
    return texId;
}

function makeDownEdge(visuals, head, tail, finalTarget) {
    var edge
    edge = makeDownEdgeCore(
        visuals,
        head,
        tail,
        finalTarget
    )
    if (isLeftDown(head)) {
        finalTarget.mountUp = head
    }
    edge.role = "down"
    return edge
}

function makeDownEdgeCore(visuals, head, tail, finalTarget) {
    var edge
    edge = createEdge(
        visuals,
        head,
        tail,
        true
    )
    edge.finalTarget = finalTarget
    edge.source = head
    edge.target = tail
    head.targets.push(edge)
    tail.sources.push(edge)
    return edge
}

function makeInputPoints(w, h) {
    var x2 = w;
    var x0 = -w;
    var x1 = x0 + Config.INPUT_LEFT * 1.4;
    var y2 = h;
    var y0 = -h;
    var y1 = 0;
    return [
      x0, y0,
      x2, y0,
      x2, y2,
      x0, y2,
      x1, y1
    ]
}

function makeLeftEdge(visuals, left, right, finalTarget) {
    var edge
    edge = createEdge(
        visuals,
        left,
        right,
        false
    )
    edge.role = "left"
    edge.finalTarget = finalTarget
    edge.source = right
    edge.target = left
    right.targets.push(edge)
    left.sources.push(edge)
    return edge
}

function makeLineFormat(format) {
    if (format.lineColor === "none") {
        format = {
            lineColor : Theme.get("identifier")
        }
    }
    return format
}

function makeLoopBeginPoints(w, h) {
    var x = 0
    var y = 0
    var notch = Q_PADDING;
    
    var x0 = x - w;
    var x1 = x0 + notch;
    var x3 = x + w;
    var x2 = x3 - notch;
    
    var top = y - h;
    var bottom = y + h;
    
    var middle = top + notch;
    return [
     x0, bottom,
     x0, middle,
     x1, top,
     x2, top,
     x3, middle,
     x3, bottom
    ]
}

function makeLoopEndPoints(w, h) {
    var x = 0
    var y = 0
    var notch = Q_PADDING;
    
    var x0 = x - w;
    var x1 = x0 + notch;
    var x3 = x + w;
    var x2 = x3 - notch;
    
    var top = y - h;
    var bottom = y + h;
    var middle = bottom - notch;
    return [
     x0, top,
     x3, top,
     x3, middle,
     x2, bottom,
     x1, bottom,
     x0, middle
    ]
}

function makeOutputPoints(w, h) {
    var x2 = w;
    var x0 = -w;
    var x1 = x2 - Config.INPUT_LEFT;
    var y2 = h;
    var y0 = -h;
    var y1 = 0;
    return [
      x0, y0,
      x1, y0,
      x2, y1,
      x1, y2,
      x0, y2
    ]
}

function makePausePoints(w, h) {
    var x = 0
    var y = 0
    var x0 = x - w;
    var top = y - h;
    var width = w * 2;
    var height = h * 2;
    var bottom = top + height;
    
    var x3 = x0 + width;
    var x1 = x0 + Q_PADDING;
    var x2 = x3 - Q_PADDING;
    return [
     x0, top,
     x3, top,
     x2, bottom,
     x1, bottom
    ]
}

function makePointToItem(address, branch, menu) {
    var redirect, targetId, text
    targetId = branch.node.itemId
    redirect = function() {
        return redirectAddress(address, targetId)
    }
    text = tr("MES_POINT_TO") + " " +
    	branch.node.text
    pushMenuItem(
        menu,
        text,
        null,
        brutal(redirect, null)
    )
}

function makeQuestionPoints(w, h) {
    var bottom, result, top, x, x0, x1, x2, x3, y
    x = 0
    y = 0
    x0 = x - w
    x1 = x0 + Q_PADDING
    x3 = x + w
    x2 = x3 - Q_PADDING
    top = y - h
    bottom = y + h
    result = [
    	x0, y,
    	x1, top,
    	x2, top,
    	x3, y,
    	x2, bottom,
    	x1, bottom
    ]
    return result
}

function makeRandomColor() {
    var b, g, r, rb, rg, rs
    r = random(200, 256)
    g = random(200, 256)
    b = random(200, 256)
    rs = hexByteToString(r)
    rg = hexByteToString(g)
    rb = hexByteToString(b)
    return "#" + rs + rg + rb
}

function makeRightEdge(visuals, left, right, finalTarget) {
    var edge
    edge = createEdge(
        visuals,
        left,
        right,
        false
    )
    edge.role = "right"
    edge.finalTarget = finalTarget
    edge.source = left
    edge.target = right
    left.targets.push(edge)
    right.sources.push(edge)
    return edge
}

function makeRightLoopEdge(visuals, left, right, finalTarget) {
    var edge
    edge = createEdge(
        visuals,
        left,
        right,
        false
    )
    edge.role = "right-loop"
    edge.finalTarget = finalTarget
    edge.source = left
    edge.target = right
    left.targets.push(edge)
    right.sources.push(edge)
    finalTarget.rightEdge = edge
    return edge
}

function makeSelectPoints(w, h) {
    var x = 0
    var y = 0
    var shift = Q_PADDING / 2
    var x0 = x - w;
    var x1 = x0 + shift;
    var x3 = x + w;
    var x2 = x3 - shift;
    var top = y - h;
    var bottom = y + h;
    return [
    	x0, bottom,
    	x1, top,
    	x3, top,
    	x2, bottom
    ]
}

function makeTokenFromChars(self, type) {
    var token
    token = new Token(
        type
    )
    token.text = Utils.arrayToString(
        self.chars
    )
    return token
}

function makeUpEdge(visuals, head, tail, finalTarget) {
    var edge
    edge = createEdge(
        visuals,
        head,
        tail,
        true
    )
    edge.finalTarget = finalTarget
    edge.source = tail
    edge.target = head
    tail.targets.push(edge)
    head.sources.push(edge)
    edge.role = "up"
    finalTarget.upEdge = edge
    return edge
}

function markArrow(loop) {
    var arrow, bottom, downEdge, leftBottom, rightEdge, start, top, upEdge
    arrow = loop.right
    top = arrow.tail
    upEdge = top.down
    top.arrow = upEdge
    arrow.arrow = upEdge
    arrow.finalTarget = upEdge.finalTarget
    arrow.links = upEdge.links
    upEdge.arrow = upEdge
    bottom = upEdge.tail
    if (isLeftUp(bottom)) {
        bottom.arrow = upEdge
        rightEdge = bottom.left
        leftBottom = rightEdge.head
        rightEdge.arrow = upEdge
        if (isRightUp(leftBottom)) {
            leftBottom.arrow = upEdge
            downEdge = leftBottom.up
            start = downEdge.head
            downEdge.arrow = upEdge
            if (start.type == "junction") {
                
            } else {
                start.arrow = upEdge
            }
        }
    }
}

function markFloor(self, address) {
    var bottom, floor, next, sub
    sub = self.sub
    bottom = goDown(address)
    next = getNextBranch(
        address.branch
    )
    floor = bottom.right
    if (floor) {
        floor.finalTarget = next.node
        floor.outer = sub
        floor.noBranch = address.itemId
        addEdgeSubRecord(
            sub.outer,
            floor
        )
    } else {
        bottom.finalTarget = next.node
        bottom.noBranch = address.itemId
        addNodeSubRecord(
            sub.outer,
            bottom
        )
    }
}

function markInnerSide(self, lower) {
    var crawler2, leftCase, leftJun, n2, question, result, upper
    upper = lower
    while (true) {
        upper = getUp(upper)
        if (upper.left) {
            break;
        }
    }
    n2 = getDown(upper)
    crawler2 = createInner(
        "down",
        self.sub
    )
    if (n2.type == "case") {
        crawl(crawler2, n2.down)
        leftJun = getLeft(upper)
        leftCase = getDown(leftJun)
        leftJun.zoned = true
        result = leftCase.down
    } else {
        crawl(crawler2, upper.down)
        if (upper.up) {
            upper.left.inner = self.sub
        }
        question = goLeft(upper)
        question.zoned = true
        result = question.down
    }
    return result
}

function markOtherCasesToStay(node) {
    var below, toKeep
    toKeep = {}
    var _ind6855 = 0;
    var _col6855 = node.select.cases;
    var _len6855 = _col6855.length;
    while (true) {
        if (_ind6855 < _len6855) {
            
        } else {
            break;
        }
        var caseNode = _col6855[_ind6855];
        if (caseNode == node) {
            
        } else {
            below = caseNode.next[0]
            markToStay(
                caseNode,
                below.itemId,
                toKeep
            )
        }
        _ind6855++;
    }
    return toKeep
}

function markToDelete(visited, prev, startItemId, edits) {
    var addDeletion, context, items
    items = module.storage.items
    context = {
        items : items,
        deleteList : [],
        visited : visited,
        edits : edits
    }
    traverseItemToDelete(
        context,
        prev,
        startItemId
    )
    addDeletion = function(id) {
        deleteItem(edits, id)
    }
    context.deleteList.forEach(
        addDeletion
    )
}

function markToStay(prev, startItemId, toKeep) {
    traverseItem(
        module.storage.items,
        prev,
        startItemId,
        toKeep
    )
}

function maxHeight(height, node) {
    return Math.max(height, node.h)
}

function measureDiagram() {
    var border, bottom, left, right, top, visuals
    left = Number.MAX_VALUE
    right = -Number.MAX_VALUE
    top = Number.MAX_VALUE
    bottom = -Number.MAX_VALUE
    border = Config.METRE
    visuals = module.visuals
    var _ind5321 = 0;
    var _col5321 = visuals.nodes.rows;
    var _keys5321 = Object.keys(_col5321); 
    var _len5321 = _keys5321.length;
    while (true) {
        if (_ind5321 < _len5321) {
            
        } else {
            break;
        }
        var id = _keys5321[_ind5321]; var node = _col5321[id];
        if (isDrawableNode(node)) {
            left = Math.min(left, node.box.left)
            top = Math.min(top, node.box.top)
            right = Math.max(right, node.box.right)
            bottom = Math.max(bottom, node.box.bottom)
        }
        _ind5321++;
    }
    return new Utils.Box(
        left - border,
        top - border,
        right + border,
        bottom + border
    )
}

function merge(from, to) {
    if (from) {
        var _ind8017 = 0;
        var _col8017 = from;
        var _keys8017 = Object.keys(_col8017); 
        var _len8017 = _keys8017.length;
        while (true) {
            if (_ind8017 < _len8017) {
                
            } else {
                break;
            }
            var key = _keys8017[_ind8017]; var value = _col8017[key];
            to[key] = value
            _ind8017++;
        }
    }
}

function mergeOps(self) {
    var text, token
    var _sw110950000_ = 0;
    _sw110950000_ = self.tokens.length;
    if (_sw110950000_ === 0) {
        
    } else {
        if (_sw110950000_ === 1) {
            self.next.onToken(
                self.tokens[0]
            )
        } else {
            if (_sw110950000_ === 2) {
                text = self.tokens[0].text +
                	self.tokens[1].text
            } else {
                if (_sw110950000_ === 3) {
                    
                } else {
                    throw "Unexpected switch value: " + _sw110950000_;
                }
                text = self.tokens[0].text +
                	self.tokens[1].text +
                	self.tokens[2].text
            }
            token = new Token("operator")
            token.text = text
            self.next.onToken(token)
        }
        self.tokens = []
    }
}

function mild(action, node) {
    return function() {
    	var edits = action(node)
    	editAndSave(edits)
    }
}

function mouseClick(x, y) {
    var prim
    addTrace("mouseClick", [x, y])
    prim = findVisualItem(
        x,
        y
    )
    if (prim) {
        addTrace("found vi", [prim.id])
        if (prim.id) {
            printPrim(prim)
            if (isSelected(prim.id)) {
                
            } else {
                deselectAll()
                selectPrim(prim.id)
                if (prim.type == Const.TEXT) {
                    startEditText(prim.id)
                } else {
                    showLianaSockets(prim)
                }
            }
        }
    } else {
        addTrace("found nothing", [])
        deselectAll()
    }
    redrawCanvas()
    return {
    	mustRedraw: true
    }
}

function moveBranchIdsLeft(branchId) {
    var branches, edits, newId
    edits = []
    branches = module.visuals.branches
    var _ind9022 = 0;
    var _col9022 = branches;
    var _len9022 = _col9022.length;
    while (true) {
        if (_ind9022 < _len9022) {
            
        } else {
            break;
        }
        var branch = _col9022[_ind9022];
        if (branch.node.branchId > branchId) {
            newId = branch.node.branchId - 1
            updateItem(
                edits,
                branch.node.itemId,
                {branchId: newId}
            )
        }
        _ind9022++;
    }
    return edits
}

function moveBranchIdsRight(branchId) {
    var branches, edits, newId
    edits = []
    branches = module.visuals.branches
    var _ind8993 = 0;
    var _col8993 = branches;
    var _len8993 = _col8993.length;
    while (true) {
        if (_ind8993 < _len8993) {
            
        } else {
            break;
        }
        var branch = _col8993[_ind8993];
        if (branch.node.branchId >= branchId) {
            newId = branch.node.branchId + 1
            updateItem(
                edits,
                branch.node.itemId,
                {branchId: newId}
            )
        }
        _ind8993++;
    }
    return edits
}

function moveEndUp(visuals) {
    var below, distance, lastBranch, levels
    if (visuals.end) {
        lastBranch = visuals.branches[
        	visuals.branches.length - 1
        ]
        below = getDown(lastBranch.node)
        distance = below.level.coord - 
        	lastBranch.node.level.coord -
        	below.h -
        	lastBranch.node.h -
        	Config.METRE
        if (distance > 0) {
            levels = collectLevels(
                visuals,
                lastBranch
            )
            var _ind8557 = 0;
            var _col8557 = levels;
            var _len8557 = _col8557.length;
            while (true) {
                if (_ind8557 < _len8557) {
                    
                } else {
                    break;
                }
                var level = _col8557[_ind8557];
                level.coord -= distance
                _ind8557++;
            }
        }
    }
}

function moveHandle(id, handleType, dx, dy, x, y) {
    
}

function nextBranchName() {
    var max, number
    max = 0
    var _ind8209 = 0;
    var _col8209 = module.visuals.branches;
    var _len8209 = _col8209.length;
    while (true) {
        if (_ind8209 < _len8209) {
            
        } else {
            break;
        }
        var branch = _col8209[_ind8209];
        number = getNumberPart(branch.node.text)
        max = Math.max(max, number)
        _ind8209++;
    }
    return branchLabel() + (max + 1)
}

function nextSymbol(state) {
    state.index++
    state.current = state.tokens[state.index]
}

function no() {
    return translateLabel("no", "DIA_NO")
}

function noBreakKeyword(item) {
    if (item.type == "keyword") {
        if ((((((item.text == "async") || (item.text == "await")) || (item.text == "function")) || (item.text == "else")) || (item.text == "catch")) || (item.text == "finally")) {
            return true
        } else {
            return false
        }
    } else {
        return false
    }
}

function noWidth(render) {
    return render.measureTextWidth(no())
}

function nodeFromItem(visuals, item) {
    var node, text
    if (item.type == "end") {
        text = end()
    } else {
        text = item.text || ""
    }
    node = createNode(
        visuals,
        item.id,
        item.type,
        text,
        item.id
    )
    setNotNull(item, node, "flag1")
    setNotNull(item, node, "branchId")
    setNotNull(item, node, "text2")
    return node
}

function onChar(self, op, cat, code) {
    var handler
    handler = self.handlers[self.top]
    handler(self, op, cat, code)
    if (op == "eol") {
        self.next.eol()
    } else {
        if (op == "finish") {
            self.next.finish()
        }
    }
}

function onLexChar(self, op, cat, code, pos) {
    var handler
    handler = self.handlers[self.top]
    handler(self, op, cat, code, pos)
}

function onSearchChange() {
    var state
    var fun = module.callbacks.onSearchChange
    if (fun) {
        state = getSearchState()
        fun(state)
    }
}

function oneLine(text) {
    return text.split("\n").join(" ")
}

function paste(x, y) {
    var type
    type = getClipboardType()
    showPasteSockets(type)
}

function pasteBlock(socket, payload) {
    var create, edits, firstId
    edits = []
    firstId = replaceIds(
        payload.start,
        payload.items,
        socket.target
    )
    create = function(item) {
        createPastedItem(edits, item)
    }
    payload.items.forEach(create)
    redirectUpperItems(
        edits,
        socket.links,
        firstId
    )
    return edits
}

function pasteBranch(socket, block) {
    var branch, branchId, create, edits, items, newId, oldToNew, start, targetId, targets
    items = block.items
    start = block.start
    targets = block.targets
    branchId = getSocketBranchId(socket)
    targetId = getBranchItemId(
        branchId
    )
    edits = moveBranchIdsRight(
        branchId
    )
    var _ind9686 = 0;
    var _col9686 = items;
    var _len9686 = _col9686.length;
    while (true) {
        if (_ind9686 < _len9686) {
            
        } else {
            break;
        }
        var item = _col9686[_ind9686];
        if (item.id == start) {
            item.branchId = branchId
            break;
        }
        _ind9686++;
    }
    oldToNew = generateNewIds(
        items
    )
    var _ind9658 = 0;
    var _col9658 = targets;
    var _keys9658 = Object.keys(_col9658); 
    var _len9658 = _keys9658.length;
    while (true) {
        if (_ind9658 < _len9658) {
            
        } else {
            break;
        }
        var oldId = _keys9658[_ind9658]; var name = _col9658[oldId];
        branch = getBranchByName(name)
        if (branch) {
            newId = branch.node.itemId
        } else {
            newId = targetId
        }
        oldToNew[oldId] = newId
        _ind9658++;
    }
    replaceTargets(
        items,
        oldToNew
    )
    create = function(item) {
        createPastedItem(edits, item)
    }
    items.forEach(create)
    return edits
}

function pasteInSocket(socket) {
    var ctype, edits, payload
    var _sw93560000_ = 0;
    edits = []
    payload = getClipboardCore()
    ctype = getClipboardType()
    if (payload) {
        _sw93560000_ = socket.type;
        if (_sw93560000_ === "block") {
            if (socket.type == ctype) {
                edits = pasteBlock(
                    socket,
                    payload
                )
            }
        } else {
            if (_sw93560000_ === "case") {
                if (ctype == "case") {
                    edits = caseInsertCore(
                        socket.node,
                        payload.items[0]
                    )
                }
            } else {
                if (_sw93560000_ === "first-case") {
                    if (ctype == "case") {
                        edits = firstCaseInsertCore(
                            socket.node,
                            payload.items[0]
                        )
                    }
                } else {
                    if ((_sw93560000_ === "branch") && (socket.type == ctype)) {
                        edits = pasteBranch(
                            socket,
                            payload
                        )
                    }
                }
            }
        }
    }
    return edits
}

function pasteText(node) {
    var text
    text = getClipboard("text")
    if (text) {
        setNodeText(
            node.id,
            text
        )
    }
}

function performChange(edit, isUndo) {
    var item, items, old, storage, target
    var _sw29100000_ = 0;
    var _sw29310000_ = 0;
    storage = module.storage
    items = storage.items
    _sw29100000_ = edit.table;
    if (_sw29100000_ === "diagrams") {
        if (isUndo) {
            Utils.copyFields(
                edit.undo,
                storage
            )
        } else {
            Utils.copyFields(
                edit.fields,
                storage
            )
        }
    } else {
        if (_sw29100000_ === "items") {
            
        } else {
            throw "Unexpected switch value: " + _sw29100000_;
        }
        _sw29310000_ = edit.type;
        if (_sw29310000_ === "insert") {
            if (isUndo) {
                delete items[edit.id]
            } else {
                item = Utils.copyObject(
                    edit.fields
                )
                item.id = edit.id
                items[edit.id] = item
            }
        } else {
            if (_sw29310000_ === "delete") {
                if (isUndo) {
                    item = Utils.copyObject(
                        edit.undo
                    )
                    item.id = edit.id
                    items[edit.id] = item
                } else {
                    delete items[edit.id]
                }
            } else {
                if (_sw29310000_ === "update") {
                    
                } else {
                    throw "Unexpected switch value: " + _sw29310000_;
                }
                old = items[edit.id]
                target = Utils.copyObject(old)
                items[edit.id] = target
                if (isUndo) {
                    Utils.copyFields(
                        edit.undo,
                        target
                    )
                } else {
                    Utils.copyFields(
                        edit.fields,
                        target
                    )
                }
            }
        }
    }
}

function performLocalChange(edits, isUndo) {
    var count, edit, i
    count = edits.length
    if (isUndo) {
        i = count - 1;
        while (true) {
            if (i >= 0) {
                
            } else {
                break;
            }
            edit = edits[i]
            performChange(
                edit,
                isUndo
            )
            i--;
        }
    } else {
        i = 0;
        while (true) {
            if (i < count) {
                
            } else {
                break;
            }
            edit = edits[i]
            performChange(
                edit,
                isUndo
            )
            i++;
        }
    }
}

function performRedo() {
    var step, undo
    undo = module.undo
    if (undo.next >= undo.steps.length) {
        
    } else {
        deselectAll()
        step = undo.steps[undo.next]
        addTrace("redo", step.info)
        editAndSaveCore(
            step.commands,
            false
        )
        undo.next++
    }
}

function performSearch() {
    var input, parsed, search, text, tokens
    search = module.search
    input = search.input
    search.occurences = []
    if (input.whole) {
        parsed = lexSearch(input.find)
        if (input.sensitive) {
            tokens = parsed.tokens
        } else {
            tokens = parsed.tokensLow
        }
        if (tokens.length == 0) {
            
        } else {
            var _ind12421 = 0;
            var _col12421 = search.items;
            var _len12421 = _col12421.length;
            while (true) {
                if (_ind12421 < _len12421) {
                    
                } else {
                    break;
                }
                var item = _col12421[_ind12421];
                scanItemWhole(
                    item,
                    tokens
                )
                _ind12421++;
            }
        }
    } else {
        if (input.sensitive) {
            text = input.find
        } else {
            text = input.find.toLowerCase()
        }
        if (text.length == 0) {
            
        } else {
            var _ind12433 = 0;
            var _col12433 = search.items;
            var _len12433 = _col12433.length;
            while (true) {
                if (_ind12433 < _len12433) {
                    
                } else {
                    break;
                }
                var item = _col12433[_ind12433];
                scanItem(
                    item,
                    text
                )
                _ind12433++;
            }
        }
    }
    search.output.current = -1
}

function performUndo() {
    var step, undo
    undo = module.undo
    if (undo.next > 0) {
        deselectAll()
        undo.next--
        step = undo.steps[undo.next]
        addTrace("undo", step.info)
        editAndSaveCore(
            step.commands,
            true
        )
    }
}

function persistChange(pers, edit, isUndo) {
    var fields, item
    var _sw27760000_ = 0;
    var _sw27810000_ = 0;
    _sw27760000_ = edit.table;
    if (_sw27760000_ === "diagrams") {
        if (isUndo) {
            fields = edit.undo
        } else {
            fields = edit.fields
        }
        pers.updateDiagram(fields)
    } else {
        _sw27810000_ = edit.type;
        if (_sw27810000_ === "insert") {
            if (isUndo) {
                pers.remove(edit.id)
            } else {
                item = edit.fields
                item.id = edit.id
                pers.add(item)
            }
        } else {
            if (_sw27810000_ === "update") {
                if (isUndo) {
                    fields = edit.undo
                } else {
                    fields = edit.fields
                }
                fields.id = edit.id
                pers.update(fields)
            } else {
                if (_sw27810000_ === "delete") {
                    
                } else {
                    throw "Unexpected switch value: " + _sw27810000_;
                }
                if (isUndo) {
                    item = edit.undo
                    item.id = edit.id
                    pers.add(item)
                } else {
                    pers.remove(edit.id)
                }
            }
        }
    }
}

function persistChanges(edits, isUndo) {
    var pers
    pers = module.persistence
    var _ind2767 = 0;
    var _col2767 = edits;
    var _len2767 = _col2767.length;
    while (true) {
        if (_ind2767 < _len2767) {
            
        } else {
            break;
        }
        var edit = _col2767[_ind2767];
        persistChange(
            pers,
            edit,
            isUndo
        )
        _ind2767++;
    }
    pers.persist()
}

function placeToken(self, token) {
    var token2, width, x2
    token.color = getTokenColor(
        token,
        self.source
    )
    width = self.render.measureTextWidth(
        token.text
    )
    x2 = self.x + width
    if (x2 > self.maxLength) {
        if (self.x == 0) {
            if (token.text.length == 1) {
                placeTokenCore(
                    self,
                    token,
                    width
                )
            } else {
                token2 = splitToken(
                    self,
                    token
                )
                placeToken(
                    self,
                    token2
                )
            }
        } else {
            addLine(self)
            if (width > self.maxLength) {
                if (token.text.length == 1) {
                    placeTokenCore(
                        self,
                        token,
                        width
                    )
                } else {
                    token2 = splitToken(
                        self,
                        token
                    )
                    placeToken(
                        self,
                        token2
                    )
                }
            } else {
                placeTokenCore(
                    self,
                    token,
                    width
                )
            }
        }
    } else {
        placeTokenCore(
            self,
            token,
            width
        )
    }
}

function placeTokenCore(self, token, width) {
    token.x = Math.floor(self.x)
    token.y = Math.floor(self.y)
    token.x = self.x
    token.y = self.y
    self.x += width
    self.width = self.x
    self.tokens.push(token)
}

function planNextSteps(visuals, stack, node) {
    var next1, next2
    var _sw64850000_ = 0;
    _sw64850000_ = node.type;
    if (_sw64850000_ === "select") {
        layoutSelect(
            visuals,
            stack,
            node
        )
    } else {
        if (_sw64850000_ === "question") {
            next1 = node.next[0]
            next2 = node.next[1]
            planRightStep(
                stack,
                node,
                next2
            )
            planStep(
                stack,
                node,
                next1
            )
        } else {
            if (_sw64850000_ === "arrow-loop") {
                next1 = buildArrowUp(
                    visuals,
                    node
                )
                planNextSteps(
                    visuals,
                    stack,
                    next1
                )
            } else {
                if (node.next.length == 0) {
                    
                } else {
                    next1 = node.next[0]
                    planStep(
                        stack,
                        node,
                        next1
                    )
                }
            }
        }
    }
}

function planRightStep(stack, node1, node2) {
    var step
    step = planStep(
        stack,
        node1,
        node2
    )
    step.down = false
    return step
}

function planSpace(self, node) {
    self.plan.push(node)
}

function planStep(stack, node1, node2) {
    var step
    step = new TraverseStep(
        node1,
        node2
    )
    if (isBackLink(node1, node2)) {
        step.back = true
    }
    stack.push(step)
    return step
}

function popFromSkewer(edits, node) {
    var dstId, edgeUp, item, items
    items = module.storage.items
    item = items[node.itemId]
    dstId = item.one
    edgeUp = node.up
    redirectUpperItems(
        edits,
        edgeUp.links,
        dstId
    )
    deleteItem(
        edits,
        node.itemId
    )
}

function positionLevels(visuals) {
    var distance, down, h, jun, leftHeight, lowest, max
    var _ind4155 = 0;
    var _col4155 = visuals.nodes.rows;
    var _keys4155 = Object.keys(_col4155); 
    var _len4155 = _keys4155.length;
    while (true) {
        if (_ind4155 < _len4155) {
            
        } else {
            break;
        }
        var id = _keys4155[_ind4155]; var node = _col4155[id];
        if (node.down) {
            down = getDown(node)
            leftHeight = getLeftHeight(node)
            if (leftHeight == 0) {
                h = node.h
            } else {
                h = leftHeight
            }
            distance = h + down.h +
            	Config.METRE
            linkLevels(
                visuals,
                down.level,
                node.level,
                distance
            )
        }
        _ind4155++;
    }
    lowest = getLowestLevel(visuals)
    calculateSkewerPos(
        visuals.levels,
        visuals.levelLinks,
        lowest,
        0
    )
    max = 0
    var _ind4167 = 0;
    var _col4167 = visuals.levels.rows;
    var _keys4167 = Object.keys(_col4167); 
    var _len4167 = _keys4167.length;
    while (true) {
        if (_ind4167 < _len4167) {
            
        } else {
            break;
        }
        var id = _keys4167[_ind4167]; var level = _col4167[id];
        max = Math.max(
            max,
            level.coord
        )
        _ind4167++;
    }
    var _ind4171 = 0;
    var _col4171 = visuals.levels.rows;
    var _keys4171 = Object.keys(_col4171); 
    var _len4171 = _keys4171.length;
    while (true) {
        if (_ind4171 < _len4171) {
            
        } else {
            break;
        }
        var id = _keys4171[_ind4171]; var level = _col4171[id];
        level.coord = max - level.coord
        _ind4171++;
    }
    var _ind6654 = 0;
    var _col6654 = visuals.nodes.rows;
    var _keys6654 = Object.keys(_col6654); 
    var _len6654 = _keys6654.length;
    while (true) {
        if (_ind6654 < _len6654) {
            
        } else {
            break;
        }
        var id = _keys6654[_ind6654]; var node = _col6654[id];
        if ((node.type == "case") || ((node.type == "branch") && (node.up))) {
            jun = getUp(node)
            node.level.coord = jun.level.coord +
              Config.METRE + node.h
        }
        _ind6654++;
    }
}

function positionSkewers(visuals) {
    var left
    var _ind4020 = 0;
    var _col4020 = visuals.skewers.rows;
    var _keys4020 = Object.keys(_col4020); 
    var _len4020 = _keys4020.length;
    while (true) {
        if (_ind4020 < _len4020) {
            
        } else {
            break;
        }
        var id = _keys4020[_ind4020]; var skewer = _col4020[id];
        findLeftLinks(
            visuals,
            skewer
        )
        _ind4020++;
    }
    if (visuals.branches.length == 1) {
        calculateSkewerPos(
            visuals.skewers,
            visuals.skewerLinks,
            visuals.header.skewer,
            0
        )
    } else {
        left = getSilCorner(visuals)
        calculateSkewerPos(
            visuals.skewers,
            visuals.skewerLinks,
            left.skewer,
            0
        )
    }
}

function precacheEdgesLinks(visuals) {
    var _ind4339 = 0;
    var _col4339 = visuals.edges.rows;
    var _keys4339 = Object.keys(_col4339); 
    var _len4339 = _keys4339.length;
    while (true) {
        if (_ind4339 < _len4339) {
            
        } else {
            break;
        }
        var id = _keys4339[_ind4339]; var edge = _col4339[id];
        findEdgeLinks(
            visuals,
            edge,
            edge
        )
        _ind4339++;
    }
}

function prepend(item, array) {
    var copy
    copy = array.slice()
    copy.unshift(item)
    return copy
}

function prettify(tokens, type) {
    var block2, rawFlower, root, rootBlock, state
    root = createBlock()
    state = createParsingState(
        tokens
    )
    readBlock(state, root, null, true)
    rootBlock = root.statement.items[0]
    if (rootBlock) {
        block2 = addSpaces(rootBlock)
        rawFlower = createRawFlower()
        if ((type == "loopbegin") || (type == "loopend")) {
            printBlockLine(
                block2,
                0,
                rawFlower
            )
        } else {
            printRootBlock(
                block2,
                rawFlower
            )
        }
        return rawFlower.tokens
    } else {
        return []
    }
}

function printBlock(block, depth, output) {
    var available
    if (block.seq) {
        var _ind11529 = 0;
        var _col11529 = block.statements;
        var _len11529 = _col11529.length;
        while (true) {
            if (_ind11529 < _len11529) {
                
            } else {
                break;
            }
            var statement = _col11529[_ind11529];
            startIndented(
                output,
                depth + 1
            )
            printStatement(
            	statement,
            	depth + 1,
            	output
            )
            _ind11529++;
        }
        startIndented(
            output,
            depth
        )
    } else {
        available = output.max - output.current
        if (block.length > available) {
            var _ind11529 = 0;
            var _col11529 = block.statements;
            var _len11529 = _col11529.length;
            while (true) {
                if (_ind11529 < _len11529) {
                    
                } else {
                    break;
                }
                var statement = _col11529[_ind11529];
                startIndented(
                    output,
                    depth + 1
                )
                printStatement(
                	statement,
                	depth + 1,
                	output
                )
                _ind11529++;
            }
            startIndented(
                output,
                depth
            )
        } else {
            printBlockLine(
                block,
                depth,
                output
            )
        }
    }
}

function printBlockLine(block, depth, output) {
    var first
    first = true
    var _ind11875 = 0;
    var _col11875 = block.statements;
    var _len11875 = _col11875.length;
    while (true) {
        if (_ind11875 < _len11875) {
            
        } else {
            break;
        }
        var statement = _col11875[_ind11875];
        if (first) {
            first = false
        } else {
            printToken(
                output,
                createSpace()
            )
        }
        printStatement(
        	statement,
        	depth,
        	output
        )
        _ind11875++;
    }
}

function printPrim(prim) {
    var edge, node, visuals
    if (Config.PRINT_PRIM) {
        visuals = module.visuals
        if (prim.id in visuals.nodes.rows) {
            node = getNode(prim.id)
            console.log(node)
        } else {
            edge = getEdge(prim.id)
            console.log(edge)
        }
    }
}

function printRootBlock(block, output) {
    var first
    first = true
    var _ind11681 = 0;
    var _col11681 = block.statements;
    var _len11681 = _col11681.length;
    while (true) {
        if (_ind11681 < _len11681) {
            
        } else {
            break;
        }
        var statement = _col11681[_ind11681];
        if (first) {
            first = false
        } else {
            startIndented(
                output,
                0
            )
        }
        printStatement(
        	statement,
        	0,
        	output
        )
        _ind11681++;
    }
}

function printStatement(statement, depth, output) {
    var available
    var _ind11570 = 0;
    var _col11570 = statement.items;
    var _len11570 = _col11570.length;
    while (true) {
        if (_ind11570 < _len11570) {
            
        } else {
            break;
        }
        var item = _col11570[_ind11570];
        if (item.type == "block") {
            printBlock(
                item,
                depth,
                output
            )
        } else {
            if (item.type == "eol") {
                startIndented(
                    output,
                    depth
                )
            } else {
                available = output.max - output.current
                if ((item.length > available) && ((item.type == "whitespace") || (item.type == "break"))) {
                    startIndented(
                        output,
                        depth
                    )
                } else {
                    printToken(
                        output,
                        item
                    )
                }
            }
        }
        _ind11570++;
    }
}

function printToken(output, token) {
    if (token.type == "break") {
        
    } else {
        if ((output.prevText == ")") && (token.text == "{")) {
            printToken(
                output,
                createSpace()
            )
        }
        output.tokens.push(token)
        output.current += token.text.length
        output.prevText = token.text || ""
    }
}

function printTokens(tokens) {
    var chunks
    chunks = []
    var _ind11596 = 0;
    var _col11596 = tokens;
    var _len11596 = _col11596.length;
    while (true) {
        if (_ind11596 < _len11596) {
            
        } else {
            break;
        }
        var token = _col11596[_ind11596];
        if (token.type == "eol") {
            chunks.push("\n")
        } else {
            chunks.push(token.text)
        }
        _ind11596++;
    }
    return chunks.join("")
}

function processOperator(self, c) {
    var builder
    self.next.endToken()
    if (c === module.DOUBLE_QUOTE) {
        builder = buildDoubleQuoter()
    } else {
        if (c === module.SINGLE_QUOTE) {
            builder = buildSingleQuoter()
        } else {
            builder = builderOperatorBuilder()
        }
    }
    builder.operator(c)
    addToList(
        builder,
        self
    )
}

function pushMenuItem(menu, text, image, code) {
    var item
    item = {
        type : "item",
        text : tr(text),
        image : image,
        code : code
    }
    menu.push(item)
}

function pushSeparator(menu) {
    var item, prev
    item = {
        type : "separator"
    }
    if (menu.length == 0) {
        
    } else {
        prev = menu[menu.length - 1]
        if (prev.type == "separator") {
            
        } else {
            menu.push(item)
        }
    }
}

function putCycleMark(address) {
    if (address.x >= address.branch.x) {
        address.mark = true
        address.branch.mark = true
    }
}

function putLoopsOnCases(select) {
    var _ind8007 = 0;
    var _col8007 = select.cases;
    var _len8007 = _col8007.length;
    while (true) {
        if (_ind8007 < _len8007) {
            
        } else {
            break;
        }
        var caseIcon = _col8007[_ind8007];
        merge(
            select.loops,
            caseIcon.loops
        )
        _ind8007++;
    }
}

function questionInsert(socket) {
    var edits, item, newId
    edits = []
    item = {
        type : "question",
        text : "",
        one : socket.target,
        two : socket.target,
        flag1 : 1
    }
    newId = createItem(
        edits,
        item
    )
    redirectUpperItems(
        edits,
        socket.links,
        newId
    )
    return edits
}

function random(min, max) {
    return Math.random() * (max - min) + min
}

function readBlock(state, parentBlock, finish, seq) {
    var result
    result = createBlock(seq)
    while (true) {
        if (readItem(state, result, finish)) {
            
        } else {
            break;
        }
    }
    startStatement(result)
    result.statement = null
    if (result.statements.length == 0) {
        
    } else {
        addItem(
            parentBlock,
            result
        )
    }
}

function readItem(state, parentBlock, finish) {
    var current, currentFinish, seq
    var _sw112670000_ = 0;
    if ((isEnd(state)) || (isClosing(state, finish))) {
        return false
    } else {
        current = state.current
        nextSymbol(state)
        _sw112670000_ = current.text;
        if (_sw112670000_ === "(") {
            currentFinish = ")"
            seq = false
            addItem(
                parentBlock,
                current
            )
            readBlock(
                state,
                parentBlock,
                currentFinish,
                seq
            )
            if (isEnd(state)) {
                return false
            } else {
                addItem(
                    parentBlock,
                    state.current
                )
                parentBlock.prev = "block"
                nextSymbol(state)
                return true
            }
        } else {
            if (_sw112670000_ === "{") {
                currentFinish = "}"
                seq = parentBlock.seqStart
                addItem(
                    parentBlock,
                    current
                )
                readBlock(
                    state,
                    parentBlock,
                    currentFinish,
                    seq
                )
                if (isEnd(state)) {
                    return false
                } else {
                    addItem(
                        parentBlock,
                        state.current
                    )
                    parentBlock.prev = "block"
                    nextSymbol(state)
                    return true
                }
            } else {
                if (_sw112670000_ === "[") {
                    currentFinish = "]"
                    seq = false
                    addItem(
                        parentBlock,
                        current
                    )
                    readBlock(
                        state,
                        parentBlock,
                        currentFinish,
                        seq
                    )
                    if (isEnd(state)) {
                        return false
                    } else {
                        addItem(
                            parentBlock,
                            state.current
                        )
                        parentBlock.prev = "block"
                        nextSymbol(state)
                        return true
                    }
                } else {
                    addSingleItem(
                        parentBlock,
                        current
                    )
                    return true
                }
            }
        }
    }
}

function rebuildSearchItems() {
    var search, visited, visuals
    search = module.search
    visuals = module.visuals
    search.occurences = []
    search.items = []
    visited = {}
    addNodeToSearch(
        visuals.params,
        search.items,
        visited
    )
    var _ind12344 = 0;
    var _col12344 = visuals.branches;
    var _len12344 = _col12344.length;
    while (true) {
        if (_ind12344 < _len12344) {
            
        } else {
            break;
        }
        var branch = _col12344[_ind12344];
        addBranchToSearch(
            branch.node,
            search.items,
            visited
        )
        _ind12344++;
    }
}

function rebuildSearchState() {
    rebuildSearchItems()
    performSearch()
    updateSearchOutput()
    onSearchChange()
}

function recalculateNextId() {
    var id, nextId, storage
    storage = module.storage
    nextId = storage.nextId
    var _ind2863 = 0;
    var _col2863 = storage.items;
    var _keys2863 = Object.keys(_col2863); 
    var _len2863 = _keys2863.length;
    while (true) {
        if (_ind2863 < _len2863) {
            
        } else {
            break;
        }
        var id = _keys2863[_ind2863]; var item = _col2863[id];
        id = parseInt(item.id) + 1
        nextId = Math.max(id, nextId)
        _ind2863++;
    }
    storage.nextId = nextId
}

function redirectAddress(address, targetId) {
    var edits
    edits = []
    redirectUpperItems(
        edits,
        address.up.links,
        targetId
    )
    return edits
}

function redirectBranch(branchItems, oldTargets, newTarget, edits) {
    var item, items
    items = module.storage.items
    var _ind8893 = 0;
    var _col8893 = branchItems;
    var _keys8893 = Object.keys(_col8893); 
    var _len8893 = _keys8893.length;
    while (true) {
        if (_ind8893 < _len8893) {
            
        } else {
            break;
        }
        var itemId = _keys8893[_ind8893]; var _ = _col8893[itemId];
        item = items[itemId]
        if (item.one in oldTargets) {
            updateItem(
                edits,
                itemId,
                {one: newTarget}
            )
        }
        if (item.two in oldTargets) {
            updateItem(
                edits,
                itemId,
                {two: newTarget}
            )
        }
        _ind8893++;
    }
}

function redirectUpperItems(edits, links, newId) {
    var change
    var _ind4578 = 0;
    var _col4578 = links;
    var _len4578 = _col4578.length;
    while (true) {
        if (_ind4578 < _len4578) {
            
        } else {
            break;
        }
        var link = _col4578[_ind4578];
        if (link.index == 0) {
            change = {
                one : newId
            }
        } else {
            change = {
                two : newId
            }
        }
        updateItem(
            edits,
            link.source,
            change
        )
        _ind4578++;
    }
}

function redraw() {
    if (module.storage) {
        buildVisualsForEdit()
        redrawCanvas()
    }
}

function redrawCanvas() {
    try {
    	redrawCanvasCore(null)
    } catch (ex) {
    	CallTrace.error(ex)
    	throw ex
    }
}

function redrawCanvasCore(insertionSocket) {
    var render, visuals
    visuals = module.visuals
    if (visuals) {
        render = module.render
        render.setBackground(
            Theme.get("back")
        )
        render.clear()
        drawCandies(
            visuals,
            render
        )
        if (Config.SHOW_ZONES) {
            drawSubspaces(
                visuals,
                render
            )
        }
        drawVisuals(
            visuals,
            render
        )
    }
}

function redrawCanvasCoreDummy(insertionSocket) {
    var item, item2, item3, item4, item5, item6, item7, item8, render, text1, text2
    if (module.storage) {
        buildVisualsForEdit()
    }
    render = module.render
    render.setBackground(
        module.colors.background
    )
    render.clear()
    item = {
        x : 200,
        y : 200
    }
    text1 = "var foo = bar.moo30X(\n" +
      "    3.345 + 4354,\n" +
      "\t1\t20\t300\t4000\tx\n" +
      "longstart\tyou\t\tend\n" +
      "one two three four five six seven eight nine ten eleven twelve " +
      "one two three four five six seven eight nine ten eleven twelve " +
      "one two three four five six seven eight nine ten eleven twelve " +
      "one two three four five six seven eight nine ten eleven twelve " +
      "onetwothreefourfivesixseveneightnineteneleventwelve" +
      "onetwothreefourfivesixseveneightnineteneleventwelve\n" +
      "thisIsAVeryLongIdentifierThat.isReallyLong()\n" +
      "    x35.foo == \"some \\t 'text'\"||y !== 20\)\n" +
      "    \"unfinished1\n" +
      "    \"unfinished2"
    item.type = "action"
    item.text = text1
    flowIcon(render, item)
    drawIcon(render, item)
    item3 = {
        type : "action",
        x : 800,
        y : 200,
        text : "foo.bar(\n\tvar1,\n\tvar2\n)"
    }
    flowIcon(render, item3)
    drawIcon(render, item3)
    item4 = {
        type : "action",
        x : 800,
        y : 300,
        text : "foo.bar(var1, var2,"
    }
    flowIcon(render, item4)
    drawIcon(render, item4)
    item5 = {
        type : "question",
        x : 800,
        y : 500,
        text : "foo.left == bar.right"
    }
    flowIcon(render, item5)
    drawIcon(render, item5)
    item6 = {
        type : "question",
        x : 800,
        y : 600,
        text : "oneTwoThree.fourFiveSix(\n\tmooFoo.x,\n\tmooFoo.y\n)",
        flag1 : true
    }
    flowIcon(render, item6)
    drawIcon(render, item6)
    item7 = {
        type : "action",
        x : 800,
        y : 700,
        text : "oneTwoThree.fourFiveSix(\n\tmooFoo.x,\n\tmooFoo.y\n)"
    }
    flowIcon(render, item7)
    drawIcon(render, item7)
    item8 = {
        type : "header",
        x : 800,
        y : 800,
        text : "DetVarEnGangEtMenneske"
    }
    flowIcon(render, item8)
    drawIcon(render, item8)
    item8 = {
        type : "end",
        x : 800,
        y : 900,
        text : "End"
    }
    flowIcon(render, item8)
    drawIcon(render, item8)
    item2 = {
        x : 200,
        y : 700,
        w : 400,
        h : 200
    }
    text2 = "«Acro mode» (Rate mode/Manual mode) — в этих режимах электронные помощники," +
    " отвечающие за стабилизацию дрона, будут отключены. Скоростные показатели" + 
    " достигнут максимальных значений.\nПилотирование в этих режимах смогут" +
    " реализовать лишь продвинутые пилоты. Помните – новичкам полет" +
    " в данных режимах должен быть ограничен, так как это не безопасно" +
    " как для пилота, так и для окружающих в месте запуска!"
    tmpRenderSource(
        render,
        item2,
        text2,
        false
    )
}

function remove(array, item) {
    var index
    index = array.indexOf(item)
    if (index == -1) {
        
    } else {
        array.splice(index, 1)
    }
}

function removeEdge(visuals, edgeId) {
    var edge, head, tail
    edge = visuals.edges.get(edgeId)
    head = edge.head
    tail = edge.tail
    if (edge.vertical) {
        head.down = null
        tail.up = null
    } else {
        head.right = null
        tail.left = null
    }
    remove(head.sources, edge)
    remove(head.targets, edge)
    remove(tail.sources, edge)
    remove(tail.targets, edge)
    edge.head = null
    edge.tail = null
    edge.source = null
    edge.target = null
    edge.finalTarget = null
    visuals.edges.remove(edgeId)
}

function removeFromList(item) {
    var next, prev
    prev = item.prev
    next = item.next
    prev.next = next
    if (next) {
        next.prev = prev
    }
    item.prev = null
    item.next = null
}

function removeNode(visuals, nodeId) {
    var node
    node = visuals.nodes.get(nodeId)
    if ((((node.up) || (node.left)) || (node.right)) || (node.down)) {
        throw new Error("Node is connected: "+
         nodeId)
    } else {
        node.finalTarget = null
        remove(
            node.skewer.nodes,
            node
        )
        remove(
            node.level.nodes,
            node
        )
        visuals.nodes.remove(nodeId)
    }
}

function removeTempEdges(visuals) {
    var edgeDown, edgeUp, finalTarget, lower, newLevel, oldLevel, tmpJun, upper
    var _ind8477 = 0;
    var _col8477 = visuals.tempEdges;
    var _len8477 = _col8477.length;
    while (true) {
        if (_ind8477 < _len8477) {
            
        } else {
            break;
        }
        var tmpEdge = _col8477[_ind8477];
        tmpJun = tmpEdge.head
        removeEdge(
            visuals,
            tmpEdge.id
        )
        edgeUp = tmpJun.up
        upper = edgeUp.head
        edgeDown = tmpJun.down
        lower = edgeDown.tail
        finalTarget = edgeUp.finalTarget
        removeEdge(
            visuals,
            edgeUp.id
        )
        removeEdge(
            visuals,
            edgeDown.id
        )
        removeNode(
            visuals,
            tmpJun.id
        )
        makeDownEdge(
            visuals,
            upper,
            lower,
            finalTarget
        )
        _ind8477++;
    }
    visuals.tempEdges = []
    if ((visuals.branches.length == 1) || (!(visuals.end))) {
        
    } else {
        oldLevel = visuals.end.level
        remove(
            oldLevel.nodes,
            visuals.end
        )
        newLevel = createLevel(
            visuals
        )
        newLevel.coord = oldLevel.coord
        newLevel.nodes.push(visuals.end)
        visuals.end.level = newLevel
        removeEdge(
            visuals,
            visuals.end.left.id
        )
        moveEndUp(visuals)
    }
}

function replace(input) {
    var search
    search = module.search
    if (search.output.canReplace) {
        doReplace(input.replace)
        search.output.current = getNextOccurence()
        updateSearchOutput()
    }
    return getSearchState()
}

function replaceAll(text, oldText, newText) {
    var parts
    parts = text.split(oldText)
    return parts.join(newText)
}

function replaceAllInItem(item, newNeedle, edits) {
    var count, oldText
    oldText = item.text
    count = 0
    var _ind12665 = 0;
    var _col12665 = item.occurences;
    var _len12665 = _col12665.length;
    while (true) {
        if (_ind12665 < _len12665) {
            
        } else {
            break;
        }
        var occ = _col12665[_ind12665];
        if (occ.active) {
            item.text = replaceOccurenceText(
                occ,
                newNeedle
            )
            occ.active = false
            shiftLowerOccurences(
                occ,
                newNeedle
            )
            count++
        }
        _ind12665++;
    }
    if (item.text == oldText) {
        
    } else {
        addReplaceCommand(
            edits,
            item.id,
            item.type,
            item.text
        )
    }
    return count
}

function replaceIds(startId, items, targetId) {
    var oldToNew
    oldToNew = generateNewIds(
        items
    )
    oldToNew["finish"] = targetId
    replaceTargets(
        items,
        oldToNew
    )
    return oldToNew[startId]
}

function replaceOccurence(occ, newNeedle) {
    var item, newText
    item = occ.item
    newText = replaceOccurenceText(
        occ,
        newNeedle
    )
    item.text = newText
    item.textLow = newText.toLowerCase()
    occ.active = false
    shiftLowerOccurences(
        occ,
        newNeedle
    )
    return newText
}

function replaceOccurenceText(occ, newNeedle) {
    var after, before, item, newText, text
    item = occ.item
    text = item.text
    before = text.substring(0, occ.begin)
    after = text.substring(occ.end)
    newText = before + newNeedle + after
    return newText
}

function replaceTarget(item, oldToNew) {
    if (item.one) {
        item.one = oldToNew[item.one]
    }
    if (item.two) {
        item.two = oldToNew[item.two]
    }
}

function replaceTargets(items, oldToNew) {
    var relink
    relink = function(item) {
        replaceTarget(item, oldToNew)
    }
    items.forEach(relink)
}

function replaceText() {
    
}

function requestSourceFlow(render, node) {
    if (isHuman()) {
        return flowText(
            render,
            node.text,
            Config.DEF_ICON_WIDTH
        )
    } else {
        return flowSourceCode(
            render,
            node,
            true
        )
    }
}

function requestTextFlow(render, node) {
    return flowText(
        render,
        node.text,
        Config.DEF_ICON_WIDTH
    )
}

function resetSelection() {
    module.selection = new Selection()
}

function roMethod(name, method) {
    var wrapped
    wrapped = function() {
    	var args = arrayFrom(arguments)
    	addTrace(name, args)
    	return method.apply(undefined, args)
    }
    module[name] = wrapped
}

function sameLoop(srcLinks, targetId) {
    var src, target, visuals
    visuals = module.visuals
    target = getNodeByItem(
        visuals,
        targetId
    )
    var _ind6227 = 0;
    var _col6227 = srcLinks;
    var _len6227 = _col6227.length;
    while (true) {
        if (_ind6227 < _len6227) {
            
        } else {
            return true
        }
        var link = _col6227[_ind6227];
        src = getNodeByItem(
            visuals,
            link.source
        )
        if ((isSubset(src.loops, target.loops)) || (canComeBackTo(src, target.loops))) {
            
        } else {
            return false
        }
        _ind6227++;
    }
}

function saveHandlePos(id) {
    
}

function saveOpChar(text) {
    var code
    code = firstChar(text)
    module.opChars[code] = true
}

function scanBranchItems(node, visited) {
    if ((node.itemId in visited) || (node.type == "address")) {
        
    } else {
        visited[node.itemId] = node
        var _ind8916 = 0;
        var _col8916 = node.next;
        var _len8916 = _col8916.length;
        while (true) {
            if (_ind8916 < _len8916) {
                
            } else {
                break;
            }
            var next = _col8916[_ind8916];
            scanBranchItems(next, visited)
            _ind8916++;
        }
    }
}

function scanItem(item, text) {
    var begin, current, end, hayStack, input, start
    input = module.search.input
    item.occurences = []
    if (input.sensitive) {
        hayStack = item.text
    } else {
        hayStack = item.textLow
    }
    current = 0
    while (true) {
        start = hayStack.indexOf(
            text,
            current
        )
        if (start == -1) {
            break;
        }
        begin = start
        end = start + text.length
        addOccurence(
            item,
            begin,
            end
        )
        current = start + text.length
    }
}

function scanItemWhole(item, tokens) {
    var begin, current, end, hayStack, input, lastToken, lastTokenId, start
    input = module.search.input
    item.occurences = []
    if (input.sensitive) {
        hayStack = item.tokens
    } else {
        hayStack = item.tokensLow
    }
    current = 0
    while (true) {
        start = findTokens(
            hayStack,
            tokens,
            current
        )
        if (start == -1) {
            break;
        }
        begin = hayStack[start].pos
        lastTokenId = start + tokens.length - 1
        lastToken = hayStack[lastTokenId]
        end = lastToken.pos + lastToken.text.length
        addOccurence(
            item,
            begin,
            end
        )
        current = lastTokenId + 1
    }
}

function scanManhattan(visited, node) {
    if (node.id in visited) {
        
    } else {
        visited[node.id] = true
        if (node.left) {
            scanManhattan(
                visited,
                getLeft(node)
            )
        }
        if (node.up) {
            scanManhattan(
                visited,
                getUp(node)
            )
        }
        if (node.right) {
            scanManhattan(
                visited,
                getRight(node)
            )
        }
        if (node.down) {
            scanManhattan(
                visited,
                getDown(node)
            )
        }
    }
}

function searchNext() {
    var search
    search = module.search
    if (search.output.canNext) {
        search.output.current = getNextOccurence()
        updateSearchOutput()
    }
    return getSearchState()
}

function searchPrev() {
    var search
    search = module.search
    if (search.output.canPrev) {
        search.output.current = getPrevOccurence()
        updateSearchOutput()
    }
    return getSearchState()
}

function selectAll() {
    
}

function selectCluster(headNode, node) {
    var context, included, info, selection, start
    var _sw100570000_ = 0;
    selection = module.selection
    if (isSelected(node.id)) {
        return headNode
    } else {
        _sw100570000_ = node.type;
        if (_sw100570000_ === "select") {
            start = node
            context = {
                paths : 0,
                nodes : {},
                arrows : 0,
                loops : {}
            }
            info = getNodeInfo(
                context,
                start
            )
            selectClusterStepNext(
                context,
                info
            )
            included = []
            var _ind10087 = 0;
            var _col10087 = context.nodes;
            var _keys10087 = Object.keys(_col10087); 
            var _len10087 = _keys10087.length;
            while (true) {
                if (_ind10087 < _len10087) {
                    
                } else {
                    break;
                }
                var id = _keys10087[_ind10087]; var info = _col10087[id];
                if (info.include) {
                    included.push(info.node)
                }
                _ind10087++;
            }
            return included.reduce(
                addOne,
                headNode
            )
        } else {
            if (_sw100570000_ === "case") {
                start = node.select
                context = {
                    paths : 0,
                    nodes : {},
                    arrows : 0,
                    loops : {}
                }
                info = getNodeInfo(
                    context,
                    start
                )
                selectClusterStepNext(
                    context,
                    info
                )
                included = []
                var _ind10087 = 0;
                var _col10087 = context.nodes;
                var _keys10087 = Object.keys(_col10087); 
                var _len10087 = _keys10087.length;
                while (true) {
                    if (_ind10087 < _len10087) {
                        
                    } else {
                        break;
                    }
                    var id = _keys10087[_ind10087]; var info = _col10087[id];
                    if (info.include) {
                        included.push(info.node)
                    }
                    _ind10087++;
                }
                return included.reduce(
                    addOne,
                    headNode
                )
            } else {
                if (_sw100570000_ === "loopbegin") {
                    start = node
                    context = {
                        paths : 0,
                        nodes : {},
                        arrows : 0,
                        loops : {}
                    }
                    info = getNodeInfo(
                        context,
                        start
                    )
                    selectClusterStepNext(
                        context,
                        info
                    )
                    included = []
                    var _ind10087 = 0;
                    var _col10087 = context.nodes;
                    var _keys10087 = Object.keys(_col10087); 
                    var _len10087 = _keys10087.length;
                    while (true) {
                        if (_ind10087 < _len10087) {
                            
                        } else {
                            break;
                        }
                        var id = _keys10087[_ind10087]; var info = _col10087[id];
                        if (info.include) {
                            included.push(info.node)
                        }
                        _ind10087++;
                    }
                    return included.reduce(
                        addOne,
                        headNode
                    )
                } else {
                    if (_sw100570000_ === "loopend") {
                        start = node.loopStart
                        context = {
                            paths : 0,
                            nodes : {},
                            arrows : 0,
                            loops : {}
                        }
                        info = getNodeInfo(
                            context,
                            start
                        )
                        selectClusterStepNext(
                            context,
                            info
                        )
                        included = []
                        var _ind10087 = 0;
                        var _col10087 = context.nodes;
                        var _keys10087 = Object.keys(_col10087); 
                        var _len10087 = _keys10087.length;
                        while (true) {
                            if (_ind10087 < _len10087) {
                                
                            } else {
                                break;
                            }
                            var id = _keys10087[_ind10087]; var info = _col10087[id];
                            if (info.include) {
                                included.push(info.node)
                            }
                            _ind10087++;
                        }
                        return included.reduce(
                            addOne,
                            headNode
                        )
                    } else {
                        if (_sw100570000_ === "arrow-loop") {
                            start = node
                            context = {
                                paths : 0,
                                nodes : {},
                                arrows : 0,
                                loops : {}
                            }
                            info = getNodeInfo(
                                context,
                                start
                            )
                            selectClusterStepNext(
                                context,
                                info
                            )
                            included = []
                            var _ind10087 = 0;
                            var _col10087 = context.nodes;
                            var _keys10087 = Object.keys(_col10087); 
                            var _len10087 = _keys10087.length;
                            while (true) {
                                if (_ind10087 < _len10087) {
                                    
                                } else {
                                    break;
                                }
                                var id = _keys10087[_ind10087]; var info = _col10087[id];
                                if (info.include) {
                                    included.push(info.node)
                                }
                                _ind10087++;
                            }
                            return included.reduce(
                                addOne,
                                headNode
                            )
                        } else {
                            if (_sw100570000_ === "question") {
                                start = node
                                context = {
                                    paths : 0,
                                    nodes : {},
                                    arrows : 0,
                                    loops : {}
                                }
                                info = getNodeInfo(
                                    context,
                                    start
                                )
                                selectClusterStepNext(
                                    context,
                                    info
                                )
                                included = []
                                var _ind10087 = 0;
                                var _col10087 = context.nodes;
                                var _keys10087 = Object.keys(_col10087); 
                                var _len10087 = _keys10087.length;
                                while (true) {
                                    if (_ind10087 < _len10087) {
                                        
                                    } else {
                                        break;
                                    }
                                    var id = _keys10087[_ind10087]; var info = _col10087[id];
                                    if (info.include) {
                                        included.push(info.node)
                                    }
                                    _ind10087++;
                                }
                                return included.reduce(
                                    addOne,
                                    headNode
                                )
                            } else {
                                return addOne(
                                    headNode,
                                    node
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

function selectClusterStep(context, src, node) {
    var aprev, joins, nodeInfo, prev
    if ((node.type == "end") || (node.type == "address")) {
        
    } else {
        nodeInfo = getNodeInfo(
            context,
            node
        )
        if (isBackLink(src, node)) {
            aprev = nodeInfo.node.aprev.length
            nodeInfo.aremaining--
            if (nodeInfo.aremaining == 0) {
                context.paths -= aprev
                selectClusterStepBack(
                    context,
                    nodeInfo
                )
            }
        } else {
            prev = nodeInfo.node.prev.length
            if (prev == 1) {
                selectClusterStepNext(
                    context,
                    nodeInfo
                )
            } else {
                nodeInfo.remaining--
                if (nodeInfo.remaining == 0) {
                    joins = prev - 1
                    context.paths -= joins
                    if (clusterComplete(context)) {
                        
                    } else {
                        selectClusterStepNext(
                            context,
                            nodeInfo
                        )
                    }
                }
            }
        }
    }
}

function selectClusterStepBack(context, nodeInfo) {
    var node
    if (nodeInfo.include) {
        context.arrows--
    } else {
        context.arrows++
        nodeInfo.include = true
        node = nodeInfo.node
        if (clusterComplete(context)) {
            
        } else {
            selectClusterStep(
                context,
                node,
                node.next[0]
            )
        }
    }
}

function selectClusterStepNext(context, nodeInfo) {
    var info, node
    if (nodeInfo.include) {
        context.arrows--
    } else {
        if (isArrowLoop(nodeInfo.node)) {
            context.arrows++
        }
        nodeInfo.include = true
        node = nodeInfo.node
        if (node.next.length == 2) {
            context.paths++
            selectClusterStep(
                context,
                node,
                node.next[1]
            )
        } else {
            if (node.type == "loopbegin") {
                context.loops[node.id] = true
                context.arrows++
            } else {
                if (node.type == "loopend") {
                    if (node.loopStart.id in context.loops) {
                        context.arrows--
                    } else {
                        info = getNodeInfo(
                            context,
                            node.loopStart
                        )
                        selectClusterStepNext(
                            context,
                            info
                        )
                    }
                }
            }
        }
        if ((clusterComplete(context)) && (!(node.type == "select"))) {
            
        } else {
            selectClusterStep(
                context,
                node,
                node.next[0]
            )
        }
    }
}

function selectInsert(socket) {
    var case1Id, case2Id, case3Id, edits, selectId
    edits = []
    case3Id = createItem(
        edits,
        {type:"case", one:socket.target}
    )
    case2Id = createItem(
        edits,
        {type:"case", one:socket.target, two:case3Id}
    )
    case1Id = createItem(
        edits,
        {type:"case", one:socket.target, two:case2Id}
    )
    selectId = createItem(
        edits,
        {type:"select", one:case1Id}
    )
    redirectUpperItems(
        edits,
        socket.links,
        selectId
    )
    return edits
}

function selectNode(node) {
    deselectAll()
    selectPrim(node.id)
    redrawCanvas()
}

function selectOneItem(itemId) {
    var node
    node = getNodeByItem(
        module.visuals,
        itemId
    )
    if (node) {
        deselectAll()
        selectPrim(node.id)
        redrawCanvas()
    }
}

function selectPath(path, head) {
    var newHead, selection
    selection = module.selection
    newHead = path.reduce(
        selectCluster,
        head
    )
    selection.head = newHead.id
}

function selectPrim(id) {
    var selection, visuals
    visuals = module.visuals
    selection = module.selection
    if (id in visuals.nodes.rows) {
        selection.prims[id] = "node"
        selection.head = id
    } else {
        if (id in visuals.edges.rows) {
            selection.prims[id] = "edge"
        } else {
            throw new Error("Can't select " + id)
        }
    }
}

function sendChars(self) {
    var token
    token = makeTokenFromChars(
        self,
        "operator"
    )
    self.next.sendToken(
        token
    )
}

function sendSToken(self, pos, chars) {
    var text, token
    text = Utils.arrayToString(
        chars
    )
    token = {
        text : text,
        pos : pos
    }
    self.next.onToken(
        token
    )
}

function sendToken(self, type, chars) {
    var text, token
    text = Utils.arrayToString(
        chars
    )
    token = {
        type : type,
        text : text
    }
    self.next.onToken(
        token
    )
    self.chars = []
    setTt(self, "idle")
    if ((type == "whitespace") || (type == "eol")) {
        
    } else {
        self.prev = token
    }
}

function sendTokens(tokens, flower) {
    var _ind11655 = 0;
    var _col11655 = tokens;
    var _len11655 = _col11655.length;
    while (true) {
        if (_ind11655 < _len11655) {
            
        } else {
            break;
        }
        var token = _col11655[_ind11655];
        if (token.type == "eol") {
            flower.eol()
        } else {
            flower.onToken(token)
        }
        _ind11655++;
    }
}

function sendWhitespace(self, ch) {
    var token
    token = new Token(
        "whitespace"
    )
    token.text = Utils.arrayToString(
        [ch]
    )
    self.next.sendToken(
        token
    )
}

function setBackground(data) {
    
}

function setCallback(name, fun) {
    module.callbacks[name] = fun
}

function setContent(id, content) {
    
}

function setFontFromIcon(render, item) {
    if (item.type == "header") {
        render.setDefaultFont(
            HeaderFont
        )
    } else {
        render.setDefaultFont(
            MainFont
        )
    }
}

function setFormat(ids, format) {
    
}

function setFreeItemSize(id, x, y, width, height) {
    
}

function setItemWidth(id, width) {
    
}

function setKeywordColor(token) {
    token.color = Theme.get("keyword")
}

function setNodeText(nodeId, text) {
    var edits, node
    if (module.readonly) {
        
    } else {
        addTrace(
            "setNodeText",
            [nodeId, text]
        )
        text = text || ""
        text = text.trim()
        edits = []
        node = getNode(nodeId)
        if (node.type == "header") {
            text = replaceAll(
                text,
                "\n",
                " "
            )
            updateDiagram(
                edits,
                {name: text}
            )
        } else {
            text = autoFormat(
                node.type,
                text
            )
            updateItem(
                edits,
                node.itemId,
                {text: text}
            )
        }
        editAndSave(edits)
    }
}

function setNodeText2(nodeId, text) {
    var edits
    if (module.readonly) {
        
    } else {
        addTrace(
            "setNodeText2",
            [nodeId, text]
        )
        text = text || ""
        text = text.trim()
        edits = []
        updateItem(
            edits,
            nodeId,
            {text2: text}
        )
        editAndSave(edits)
    }
}

function setNotNull(src, dst, name) {
    if (name in src) {
        dst[name] = src[name]
    }
}

function setProperties(props) {
    var change, edits
    change = {
        params : props.params || "",
        keywords : props.keywords || {}
    }
    edits = []
    updateDiagram(
        edits,
        change
    )
    deselectAll()
    editAndSave(edits)
}

function setReadonly(readonly) {
    module.readonly = readonly
}

function setSameHeight(visuals) {
    var addresses, branches
    forType(
        visuals,
        "select",
        setSameHeightForSelect
    )
    branches = getCreateList(
        visuals.byType,
        "branch"
    )
    setSameHeightForNodes(
        branches
    )
    addresses = getCreateList(
        visuals.byType,
        "address"
    )
    setSameHeightForNodes(
        addresses
    )
}

function setSameHeightForNodes(nodes) {
    var height, setHeight
    height = nodes.reduce(
        maxHeight,
        0
    )
    setHeight = function(node) {
        node.h = height
    }
    nodes.forEach(
        setHeight
    )
}

function setSameHeightForSelect(select) {
    setSameHeightForNodes(
        select.cases
    )
}

function setSameWidth(skewer) {
    var nodes, width
    width = 0
    var _ind3902 = 0;
    var _col3902 = skewer.nodes;
    var _len3902 = _col3902.length;
    while (true) {
        if (_ind3902 < _len3902) {
            
        } else {
            break;
        }
        var node = _col3902[_ind3902];
        width = Math.max(
            width,
            node.w
        )
        _ind3902++;
    }
    skewer.boundary = width
    nodes = skewer.nodes.filter(
        shouldAlignWidth
    )
    var _ind3894 = 0;
    var _col3894 = nodes;
    var _len3894 = _col3894.length;
    while (true) {
        if (_ind3894 < _len3894) {
            
        } else {
            break;
        }
        var node = _col3894[_ind3894];
        node.w = width
        _ind3894++;
    }
}

function setTop(lexer, top) {
    lexer.top = top
    lexer.escaping = false
    lexer.part = 1
    setTt(lexer, "idle")
}

function setTt(lexer, tt) {
    lexer.tt = tt
    lexer.part = 1
}

function setUserSettings(settings) {
    module.userSettings = Utils.copyObject(settings)
}

function shiftLowerOccurences(occ, newNeedle) {
    var delta, occs, oldLength
    oldLength = occ.end - occ.begin
    delta = newNeedle.length - oldLength
    occs = occ.item.occurences
    var _ind12602 = 0;
    var _col12602 = occs;
    var _len12602 = _col12602.length;
    while (true) {
        if (_ind12602 < _len12602) {
            
        } else {
            break;
        }
        var occ2 = _col12602[_ind12602];
        if (occ2.active) {
            if (occ2.ordinal > occ.ordinal) {
                occ2.begin += delta
                occ2.end += delta
            }
            updateOccurence(occ2)
        }
        _ind12602++;
    }
}

function shouldAlignWidth(node) {
    if (node.type in module.widthNodes) {
        return false
    } else {
        return true
    }
}

function shouldAutoformat(type) {
    if (((((((type == "branch") || (type == "address")) || (type == "params")) || (type == "header")) || (type == "end")) || (type == "input")) || (type == "pause")) {
        return false
    } else {
        return true
    }
}

function showAllBranchSockets(op) {
    var showInsert
    if (isSilhouette()) {
        showInsert = function(node) {
            showBranchSockets(node, op)
        }
        forType(
            module.visuals,
            "branch",
            showInsert
        )
    }
}

function showBlockInsertSockets(op, type) {
    var createEdgeSocket, edges, sockets
    edges = findForInsertion()
    createEdgeSocket = function(edge) {
        return createSocketFromEdge(edge, op, type)
    }
    sockets = edges.map(
        createEdgeSocket
    )
    sockets.forEach(
        copyEdgeLinks
    )
}

function showBranchSockets(node, op) {
    var lowest, socket, socket2, visuals
    visuals = module.visuals
    lowest = goDown(node)
    if (lowest.type == "end") {
        
    } else {
        socket = new Socket(
            node.x - node.w,
            node.y,
            op,
            "branch"
        )
        visuals.sockets.insert(
            socket
        )
        socket.node = node
        socket.left = true
        socket2 = new Socket(
            node.x + node.w,
            node.y,
            op,
            "branch"
        )
        visuals.sockets.insert(
            socket2
        )
        socket2.node = node
    }
}

function showCaseSockets(node, op) {
    showRightCaseSocket(
        node,
        op
    )
    if (node = firstCase(node.select)) {
        showFirstCaseSocket(
            node,
            op
        )
    }
}

function showFirstCaseSocket(node, op) {
    var socket, visuals
    visuals = module.visuals
    socket = new Socket(
        node.x - node.w,
        node.y,
        op,
        "first-case"
    )
    visuals.sockets.insert(
        socket
    )
    socket.node = node
}

function showInputBox(title, oldText, callback, x, y, validate, cmOptions) {
    var fun = module.callbacks.showInputBox
    if (fun) {
        fun(
        	title,
        	oldText,
        	callback,
        	x, y,
        	validate,
        	cmOptions
        )
    }
}

function showInsertionSockets(type) {
    var action, showInsert
    clearSockets()
    if (module.readonly) {
        
    } else {
        action = getActionForInsert(
            type
        )
        if (action) {
            deselectAll()
            if (type === "case") {
                showInsert = function(node) {
                    showCaseSockets(node, "insert")
                }
                forType(
                    module.visuals,
                    "case",
                    showInsert
                )
            } else {
                if (type === "branch") {
                    showAllBranchSockets(
                        "insert"
                    )
                } else {
                    if (type === "action") {
                        addParamsSocket()
                    }
                    showBlockInsertSockets(
                        "insert",
                        type
                    )
                }
            }
            redrawCanvas()
        }
    }
}

function showLianaSockets(prim) {
    var source
    clearSockets()
    if (module.readonly) {
        
    } else {
        source = findLianaSource(prim)
        if (source) {
            if (source.outer) {
                var _ind5908 = 0;
                var _col5908 = source.outer.outer;
                var _keys5908 = Object.keys(_col5908); 
                var _len5908 = _keys5908.length;
                while (true) {
                    if (_ind5908 < _len5908) {
                        
                    } else {
                        break;
                    }
                    var targetId = _keys5908[_ind5908]; var record = _col5908[targetId];
                    if (isLower(record, source)) {
                        createLianaSocket(record, source)
                    }
                    _ind5908++;
                }
                if (source.arrow) {
                    
                } else {
                    var _ind7704 = 0;
                    var _col7704 = source.outer.outerArrPads;
                    var _keys7704 = Object.keys(_col7704); 
                    var _len7704 = _keys7704.length;
                    while (true) {
                        if (_ind7704 < _len7704) {
                            
                        } else {
                            break;
                        }
                        var id = _keys7704[_ind7704]; var downEdge = _col7704[id];
                        createArrowSocket(downEdge, source)
                        _ind7704++;
                    }
                }
                var _ind5914 = 0;
                var _col5914 = source.outer.inner;
                var _keys5914 = Object.keys(_col5914); 
                var _len5914 = _keys5914.length;
                while (true) {
                    if (_ind5914 < _len5914) {
                        
                    } else {
                        break;
                    }
                    var targetId = _keys5914[_ind5914]; var record = _col5914[targetId];
                    if (canOuterToInner(record, source)) {
                        createLianaSocket(record, source)
                    }
                    _ind5914++;
                }
                if (((source.arrow) || (source.role == "up")) || (!(source.inner))) {
                    
                } else {
                    var _ind5920 = 0;
                    var _col5920 = source.inner.outer;
                    var _keys5920 = Object.keys(_col5920); 
                    var _len5920 = _keys5920.length;
                    while (true) {
                        if (_ind5920 < _len5920) {
                            
                        } else {
                            break;
                        }
                        var targetId = _keys5920[_ind5920]; var record = _col5920[targetId];
                        if ((source.role == "right-loop") || (!((source.vertical) || (isLower(record, source))))) {
                            
                        } else {
                            createLianaSocket(record, source)
                        }
                        _ind5920++;
                    }
                    if (isDegQuestion(source)) {
                        var _ind6022 = 0;
                        var _col6022 = source.inner.inner;
                        var _keys6022 = Object.keys(_col6022); 
                        var _len6022 = _keys6022.length;
                        while (true) {
                            if (_ind6022 < _len6022) {
                                
                            } else {
                                break;
                            }
                            var targetId = _keys6022[_ind6022]; var record = _col6022[targetId];
                            createLianaSocket(record, source)
                            _ind6022++;
                        }
                    }
                }
            } else {
                var _ind5920 = 0;
                var _col5920 = source.inner.outer;
                var _keys5920 = Object.keys(_col5920); 
                var _len5920 = _keys5920.length;
                while (true) {
                    if (_ind5920 < _len5920) {
                        
                    } else {
                        break;
                    }
                    var targetId = _keys5920[_ind5920]; var record = _col5920[targetId];
                    if ((source.role == "right-loop") || (!((source.vertical) || (isLower(record, source))))) {
                        
                    } else {
                        createLianaSocket(record, source)
                    }
                    _ind5920++;
                }
                if (isDegQuestion(source)) {
                    var _ind6022 = 0;
                    var _col6022 = source.inner.inner;
                    var _keys6022 = Object.keys(_col6022); 
                    var _len6022 = _keys6022.length;
                    while (true) {
                        if (_ind6022 < _len6022) {
                            
                        } else {
                            break;
                        }
                        var targetId = _keys6022[_ind6022]; var record = _col6022[targetId];
                        createLianaSocket(record, source)
                        _ind6022++;
                    }
                }
            }
        }
    }
}

function showPasteSockets(type) {
    var showPaste
    clearSockets()
    if ((type) && (!(module.readonly))) {
        deselectAll()
        if (type === "case") {
            showPaste = function(node) {
                showCaseSockets(node, "paste")
            }
            forType(
                module.visuals,
                "case",
                showPaste
            )
            redrawCanvas()
        } else {
            if (type === "branch") {
                showAllBranchSockets(
                    "paste"
                )
                redrawCanvas()
            } else {
                if (type === "block") {
                    showBlockInsertSockets(
                        "paste",
                        type
                    )
                    redrawCanvas()
                }
            }
        }
    }
}

function showRightCaseSocket(node, op) {
    var socket, visuals
    visuals = module.visuals
    socket = new Socket(
        node.x + node.w,
        node.y,
        op,
        "case"
    )
    visuals.sockets.insert(
        socket
    )
    socket.node = node
}

function simpleInsert(socket, type) {
    var edits, item, newId
    edits = []
    item = {
        type : type,
        text : "",
        one : socket.target
    }
    newId = createItem(
        edits,
        item
    )
    redirectUpperItems(
        edits,
        socket.links,
        newId
    )
    return edits
}

function skewerHead(skewer) {
    return skewer.nodes[0]
}

function skewerTail(skewer) {
    var last, nodes
    nodes = skewer.nodes
    last = nodes.length - 1
    return nodes[last]
}

function snapSize(textHeight) {
    var height, heightRaw, padding
    padding = Config.ICON_PADDING
    heightRaw = (textHeight / 2 + padding)
    height = Math.ceil(heightRaw / Config.SIZE_SNAP) *
      Config.SIZE_SNAP
    return height
}

function splitRight(visuals, rightEdge) {
    var finalTarget, jun, leftNode, leftPart, rightNode, role
    leftNode = rightEdge.head
    rightNode = rightEdge.tail
    finalTarget = rightEdge.finalTarget
    role = rightEdge.role
    removeEdge(
        visuals,
        rightEdge.id
    )
    jun = createJunction(
        visuals,
        finalTarget
    )
    leftPart = makeRightEdge(
        visuals,
        leftNode,
        jun,
        finalTarget
    )
    leftPart.role = role
    makeRightLoopEdge(
        visuals,
        jun,
        rightNode,
        finalTarget
    )
    return jun
}

function splitToken(self, token) {
    var i, text, text2, token1, token2, width
    i = token.text.length - 1
    while (true) {
        text = token.text.substring(
            0,
            i
        )
        width = self.render.measureTextWidth(
            text
        )
        if ((i > 1) && (width > self.maxLength)) {
            
        } else {
            break;
        }
        i--
    }
    text2 = token.text.substring(
        i,
        token.text.length
    )
    token1 = new Token(token.type)
    token1.text = text
    token1.color = token.color
    token2 = new Token(token.type)
    token2.text = text2
    token2.color = token.color
    placeTokenCore(
        self,
        token1,
        width
    )
    return token2
}

function splitVertical(visuals, node) {
    var finalTarget, jun, upEdge, upNode
    upEdge = node.up
    upNode = upEdge.head
    finalTarget = upEdge.finalTarget
    removeEdge(
        visuals,
        upEdge.id
    )
    jun = createJunction(
        visuals,
        finalTarget
    )
    makeDownEdge(
        visuals,
        upNode,
        jun,
        finalTarget
    )
    makeDownEdge(
        visuals,
        jun,
        node,
        finalTarget
    )
    return jun
}

function splitVerticalUp(visuals, upEdge) {
    var downNode, finalTarget, jun, upNode
    upNode = upEdge.head
    downNode = upEdge.tail
    finalTarget = upEdge.finalTarget
    removeEdge(
        visuals,
        upEdge.id
    )
    jun = createJunction(
        visuals,
        finalTarget
    )
    makeUpEdge(
        visuals,
        jun,
        downNode,
        finalTarget
    )
    makeUpEdge(
        visuals,
        upNode,
        jun,
        finalTarget
    )
    return jun
}

function standardCandy(item, render, color) {
    var candies, layer
    layer = "icon_candies"
    candies = buildDrnCandies(item)
    var _ind4696 = 0;
    var _col4696 = candies;
    var _len4696 = _col4696.length;
    while (true) {
        if (_ind4696 < _len4696) {
            
        } else {
            break;
        }
        var candy = _col4696[_ind4696];
        render.createJCandy(
            candy.x,
            candy.y,
            CandyColor,
            layer
        )
        _ind4696++;
    }
}

function startEdit() {
    var node, nodes
    nodes = getNodesFromSelection()
    if (nodes.length == 1) {
        node = nodes[0]
        if (canEditNodeText(node)) {
            startEditText(node.id)
        }
    }
}

function startEditText(nodeId) {
    var cmOptions, node, old, setTextProc, title, validate, x, y
    node = getNode(nodeId)
    if (node.type == "params") {
        addTrace(
            "startEditText - params",
            [nodeId, node.type]
        )
        changeDiagramProperties()
    } else {
        addTrace(
            "startEditText - normal",
            [nodeId, node.type]
        )
        old = node.text
        x = node.x - node.w - 5
        y = node.y - node.h - 29
        setTextProc = function(text) {
            setNodeText(nodeId, text)
        }
        cmOptions = undefined
        if (node.type == "header") {
            title = tr("MES_RENAME_DIAGRAM")
            validate = validateModuleName
        } else {
            if (isHuman()) {
                
            } else {
                cmOptions = {
                	mode: "javascript",
                	theme: "base16-dark"
                }
            }
            title = tr("MES_CHANGE_ITEM_TEXT") +
             ": " + node.itemId
            validate = validateItemText
        }
        showInputBox(
            title,
            old,
            setTextProc,
            x,
            y,
            validate,
            cmOptions
        )
    }
}

function startEditTextAt(id, x, y) {
    var middle, node
    node = getNode(id)
    middle = node.y - node.h +
     node.a * 2
    if ((node.type == "input") && (!(y > middle))) {
        startEditUpperText(id)
    } else {
        startEditText(id)
    }
}

function startEditUpperText(nodeId) {
    var node, old, setTextProc, title, validate, x, y
    node = getNode(nodeId)
    old = node.text2 || ""
    x = node.x + node.w
    y = node.y - node.h
    setTextProc = function(text) {
        setNodeText2(nodeId, text)
    }
    title = tr("MES_CHANGE_ITEM_UPPER") +
     ": " + node.itemId
    validate = validateItemText
    showInputBox(
        title,
        old,
        setTextProc,
        x,
        y,
        validate
    )
}

function startIndented(output, depth) {
    var i
    printToken(
        output,
        createEol()
    )
    output.current = 0
    i = 0;
    while (true) {
        if (i < depth * TabSize) {
            
        } else {
            break;
        }
        printToken(
            output,
            createSpace()
        )
        i++;
    }
}

function startStatement(block) {
    var old
    old = block.statement
    if (old.items.length == 0) {
        
    } else {
        block.statements.push(old)
    }
    block.statement = createStatement()
    block.prev = "operator"
}

function startToken(self, type, c) {
    self.token = new Token(
        type
    )
    self.chars = [c]
}

function startVisualDrag(itemId) {
    
}

function subtract(from, what) {
    var result
    result = {}
    var _ind9051 = 0;
    var _col9051 = from;
    var _keys9051 = Object.keys(_col9051); 
    var _len9051 = _keys9051.length;
    while (true) {
        if (_ind9051 < _len9051) {
            
        } else {
            break;
        }
        var key = _keys9051[_ind9051]; var value = _col9051[key];
        if (key in what) {
            
        } else {
            result[key] = value
        }
        _ind9051++;
    }
    return result
}

function swapYesNo(node) {
    var change, edits
    edits = []
    change = {
        flag1 : node.flag1 ? 0 : 1
    }
    updateItem(
        edits,
        node.itemId,
        change
    )
    return edits
}

function tailChars(text, n) {
    var first
    if (text.length > n) {
        first = text.length - n
        return text.substring(first)
    } else {
        return text
    }
}

function takeOldValues(fields, old) {
    var undo
    undo = {}
    var _ind5121 = 0;
    var _col5121 = fields;
    var _keys5121 = Object.keys(_col5121); 
    var _len5121 = _keys5121.length;
    while (true) {
        if (_ind5121 < _len5121) {
            
        } else {
            break;
        }
        var name = _keys5121[_ind5121]; var _ = _col5121[name];
        var oldValue = old[name]
        if ((oldValue === null) || (oldValue === undefined)) {
            oldValue = ""
        }
        undo[name] = oldValue
        _ind5121++;
    }
    return undo
}

function tmpRenderSource(render, item, text, isSource) {
    var format, left, prims, texId, top
    format = {}
    format.fillColor = "#000000"
    format.lineColor = "#808080"
    format.lineThickness = 1
    format.lineStyle = "solid"
    format.shadow = null
    format.secondaryColor = "green"
    render.setDefaultFont(
        "14px Cousine"
    )
    texId = makeCustomTexture(
        render,
        item.x,
        item.y,
        item.w,
        item.h
    )
    render.drawShape(
        texId,
        "rectangle",
        item.x,
        item.y,
        [item.w, item.h],
        format
    )
    if (isSource) {
        prims = flowSourceCode(render, text)
    } else {
        prims = flowText(render, text, 200)
    }
    console.log(prims.width, prims.height)
    left = item.x - item.w
    top = item.y - item.h
    var _ind2406 = 0;
    var _col2406 = prims.tokens;
    var _len2406 = _col2406.length;
    while (true) {
        if (_ind2406 < _len2406) {
            
        } else {
            break;
        }
        var prim = _col2406[_ind2406];
        render.drawText(
            texId,
            prim.text,
            prim.x + left,
            prim.y + top,
            prim.color
        )
        _ind2406++;
    }
}

function toBText() {
    var branch, keyText, lines, lines0, params, storage
    storage = module.storage
    lines = []
    var _ind10932 = 0;
    var _col10932 = storage.items;
    var _keys10932 = Object.keys(_col10932); 
    var _len10932 = _keys10932.length;
    while (true) {
        if (_ind10932 < _len10932) {
            
        } else {
            break;
        }
        var id = _keys10932[_ind10932]; var item = _col10932[id];
        if ((item.type == "branch") && ((item.branchId === 0) || (item.branchId === 1))) {
            branch = item
        } else {
            itemToBText(
                lines,
                item
            )
        }
        _ind10932++;
    }
    lines0 = []
    addBText(
        lines0,
        "drakon",
        "header",
        storage.name,
        Config.DIAGRAM_VERSION
    )
    keyText = createKeywordsText(storage)
    params = keyText + "\n\n" + storage.params
    params = params.trim()
    if (params) {
        addBText(
            lines0,
            "params",
            "params",
            params
        )
    }
    itemToBText(
        lines0,
        branch
    )
    return lines0.concat(lines).join("\n")
}

function toPrimitive() {
    var branches, ditch, edits, endId, first, firstId, i, rest, visuals
    edits = []
    visuals = module.visuals
    branches = visuals.branches
    first = {}
    rest = {}
    firstId = branches[0].node.itemId
    scanBranchItems(
        branches[0].node,
        first
    )
    i = 1;
    while (true) {
        if (i < branches.length) {
            
        } else {
            break;
        }
        scanBranchItems(
            branches[i].node,
            rest
        )
        i++;
    }
    if (visuals.end) {
        endId = visuals.end.itemId
        delete rest[endId]
    } else {
        endId = createItem(
            edits,
            {type: "end"}
        )
    }
    rest[firstId] = true
    redirectBranch(
        first,
        rest,
        endId,
        edits
    )
    delete rest[firstId]
    ditch = function(itemId) {
        deleteItem(edits, itemId)
    }
    Object.keys(rest).forEach(
        ditch
    )
    updateItem(
        edits,
        branches[0].node.itemId,
        {text:"", branchId:0}
    )
    return edits
}

function toSilhouette() {
    var b1, b2, b3, branch2, branch3, edits, end, fb, visuals
    visuals = module.visuals
    end = visuals.end
    edits = []
    b1 = branchLabel() + "1"
    b2 = branchLabel() + "2"
    b3 = "Exit"
    fb = firstBranchNode(visuals)
    branch3 = createItem(
        edits,
        {type:"branch", text:b3, one:end.itemId, branchId:3}
    )
    branch2 = createItem(
        edits,
        {type:"branch", text:b2, one:branch3, branchId:2}
    )
    updateItem(
        edits,
        fb.itemId,
        {text: b1, branchId:1}
    )
    redirectUpperItems(
        edits,
        end.up.links,
        branch2
    )
    return edits
}

function toTokens(machines, text) {
    var c, category, i, length, machine
    length = text.length
    i = 0;
    while (true) {
        if (i < length) {
            
        } else {
            break;
        }
        c = text.charCodeAt(i)
        if (c == 13) {
            
        } else {
            category = classifyChar(c)
            machine = machines.top()
            callMethod(
                machine,
                category,
                [c]
            )
        }
        i++;
    }
    machine = machines.top()
    machine.finish()
}

function toTokens2(machines, text) {
    var c, category, i, length, machine
    length = text.length
    i = 0;
    while (true) {
        if (i < length) {
            
        } else {
            break;
        }
        c = text.charCodeAt(i)
        if (c == 13) {
            
        } else {
            if (c == 10) {
                machine.onChar("eol")
            } else {
                category = classifyChar(c)
                machine = machines.top()
                machine.onChar(
                    "char",
                    category,
                    c,
                    i
                )
            }
        }
        i++;
    }
    machine = machines.top()
    machine.onChar("finish")
}

function toggleSilhouette() {
    var edits
    if (isSilhouette()) {
        edits = toPrimitive()
    } else {
        edits = toSilhouette()
    }
    brutalChange(edits)
}

function toggleTreeType() {
    
}

function traceLevel(visuals, node) {
    var level
    level = createLevel(
        visuals
    )
    while (true) {
        linkNodeToLevel(
            level,
            node
        )
        if (node.right) {
            
        } else {
            break;
        }
        node = getRight(node)
    }
}

function traceLoop(visited, node, loopEnd) {
    if (node.id in visited) {
        
    } else {
        visited[node.id] = true
        if (node.loopEnd == loopEnd) {
            
        } else {
            node.loops[loopEnd.id] = true
            var _ind6249 = 0;
            var _col6249 = node.prev;
            var _len6249 = _col6249.length;
            while (true) {
                if (_ind6249 < _len6249) {
                    
                } else {
                    break;
                }
                var prev = _col6249[_ind6249];
                traceLoop(
                    visited,
                    prev,
                    loopEnd
                )
                _ind6249++;
            }
        }
    }
}

function traceLoops() {
    var trace, visuals
    visuals = module.visuals
    trace = function(node) {
        traceLoop({}, node, node)
    }
    forType(
        visuals,
        "loopend",
        trace
    )
    forType(
        visuals,
        "select",
        putLoopsOnCases
    )
}

function traceSkewer(visuals, node) {
    var beneath, skewer
    skewer = createSkewer(
        visuals
    )
    if (node.type == "header") {
        skewer.main = true
    } else {
        beneath = getDown(node)
        if (beneath.type == "branch") {
            skewer.main = true
        }
    }
    while (true) {
        linkNodeToSkewer(
            skewer,
            node
        )
        if (node.down) {
            
        } else {
            break;
        }
        node = getDown(node)
    }
}

function translateLabel(prop, textId) {
    if (module.userSettings[prop]) {
        return module.userSettings[prop]
    } else {
        return translate(textId)
    }
}

function traverseItem(items, prev, itemId, visited) {
    var item, node
    if ((itemId) && (!(itemId in visited))) {
        visited[itemId] = false
        node = getNodeByItem(
            module.visuals,
            itemId
        )
        if ((node.type == "branch") || (isBackLink(prev, node))) {
            
        } else {
            item = items[itemId]
            traverseItem(
                items,
                node,
                item.one,
                visited
            )
            traverseItem(
                items,
                node,
                item.two,
                visited
            )
        }
    }
}

function traverseItemToDelete(context, prev, itemId) {
    var item, node, visited
    visited = context.visited
    if ((itemId) && (!(itemId in visited))) {
        node = getNodeByItem(
            module.visuals,
            itemId
        )
        if (node.type == "branch") {
            
        } else {
            if (isBackLink(prev, node)) {
                if (hasUntouchedArrows(visited, node)) {
                    
                } else {
                    visited[itemId] = true
                    context.deleteList.push(itemId)
                    unlinkArrow(
                        node,
                        visited,
                        context.edits
                    )
                }
            } else {
                if (hasUntouchedUpstream(visited, node)) {
                    
                } else {
                    visited[itemId] = true
                    context.deleteList.push(itemId)
                    item = context.items[itemId]
                    traverseItemToDelete(
                        context,
                        node,
                        item.one
                    )
                    traverseItemToDelete(
                        context,
                        node,
                        item.two
                    )
                }
            }
        }
    }
}

function turn180up(visuals, node1, node2) {
    var bottom, left, top
    top = getRight(node2)
    bottom = createJunction(
        visuals,
        node2
    )
    makeUpEdge(
        visuals,
        top,
        bottom,
        node2
    )
    left = createJunction(
        visuals,
        node2
    )
    makeDownEdge(
        visuals,
        node1,
        left,
        node2
    )
    makeRightLoopEdge(
        visuals,
        left,
        bottom,
        node2
    )
    createTempEdge(
        visuals,
        node1,
        left
    )
}

function turnDown(visuals, node1, node2) {
    var finalTarget, jun
    finalTarget = node2
    jun = createLeftDown(
        visuals,
        finalTarget
    )
    makeRightEdge(
        visuals,
        node1,
        jun,
        finalTarget
    )
    return jun
}

function twoTokens(token, secondStart) {
    var text1, text2, token1, token2
    text1 = token.text.substring(
        0,
        secondStart
    )
    text2 = token.text.substring(
        secondStart,
        token.text.length
    )
    token1 = new Token(token.type)
    token1.text = text1
    token1.color = token.color
    token2 = new Token(token.type)
    token2.text = text2
    token2.color = token.color
    return {
        first : token1,
        second : token2
    }
}

function unlinkArrow(arrowNode, visited, edits) {
    var node
    node = arrowNode
    while (true) {
        node = node.next[0]
        if (visited[node.itemId]) {
            
        } else {
            break;
        }
    }
    redirectUpperItems(
        edits,
        arrowNode.up.links,
        node.itemId
    )
}

function unselectEdges() {
    var ids, node, selection
    selection = module.selection
    ids = Object.keys(selection.prims)
    var _ind9770 = 0;
    var _col9770 = ids;
    var _len9770 = _col9770.length;
    while (true) {
        if (_ind9770 < _len9770) {
            
        } else {
            break;
        }
        var id = _col9770[_ind9770];
        if (selection.prims[id] == "edge") {
            delete selection.prims[id]
        } else {
            node = getNode(id)
            if (canSelectNode(node)) {
                
            } else {
                delete selection.prims[id]
            }
        }
        _ind9770++;
    }
    if (Object.keys(selection.prims).length == 0) {
        selection.head = null
    }
}

function updateDiagram(edits, fields) {
    var edit
    edit = new Edit(
        "update",
        "diagrams",
        null,
        fields
    )
    edits.push(
        edit
    )
}

function updateItem(edits, id, fields) {
    var edit
    edit = new Edit(
        "update",
        "items",
        id,
        fields
    )
    edits.push(
        edit
    )
}

function updateOccurence(occurence) {
    var N, after, before, match, text
    N = 30
    text = occurence.item.text
    before = text.substring(
        0,
        occurence.begin
    )
    match = text.substring(
        occurence.begin,
        occurence.end
    )
    after = text.substring(
        occurence.end
    )
    occurence.before = oneLine(tailChars(before, N))
    occurence.match = oneLine(match)
    occurence.after = oneLine(after.substring(0, N))
}

function updateSearchOutput() {
    var current, occ, search
    search = module.search
    search.output.total = search.occurences.filter(
    	isActive).length
    if (search.output.total == 0) {
        search.output.current = -1
        search.output.canNext = false
        search.output.canPrev = false
        search.output.canReplace = false
        search.output.canReplaceAll = false
        search.output.before = ""
        search.output.match = ""
        search.output.after = ""
        search.output.id = undefined
    } else {
        current = search.output.current
        search.output.canNext = true
        search.output.canPrev = true
        search.output.canReplaceAll = true
        if (getPrevOccurence() == -1) {
            search.output.canPrev = false
        }
        if (getNextOccurence() == -1) {
            search.output.canNext = false
        }
        if (current == -1) {
            search.output.canReplace = false
            search.output.before = ""
            search.output.match = ""
            search.output.after = ""
        } else {
            search.output.canReplace = true
            occ = search.occurences[current]
            search.output.before = occ.before
            search.output.match = occ.match
            search.output.after = occ.after
            search.output.id = occ.id
        }
        if (self.readonly) {
            search.output.canReplace = false
            search.output.canReplaceAll = false
        }
    }
}

function validateItemText(text) {
    var error
    error = checkInputText(text)
    if (error) {
        return translate(error)
    } else {
        return null
    }
}

function validateModuleName(name) {
    var error
    error = checkInputText(name)
    if (error) {
        return translate(error)
    } else {
        error = Utils.validateModuleName(
            name,
            module.language
        )
        if (error) {
            return translate(error)
        } else {
            return null
        }
    }
}

function verticalCandy(edge, render) {
    var bottom, h, head, headX, headY, tail, tailY, top, x, y
    head = edge.head
    tail = edge.tail
    headX = getX(head)
    headY = getY(head)
    tailY = getY(tail)
    x = headX
    y = headY
    h = tailY - headY
    top = y + head.h
    bottom = tailY - tail.h
    render.createVCandy(
        x,
        y,
        h,
        false,
        top,
        bottom,
        "line_candies"
    )
}

function visualDrag(dx, dy, visibleBox) {
    
}

function withinSameLoop(src, target) {
    var node, targetNode
    targetNode = target.finalTarget
    var _ind8142 = 0;
    var _col8142 = src.links;
    var _len8142 = _col8142.length;
    while (true) {
        if (_ind8142 < _len8142) {
            
        } else {
            return true
        }
        var link = _col8142[_ind8142];
        node = getNodeByItem(
            module.visuals,
            link.source
        )
        if (withinSameLoopCore(node, targetNode, 0)) {
            
        } else {
            return false
        }
        _ind8142++;
    }
}

function withinSameLoopCore(node, target, depth) {
    var _sw81210000_ = 0;
    _sw81210000_ = node.type;
    if (_sw81210000_ === "loopbegin") {
        depth--
    } else {
        if (_sw81210000_ === "loopend") {
            depth++
        }
    }
    if (depth < 0) {
        return false
    } else {
        if (node == target) {
            return true
        } else {
            var _ind8138 = 0;
            var _col8138 = node.prev;
            var _len8138 = _col8138.length;
            while (true) {
                if (_ind8138 < _len8138) {
                    
                } else {
                    return true
                }
                var prev = _col8138[_ind8138];
                if (withinSameLoopCore(prev, target, depth)) {
                    
                } else {
                    return false
                }
                _ind8138++;
            }
        }
    }
}

function yes() {
    return translateLabel("yes", "DIA_YES")
}

function yesWidth(render) {
    return render.measureTextWidth(yes())
}

function TokenBuilder() {
  var _self = this;
  _self.type_name = "TokenBuilder";
  _self.state = "Empty";
  _self.addChar = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Empty") {
      return TokenBuilder_Empty_addChar(_self, msg);
    }
    else if (_state_ == "Building") {
      return TokenBuilder_Building_addChar(_self, msg);
    }
    return null;
  };
  _self.endToken = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Building") {
      return TokenBuilder_Building_endToken(_self, msg);
    }
    return null;
  };
  _self.eol = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Empty") {
      return TokenBuilder_Empty_eol(_self, msg);
    }
    else if (_state_ == "Building") {
      return TokenBuilder_Building_eol(_self, msg);
    }
    return null;
  };
  _self.finish = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Building") {
      return TokenBuilder_Building_finish(_self, msg);
    }
    return null;
  };
  _self.identifier = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Empty") {
      return TokenBuilder_Empty_identifier(_self, msg);
    }
    else if (_state_ == "Building") {
      return TokenBuilder_Building_identifier(_self, msg);
    }
    return null;
  };
  _self.number = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Empty") {
      return TokenBuilder_Empty_number(_self, msg);
    }
    else if (_state_ == "Building") {
      return TokenBuilder_Building_number(_self, msg);
    }
    return null;
  };
  _self.sendToken = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Empty") {
      return TokenBuilder_Empty_sendToken(_self, msg);
    }
    else if (_state_ == "Building") {
      return TokenBuilder_Building_sendToken(_self, msg);
    }
    return null;
  };
}

function OperatorBuilder() {
  var _self = this;
  _self.type_name = "OperatorBuilder";
  _self.state = "Idle";
  _self.operator = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Idle") {
      return OperatorBuilder_Idle_operator(_self, msg);
    }
    else if (_state_ == "One") {
      return OperatorBuilder_One_operator(_self, msg);
    }
    else if (_state_ == "Two") {
      return OperatorBuilder_Two_operator(_self, msg);
    }
    return null;
  };
}

function DoubleQuoter() {
  var _self = this;
  _self.type_name = "DoubleQuoter";
  _self.state = "Created";
  _self.alpha = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return DoubleQuoter_Created_default(_self, msg);
    }
    else if (_state_ == "Normal") {
      return DoubleQuoter_Normal_alpha(_self, msg);
    }
    else if (_state_ == "Escaping") {
      return DoubleQuoter_Escaping_default(_self, msg);
    }
    return null;
  };
  _self.digit = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return DoubleQuoter_Created_default(_self, msg);
    }
    else if (_state_ == "Normal") {
      return DoubleQuoter_Normal_digit(_self, msg);
    }
    else if (_state_ == "Escaping") {
      return DoubleQuoter_Escaping_default(_self, msg);
    }
    return null;
  };
  _self.operator = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return DoubleQuoter_Created_operator(_self, msg);
    }
    else if (_state_ == "Normal") {
      return DoubleQuoter_Normal_operator(_self, msg);
    }
    else if (_state_ == "Escaping") {
      return DoubleQuoter_Escaping_operator(_self, msg);
    }
    return null;
  };
  _self.whitespace = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return DoubleQuoter_Created_default(_self, msg);
    }
    else if (_state_ == "Normal") {
      return DoubleQuoter_Normal_whitespace(_self, msg);
    }
    else if (_state_ == "Escaping") {
      return DoubleQuoter_Escaping_default(_self, msg);
    }
    return null;
  };
}

function SingleQuoter() {
  var _self = this;
  _self.type_name = "SingleQuoter";
  _self.state = "Created";
  _self.alpha = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return SingleQuoter_Created_default(_self, msg);
    }
    else if (_state_ == "Normal") {
      return SingleQuoter_Normal_alpha(_self, msg);
    }
    else if (_state_ == "Escaping") {
      return SingleQuoter_Escaping_default(_self, msg);
    }
    return null;
  };
  _self.digit = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return SingleQuoter_Created_default(_self, msg);
    }
    else if (_state_ == "Normal") {
      return SingleQuoter_Normal_digit(_self, msg);
    }
    else if (_state_ == "Escaping") {
      return SingleQuoter_Escaping_default(_self, msg);
    }
    return null;
  };
  _self.operator = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return SingleQuoter_Created_operator(_self, msg);
    }
    else if (_state_ == "Normal") {
      return SingleQuoter_Normal_operator(_self, msg);
    }
    else if (_state_ == "Escaping") {
      return SingleQuoter_Escaping_operator(_self, msg);
    }
    return null;
  };
  _self.whitespace = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return SingleQuoter_Created_default(_self, msg);
    }
    else if (_state_ == "Normal") {
      return SingleQuoter_Normal_whitespace(_self, msg);
    }
    else if (_state_ == "Escaping") {
      return SingleQuoter_Escaping_default(_self, msg);
    }
    return null;
  };
}

function SourceFlower() {
  var _self = this;
  _self.type_name = "SourceFlower";
  _self.state = "Created";
  _self.eol = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return SourceFlower_Created_default(_self, msg);
    }
    else if (_state_ == "Normal") {
      return SourceFlower_Normal_eol(_self, msg);
    }
    return null;
  };
  _self.init = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return SourceFlower_Created_init(_self, msg);
    }
    return null;
  };
  _self.onToken = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Created") {
      return SourceFlower_Created_default(_self, msg);
    }
    else if (_state_ == "Normal") {
      return SourceFlower_Normal_onToken(_self, msg);
    }
    return null;
  };
}

function TextLexer() {
  var _self = this;
  _self.type_name = "TextLexer";
  _self.state = "Idle";
  _self.alpha = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Idle") {
      return TextLexer_Idle_alpha(_self, msg);
    }
    else if (_state_ == "Identifier") {
      return TextLexer_Identifier_default(_self, msg);
    }
    return null;
  };
  _self.digit = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Idle") {
      return TextLexer_Idle_digit(_self, msg);
    }
    else if (_state_ == "Identifier") {
      return TextLexer_Identifier_default(_self, msg);
    }
    return null;
  };
  _self.operator = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Idle") {
      return TextLexer_Idle_operator(_self, msg);
    }
    else if (_state_ == "Identifier") {
      return TextLexer_Identifier_default(_self, msg);
    }
    return null;
  };
  _self.whitespace = function(msg) {
    var _state_ = _self.state;
    if (_state_ == "Idle") {
      return TextLexer_Idle_whitespace(_self, msg);
    }
    else if (_state_ == "Identifier") {
      return TextLexer_Identifier_whitespace(_self, msg);
    }
    return null;
  };
}

function OuterCrawler() {
  var _self = this;
  _self.type_name = "OuterCrawler";
  _self.state = "down";
  _self.onEdge = function(edge) {
    var _state_ = _self.state;
    if (_state_ == "down") {
      return OuterCrawler_down_onEdge(_self, edge);
    }
    else if (_state_ == "rightLoop") {
      return OuterCrawler_rightLoop_onEdge(_self, edge);
    }
    else if (_state_ == "downLoop") {
      return OuterCrawler_downLoop_onEdge(_self, edge);
    }
    else if (_state_ == "leftLoop") {
      return OuterCrawler_leftLoop_onEdge(_self, edge);
    }
    else if (_state_ == "right") {
      return OuterCrawler_right_onEdge(_self, edge);
    }
    else if (_state_ == "left") {
      return OuterCrawler_left_onEdge(_self, edge);
    }
    return null;
  };
}

function InnerCrawler() {
  var _self = this;
  _self.type_name = "InnerCrawler";
  _self.state = "down";
  _self.onEdge = function(edge) {
    var _state_ = _self.state;
    if (_state_ == "down") {
      return InnerCrawler_down_onEdge(_self, edge);
    }
    else if (_state_ == "left") {
      return InnerCrawler_left_onEdge(_self, edge);
    }
    else if (_state_ == "right") {
      return InnerCrawler_right_onEdge(_self, edge);
    }
    return null;
  };
}

function OperBuilder() {
  var _self = this;
  _self.type_name = "OperBuilder";
  _self.state = "Idle";
  _self.eol = function(token) {
    var _state_ = _self.state;
    if (_state_ == "Idle") {
      return OperBuilder_Idle_eol(_self, token);
    }
    else if (_state_ == "One") {
      return OperBuilder_One_eol(_self, token);
    }
    else if (_state_ == "Two") {
      return OperBuilder_Two_eol(_self, token);
    }
    return null;
  };
  _self.onToken = function(token) {
    var _state_ = _self.state;
    if (_state_ == "Idle") {
      return OperBuilder_Idle_onToken(_self, token);
    }
    else if (_state_ == "One") {
      return OperBuilder_One_onToken(_self, token);
    }
    else if (_state_ == "Two") {
      return OperBuilder_Two_onToken(_self, token);
    }
    return null;
  };
}


function FakePersistence() {
	var module = this;
	
	module.add = function(item) {}
	module.remove = function(id) {}
	module.update = function(item) {}
	module.updateDiagram = function(name) {}
	module.persist = function() {}
}



// Public methods

this.buildTextBoxes = buildTextBoxes
this.setReadonly = setReadonly
this.findVisualItem = findVisualItem;
this.startVisualDrag = startVisualDrag;
this.visualDrag = visualDrag;
this.endVisualDrag = endVisualDrag;

this.autoSizeIcons = autoSizeIcons;

this.hit = hit;
this.setCallback = setCallback;

this.measureDiagram = measureDiagram;
this.getIconCount = getIconCount;


this.clearUndo = clearUndo;
this.drawToOtherRender = drawToOtherRender;
this.drawToOtherRender = drawToOtherRender;
this.mouseClick = mouseClick;
this.buildBlockMenu = buildBlockMenu;
this.deselect = deselect;
this.blockSelect = blockSelect;
this.beginBlockSelect = beginBlockSelect;
this.isSelected = isSelected;


this.redraw = redraw;

this.setItemWidth = setItemWidth;
this.buildMenuAt = buildMenuAt;
this.insertFreeItem = insertFreeItem
this.setFreeItemSize = setFreeItemSize
this.moveHandle = moveHandle
this.saveHandlePos = saveHandlePos
this.setBackground = setBackground
this.setFormat = setFormat
this.getFormat = getFormat
this.getItemRect = getItemRect
this.getFonts = getFonts
this.getFont = getFont
this.clearFormat = clearFormat
this.getSelection = getSelection
this.selectAll = selectAll
this.findDraggable = findDraggable
this.setContent = setContent
this.setUserSettings = setUserSettings



this.getItem = getItem
this.selectOneItem = selectOneItem
this.toggleTreeType = toggleTreeType
this.getFontsForItems = getFontsForItems

this.loadDiagram = loadDiagram
this.createDiagram = createDiagram

editMethod("addParameters", addParameters)
editMethod("deleteSelection", deleteSelection)
editMethod("performRedo", performRedo)
editMethod("performUndo", performUndo)
editMethod("toggleSilhouette", toggleSilhouette)
editMethod("cut", cut)
editMethod("paste", paste)
editMethod("showInsertionSockets", showInsertionSockets)
editMethod("clickSocket", clickSocket)
editMethod("findSocket", findSocket)
editMethod("replace", replace)
editMethod("findReplaceAll", findReplaceAll)
editMethod("setProperties", setProperties)



roMethod("copy", copy)
roMethod("hideSockets", hideSockets)
roMethod("fireSocket", fireSocket)
roMethod("darkenSocket", darkenSocket)
roMethod("diagramToJson", diagramToJson)
roMethod("getDiagramAsItems", getDiagramAsItems)
roMethod("canEditText", canEditText)
roMethod("startEditText", startEditText)
roMethod("startEditTextAt", startEditTextAt)
roMethod("toBText", toBText)
roMethod("startEdit", startEdit)
roMethod("arrowUp", arrowUp)
roMethod("arrowDown", arrowDown)
roMethod("arrowLeft", arrowLeft)
roMethod("arrowRight", arrowRight)
roMethod("getSearchState", getSearchState)

roMethod("getSearchState", getSearchState)
roMethod("searchNext", searchNext)
roMethod("searchPrev", searchPrev)
roMethod("changeSearch", changeSearch)

init()

}
