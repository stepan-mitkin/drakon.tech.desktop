function ViewWidget(
	window,
	document, 
	canvas,
	over
) {
	var self = this;
	var gPassive = false

	var gWidth = 0
	var gHeight = 0

	var gTouch = null;
	var gOverTouch = null;

	var gOldBlock = null;
	var gDebugMode = false;
	var gRetina = 1;

	var gOrigin = new Point(0, 0);
	var gLeft = 0;
	var gTop = 0
	var gZoom = 1.0;
	var gPrevZoom = gZoom;
	var gTempOrigin = new Point(0, 0);

	var gMouse = new Point(0, 0);

	var gPayload = null;

	var gZooms = [
		0.25, 1/3, 0.4, 0.5, 0.6, 2/3, 0.7, 0.8, 0.9, 1,
		1.2, 1.25, 1.5, 1.75, 2
	];

	var BACK_MARGIN = 1000;
	var INNER_MARGIN = 0;
	if (gDebugMode) {
		INNER_MARGIN = 200;
	}
	
	var PATCH_COUNT = 1;



	create();

// Autogenerated with DRAKON Editor 1.33


function Point(x, y) {
    this.x = x;
    this.y = y;
}

function Size(w, h) {
    this.w = w;
    this.h = h;
}

function Timers() {
    this.timers = {};
    this.add = timersAdd;
    this.clear = timersClear;
    this.remove = timersRemove;
}

function adjustOriginToZoom(at, newZoom) {
    var sx = at.x;
    var sy = at.y;
    var dx = sx / gZoom - getOriginX();
    var dy = sy / gZoom - getOriginY();
    var ox = Math.round(sx / newZoom - dx);
    var oy = Math.round(sy / newZoom - dy);
    return new Point(ox, oy);
}

function bind(name, callback) {
    canvas.addEventListener(name, callback, getListenOptions())
}

function bindMouseWheel(element, callback) {
    // IE9, Chrome, Safari, Opera
    element.addEventListener("mousewheel", callback, getListenOptions());
    // Firefox
    element.addEventListener("DOMMouseScroll", callback, getListenOptions());
}

function buildWheelMessage(evt) {
    var delta = calculateWheelDelta(evt);
    preventDefault(evt);
    var message = {
    	delta: delta,
    	shiftKey: evt.shiftKey,
    	ctrlKey: evt.ctrlKey || evt.metaKey
    };
    return message;
}

function calculateWheelDelta(e) {
    var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
    return delta;
}

function clientToDiagram(cx, cy) {
    var mx = Math.round((cx - gLeft) / gZoom - getOriginX())
    var my = Math.round((cy - gTop) / gZoom - getOriginY())
    return {
    	x: mx,
    	y: my,
    	cx: cx,
    	cy: cy
    }
}

function colorFromCoord(row, column) {
    var r = 255;
    var g = Math.floor((row % 500) / 500.0 * 255);
    var b = Math.floor((column % 500) / 500.0 * 255);
    var rh = toHexByte(r);
    var gh = toHexByte(g);
    var bh = toHexByte(b);
    return "#" + rh + gh + bh;
}

function create() {
    gRetina = HtmlUtils.getRetinaFactor()
    gTouch = new Multitouch(self);
    //detectPassive()
    bind("mousedown", mouseDown);
    bind("mousemove", mouseMove);
    bind("mouseup", mouseUp);
    bind("touchstart", touchstart);
    bind("touchmove", touchmove);
    bind("touchend", touchend);
    bind("touchcancel", touchcancel);
    bindMouseWheel(canvas, mouseWheel);
    bindMouseWheel(over, mouseWheel);
    canvas.oncontextmenu = function() { return false; }
    canvas.onmouseleave = mouseLeave
}

function detectPassive() {
    var supportsPassive = false;
    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function() {
          supportsPassive = true;
        }
      });
      window.addEventListener("testPassive", null, opts);
      window.removeEventListener("testPassive", null, opts);
    } catch (e) {}
    gPassive = supportsPassive
}

function diagramToClient(x, y) {
    var tx = x;
    var ty = y;
    var bx = tx + INNER_MARGIN;
    var by = ty + INNER_MARGIN;
    var mx = Math.round(gZoom * (bx + getOriginX()));
    var my = Math.round(gZoom * (by + getOriginY()));
    return new Utils.Point(mx, my);
}

function drawPatch() {
    var background = gPayload.getBackground()
    background = background || Theme.get("back")
    if (canvas.style.background == background) {
        
    } else {
        canvas.style.background = background
    }
    var origin = gOrigin;
    var ctx = canvas.getContext("2d");
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    var scale = gZoom * gRetina
    ctx.scale(scale, scale);
    ctx.translate(
    	origin.x,
    	origin.y
    );
    gPayload.setTransform(origin.x, origin.y, gZoom, gRetina)
    gPayload.draw(ctx)
}

function finishScroll() {
    
}

function finishZoom() {
    gPayload.setZoom(gZoom, gRetina);
    gPayload.redrawCache();
    rebuild();
}

function getListenOptions() {
    if (gPassive) {
        return {
        	capture: true,
        	passive: true
        }
    } else {
        return true
    }
}

function getOrigin() {
    return new Point(
    	gOrigin.x,
    	gOrigin.y
    )
}

function getOriginX() {
    return gOrigin.x
}

function getOriginY() {
    return gOrigin.y
}

function getRetinaFactor() {
    return gRetina;
}

function getTargetSize() {
    var rect = canvas.getBoundingClientRect();
    gLeft = rect.left
    gTop = rect.top
    var tw = Math.max(10, rect.width);
    var th = Math.max(10, rect.height);
    return new Size(tw, th);
}

function getVisibleBox() {
    var left = -getOriginX()
    var top = -getOriginY()
    var right = left + gWidth / gZoom
    var bottom = top + gHeight / gZoom
    var box = new Utils.Box(
    	left,
    	top,
    	right,
    	bottom
    );
    return box
}

function getZoom() {
    return gZoom;
}

function hideOver() {
    over.style.display = "none";
    var ctx = over.getContext("2d");
    ctx.clearRect(0, 0, over.width, over.height);
}

function incomingClick(evt) {
    CallTrace.add(
    	"vw:incomingClick", []
    )
    mouseDownCore(evt, false)
    mouseUp(evt)
}

function mouseDown(evt) {
    mouseDownCore(evt, true)
}

function mouseDownCore(evt, reset) {
    if (reset) {
        CallTrace.reset()
    }
    preventDefault(evt);
    gMouse.x = evt.clientX;
    gMouse.y = evt.clientY;
    var message = toDiagram(evt);
    if (evt.ctrlKey) {
        message.button = 2
    }
    CallTrace.add(
    	"vw:mouseDown",
    	[message.x, message.y,
    	message.cx, message.cy,
    	message.button]
    )
    gPayload.mouseDown(message);
}

function mouseLeave(evt) {
    CallTrace.add(
    	"vw:mouseLeave", []
    )
    if (evt.buttons == 0) {
        
    } else {
        mouseUp(evt)
    }
}

function mouseMove(evt) {
    preventDefault(evt);
    var dx = evt.clientX - gMouse.x;
    var dy = evt.clientY - gMouse.y;
    var mouseClient = toDiagram(evt);
    var message = {
    	x: mouseClient.x,
    	y: mouseClient.y,
    	dx: dx / gZoom,
    	dy: dy / gZoom,
    	cx: evt.clientX,
    	cy: evt.clientY
    };
    gMouse.x = evt.clientX;
    gMouse.y = evt.clientY;
    gPayload.mouseMove(message);
}

function mouseUp(evt) {
    preventDefault(evt);
    var message = toDiagram(evt);
    CallTrace.add(
    	"vw:mouseUp",
    	[message.x, message.y,
    	message.cx, message.cy,
    	message.button]
    )
    gPayload.mouseUp(message);
}

function mouseWheel(evt) {
    var message = buildWheelMessage(evt);
    CallTrace.add(
    	"vw:mouseWheel",
    	[message.delta, message.shiftKey,
    	message.ctrlKey]
    )
    gPayload.mouseWheel(message);
}

function pan(ox, oy) {
    gOrigin = new Point(ox, oy);
    redrawLater();
}

function preventDefault(evt) {
    if (evt.preventDefault) {
        evt.preventDefault();
    } else {
        evt.returnValue = false;
    }
}

function randomColor() {
    var r = randomHexByte();
    var g = randomHexByte();
    var b = randomHexByte();
    return "#" + r + g + b;
}

function randomHexByte() {
    var value = Math.floor(Math.random() * 128);
    return toHexByte(value);
}

function rebuild() {
    gTempOrigin = new Point(
    	getOriginX(),
    	getOriginY()
    );
    var tSize = getTargetSize();
    gWidth = tSize.w
    gHeight = tSize.h
    setupCanvas(canvas, tSize.w, tSize.h);
    drawPatch();
    setupCanvas(over, tSize.w, tSize.h);
}

function redraw() {
    drawPatch();
}

function redrawLater() {
    window.requestAnimationFrame(drawPatch);
}

function scrollBy(dx, dy) {
    var ox = getOriginX()
    var oy = getOriginY()
    setOrigin(
    	ox + dx,
    	oy + dy
    )
    redrawLater();
}

function selectBlock(box) {
    var ctx = over.getContext("2d");
    if (gOldBlock) {
        var width = gOldBlock.right - gOldBlock.left + 6;
        var height = gOldBlock.bottom - gOldBlock.top + 6;
        ctx.clearRect(
        	gOldBlock.left - 3, 
        	gOldBlock.top - 3,
        	width,
        	height
        );
    }
    if (box) {
        var leftTop = diagramToClient(box.left, box.top);
        var rightBottom = diagramToClient(box.right, box.bottom);
        ctx.lineWidth = 2 * gRetina
        leftTop.x *= gRetina
        leftTop.y *= gRetina
        rightBottom.x *= gRetina
        rightBottom.y *= gRetina
        var newBox = new Utils.Box(
        	leftTop.x,
        	leftTop.y,
        	rightBottom.x,
        	rightBottom.y
        );
        var width2 = newBox.right - newBox.left;
        var height2 = newBox.bottom - newBox.top;
        ctx.strokeStyle = Theme.get("line")
        ctx.strokeRect(
        	newBox.left,
        	newBox.top,
        	width2,
        	height2
        );
    }
    gOldBlock = newBox;
}

function setCursor(cursor) {
    canvas.style.cursor = cursor;
}

function setOrigin(ox, oy) {
    gOrigin.x = ox
    gOrigin.y = oy
    if (self.onOriginChanged) {
        self.onOriginChanged(
        	gOrigin.x,
        	gOrigin.y
        )
    }
}

function setPayload(payload) {
    gPayload = payload;
    gTouch.setBeh(gPayload);
    gPayload.setZoom(gZoom, gRetina);
}

function setupCanvas(canvas, w, h) {
    canvas.width = w * gRetina
    canvas.height = h * gRetina
}

function showOver() {
    over.style.display = "inline-block"
}

function timersAdd(id, callback, milliseconds) {
    var me = this;
    var wrappedCallback = function() {
    	delete me.timers[id];
    	callback(id);
    	rebuild();
    }
    this.timers[id] = window.setTimeout(
    	wrappedCallback,
    	milliseconds
    );
}

function timersClear() {
    var ids = Object.keys(this.timers);
    var _ind797 = 0;
    var _col797 = ids;
    var _len797 = _col797.length;
    while (true) {
        if (_ind797 < _len797) {
            
        } else {
            break;
        }
        var id = _col797[_ind797];
        this.remove(id);
        _ind797++;
    }
}

function timersRemove(id) {
    var timer = this.timers[id];
    delete this.timers[id];
    window.clearInterval(timer);
}

function toDiagram(evt) {
    var cx = evt.clientX;
    var cy = evt.clientY;
    var result = clientToDiagram(cx, cy);
    result.button = evt.button;
    result.dx = evt.dx / gZoom;
    result.dy = evt.dy / gZoom;
    return result;
}

function toHexByte(value) {
    var hex = value.toString(16);
    if (hex.length < 2) {
        return "0" + hex;
    } else {
        return hex;
    }
}

function touchcancel(evt) {
    CallTrace.add(
    	"vw:touchcancel", []
    )
    DTools.print("cancel touch vw")
    preventDefault(evt);
    gTouch.touchcancel(evt);
}

function touchend(evt) {
    CallTrace.add(
    	"vw:touchend", [evt]
    )
    DTools.print("end touch vw")
    preventDefault(evt);
    gTouch.touchend(evt);
}

function touchmove(evt) {
    DTools.print("move touch vw")
    preventDefault(evt);
    gTouch.touchmove(evt);
}

function touchstart(evt) {
    CallTrace.reset()
    CallTrace.add(
    	"vw:touchstart", [evt]
    )
    DTools.clear()
    DTools.print("start touch vw")
    preventDefault(evt);
    gTouch.touchstart(evt);
}

function zoomAt(center, newZoom) {
    newZoom = Math.max(0.2, Math.min(3, newZoom));
    gOrigin = adjustOriginToZoom(center, newZoom);
    gZoom = newZoom;
    redraw();
}

function zoomBy(amount) {
    //var newZoom = gZoom * (1 + amount / 500.0);
    //zoomAt(gMouse, newZoom);
    if (amount > 0) {
        zoomIn()
    } else {
        zoomOut()
    }
}

function zoomIn() {
    var i;
    i = 0;
    while (true) {
        if (i < gZooms.length) {
            
        } else {
            break;
        }
        var zoom = gZooms[i];
        if (zoom > gZoom) {
            zoomAt(gMouse, zoom)
            break;
        }
        i++;
    }
}

function zoomOut() {
    var i;
    i = gZooms.length - 1;
    while (true) {
        if (i >= 0) {
            
        } else {
            break;
        }
        var zoom = gZooms[i];
        if (zoom < gZoom) {
            zoomAt(gMouse, zoom)
            break;
        }
        i--;
    }
}

function zoomTo(newZoom) {
    var size = getTargetSize();
    var at = new Point(size.w / 2, size.h / 2);
    gOrigin = adjustOriginToZoom(at, newZoom);
    gZoom = newZoom;
    finishZoom();
}


	this.rebuild = rebuild;
	this.redraw = redraw;
	this.setPayload = setPayload;
	this.pan = pan;
	this.Timers = Timers;
	this.setTimeout = setTimeout;
	this.clientToDiagram = clientToDiagram;
	this.diagramToClient = diagramToClient
	this.toDiagram = toDiagram;
	this.incomingClick = incomingClick;

	this.scrollBy = scrollBy;
	this.finishScroll = finishScroll;

	this.zoomBy = zoomBy;
	this.finishZoom = finishZoom;
	this.zoomTo = zoomTo;
	this.zoomIn = zoomIn;
	this.zoomOut = zoomOut;
	this.getZoom = getZoom;
	this.getOrigin = getOrigin;
	this.zoomAt = zoomAt;
	this.getRetinaFactor = getRetinaFactor;

	this.showOver = showOver;
	this.hideOver = hideOver;
	this.selectBlock = selectBlock;

	this.mouseDown = mouseDown;
	this.mouseMove = mouseMove;
	this.mouseUp = mouseUp;
	this.setCursor = setCursor;
	this.getVisibleBox = getVisibleBox
}
