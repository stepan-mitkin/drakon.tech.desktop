function Canvas(window, document, undefined) {
	var USE_SIMPLE_MEASURE = true
	var SHADOW_SHIFT_X = 5
	var SHADOW_SHIFT_Y = 7
	var SHADOW_STYLE = "rgba(0, 0, 0, 0.3)"

	var Q_PADDING = 20

	var self = this

	this.zoom = 1;
	this.retina = 1;

	var TEXTURE_BORDER = 20;
	var SHADOW_BORDER = 0

	var ARROW_WIDTH = 20;
	var ARROW_HEIGHT = 5;
	var CANDY_SIZE = 10;


	var gContext = null;
	var gBackground = ""

	var gFont = null
	var gDefaultFont = null
	var gShadows = {}

	this.renderToTexture = true

	

	var gNextItem = 0;
	var gItems = {};
	var gPlanes = makePlanes();

	var gDoc = document;
	var gTextCanvas = gDoc.createElement("canvas");
	var gTextContext = gTextCanvas.getContext("2d");

	var gMoveAllImage = null
	var gMoveAllImageReady = false
	var gVideoImage = null
	var gLinkImage = null
	var gPictureImage = null

	var moreCallbacks = {}

	// updateFontMetrics();

// Autogenerated with DRAKON Editor 1.33


function FontRecord(font, italic, bold, size, family) {
    this.font = font
    this.italic = italic
    this.bold = bold
    this.size = size
    this.family = family
    this.face = italic + "-" + bold + "-" + family
}

function SafePath(ctx, ox, oy, scaleX, scaleY) {
    this.ctx = ctx
    this.moveTo = sp_moveTo
    this.lineTo = sp_lineTo
    this.arc = sp_arc
    this.transformX = sp_x
    this.transformY = sp_y
    this.ox = ox
    this.oy = oy
    this.scaleX = scaleX
    this.scaleY = scaleY
}

function addDirect(textureItem, draw) {
    var obj = {
    	draw: draw
    }
    textureItem.primitives.push(obj)
}

function addShadow(key, color, blur, offsetX, offsetY) {
    gShadows[key] = {
    	key: key,
    	color: color,
    	blur: blur,
    	offsetX: offsetX,
    	offsetY: offsetY
    }
}

function addSocket(x, y, active) {
    var item = {
    	x: x, y: y, active: active,
    	draw: drawSocket
    };
    return createItem(item, "sockets");
}

function buildBeginPath(ctx, x, y, w, h, points) {
    var x0 = x - w;
    var x1 = x0 + h;
    var x3 = x + w;
    var x2 = x3 - h;
    var top = y - h;
    var bottom = y + h;
    ctx.beginPath();
    ctx.arc(x1, y, h, Math.PI * 0.5, Math.PI * 1.5);
    ctx.lineTo(x2, top);
    ctx.arc(x2, y, h, Math.PI * 1.5, Math.PI * 0.5);
    ctx.closePath();
}

function buildCloudPath(ctx, x, y, w, h, points) {
    var r1 = Math.round(h * 2 / 3)
    var bottom = y + h
    var w2 = Math.round(h * 490 / 260)
    var leftX = x - w2 + r1
    var rightX = x + w2 - r1
    var midY = bottom - r1 * 2
    var x0 = x - w2 / 2
    var y0 = y - h
    var x1 = x - w2 / 4
    var y1 = y - h + r1 / 2
    var x2 = x + 0.34 * w2
    var y2 = y - h - r1 * 1.3
    var x3 = rightX
    var y3 = midY
    var rleft = r1 * 0.8
    var rright = r1 * 1.4
    var scale = w / h / 2
    /*
    ctx.beginPath();
    ctx.moveTo(leftX, bottom)
    ctx.arc(leftX, bottom - r1, r1, Math.PI / 2, Math.PI * 3 / 2)
    ctx.lineTo(x0, y0)
    ctx.lineTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.lineTo(x3, y3)
    ctx.arc(rightX, bottom - r1, r1, -Math.PI / 2, Math.PI / 2)
    ctx.closePath();
    */
    /*
    ctx.beginPath();
    ctx.moveTo(leftX, bottom)
    ctx.arc(leftX, bottom - r1, r1, Math.PI / 2, Math.PI * 3 / 2)
    ctx.arcTo(x0, y0, x1, y1, rleft)
    ctx.arcTo(x2, y2, x3, y3, rright)
    ctx.arc(rightX, bottom - r1, r1, -Math.PI / 2, Math.PI / 2)
    ctx.closePath();
    */
    var clx = x - w2 * 0.34
    var cly = midY + h * 0.16
    var clbegin = -0.9 * Math.PI
    var clend = -0.25 * Math.PI
    
    var crx = x + w2 * 0.2
    var cry = midY
    var crbegin = -0.9 * Math.PI
    var crend = 0
    rright = r1
    var useSafe = true
    if (ctx.ellipse) {
        ctx.save()
        ctx.translate(x, y)
        ctx.scale(scale, 1)
        ctx.translate(-x, -y)
        ctx.beginPath();
        ctx.moveTo(leftX, bottom)
        ctx.arc(leftX, bottom - r1, r1, Math.PI / 2, Math.PI * 3 / 2)
        ctx.arc(clx, cly, rleft, clbegin, clend)
        ctx.arc(crx, cry, rright, crbegin, crend)
        ctx.arc(rightX, bottom - r1, r1, -Math.PI / 2, Math.PI / 2)
        ctx.closePath();
         ctx.restore()
    } else {
        var sp = new SafePath(
        	ctx,
        	x, y,
        	scale, 1
        )
        ctx.beginPath();
        sp.moveTo(leftX, bottom)
        sp.arc(leftX, bottom - r1, r1, Math.PI / 2, Math.PI * 3 / 2)
        sp.arc(clx, cly, rleft, clbegin, clend)
        sp.arc(crx, cry, rright, crbegin, crend)
        sp.arc(rightX, bottom - r1, r1, -Math.PI / 2, Math.PI / 2)
        ctx.closePath();
    }
}

function buildDbLidPath(ctx, x, y, w, h) {
    var h2 = makeCylinderHeight(w)
    var scale = h / h2
    var ctop = y - h2 + w
    if (ctx.ellipse) {
        ctx.save()
        ctx.translate(x, y)
        ctx.scale(1, scale)
        ctx.translate(-x, -y)
        ctx.beginPath();
        ctx.arc(x, ctop, w, 0, Math.PI)
         ctx.restore()
    } else {
        var sp = new SafePath(
        	ctx,
        	x, y,
        	1, scale
        )
        ctx.beginPath();
        sp.moveTo(x + w, ctop)
        sp.arc(x, ctop, w, 0, Math.PI)
    }
}

function buildDbPath(ctx, x, y, w, h) {
    var h2 = makeCylinderHeight(w)
    var scale = h / h2
    var ctop = y - h2 + w
    var cbottom = y + h2 - w
    if (ctx.ellipse) {
        ctx.save()
        ctx.translate(x, y)
        ctx.scale(1, scale)
        ctx.translate(-x, -y)
        ctx.beginPath();
        ctx.arc(x, ctop, w, -Math.PI, 0)
        ctx.arc(x, cbottom, w, 0, Math.PI)
        ctx.closePath()
         ctx.restore()
    } else {
        var sp = new SafePath(
        	ctx,
        	x, y,
        	1, scale
        )
        ctx.beginPath();
        sp.arc(x, ctop, w, -Math.PI, 0)
        sp.arc(x, cbottom, w, 0, Math.PI)
        ctx.closePath()
    }
}

function buildEllipsePath(ctx, x, y, w, h) {
    ctx.beginPath()
    safeEllipse(
    	ctx,
    	x,
    	y,
    	w,
    	h
    )
}

function buildEndPath(ctx, x, y, w, h, points) {
    var radius = points[2]
    var left = x - w;
    var top = y - h;
    var right = x + w;
    var bottom = y + h;
    var x0 = left;
    var x1 = x0 + radius;
    var x3 = right;
    var x2 = x3 - radius;
    var y0 = top;
    var y1 = bottom - radius;
    var y2 = bottom;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x3, y0);
    ctx.lineTo(x3, y1);
    ctx.arc(x2, y1, radius, Math.PI * 0, Math.PI * 0.5);
    ctx.lineTo(x1, y2);
    ctx.arc(x1, y1, radius, Math.PI * 0.5, Math.PI * 1.0);
    ctx.closePath();
}

function buildPolyPath(ctx, x, y, points, format) {
    ctx.beginPath();
    var x0 = points[0] + x
    var y0 = points[1] + y
    ctx.moveTo(x0, y0)
    var i = 2
    var length = points.length
    while (true) {
        if (i < length) {
            
        } else {
            break;
        }
        x0 = points[i] + x
        i++
        y0 = points[i] + y
        i++
        ctx.lineTo(x0, y0)
    }
    ctx.closePath();
}

function buildStartPath(ctx, x, y, w, h, points) {
    var radius = points[2]
    var left = x - w;
    var top = y - h;
    var right = x + w;
    var bottom = y + h;
    var x0 = left;
    var x1 = x0 + radius;
    var x3 = right;
    var x2 = x3 - radius;
    var y0 = top;
    var y1 = y0 + radius;
    var y2 = bottom;
    ctx.beginPath();
    ctx.arc(x1, y1, radius, Math.PI * 1.0, Math.PI * 1.5);
    ctx.lineTo(x2, y0);
    ctx.arc(x2, y1, radius, Math.PI * 1.5, Math.PI * 0);
    ctx.lineTo(x3, y2);
    ctx.lineTo(x0, y2);
    ctx.closePath();
}

function buildTabPath(ctx, x, y, w, h, points) {
    var notch = h / 3;
    var x0 = x - w;
    var x1 = x0 + notch;
    var x3 = x + w;
    var x2 = x3 - notch;
    var y0 = y - h;
    var y1 = y0 + notch
    var y2 = y + h;
    ctx.beginPath();
    ctx.moveTo(x0, y2)
    ctx.lineTo(x0, y1)
    ctx.lineTo(x1, y0)
    ctx.lineTo(x2, y0)
    ctx.lineTo(x3, y1)
    ctx.lineTo(x3, y2)
}

function cfalse_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    ctx.fillStyle = format.fillColor
    if (shouldShift(ctx.lineWidth)) {
        x += 0.5
        y += 0.5
    }
    var xp = w * 0.3
    var yp = h * 0.3
    var x0 = x - w + xp
    var y0 = y - h + yp
    var w2 = w * 2 - xp * 2
    var h2 = h * 2 - yp * 2
    ctx.fillRect(x0, y0, w2, h2)
    ctx.strokeRect(x0, y0, w2, h2)
}

function check_render(ctx, x, y, w, h, format) {
    var xp = w * 0.3
    var yp = h * 0.3
    var x0 = x - w + xp
    var x1 = x0 + xp
    var x2 = x + w - xp
    
    var y0 = y - h + yp
    var y1 = y + h - yp
    setStyleForMore(ctx, format)
    ctx.beginPath();
    ctx.moveTo(x0, y)
    ctx.lineTo(x1, y1)
    ctx.lineTo(x2, y0)
    ctx.stroke()
}

function circlePath(ctx, x, y, r) {
    buildEllipsePath(ctx, x, y, r, r)
}

function cleanDirty() {
    this.dirty = false;
}

function clear() {
    gNextItem = 0;
    gPlanes = makePlanes();
    gItems = {};
}

function clearGuides() {
    var _ind2730 = 0;
    var _col2730 = gPlanes.guides;
    var _len2730 = _col2730.length;
    while (true) {
        if (_ind2730 < _len2730) {
            
        } else {
            break;
        }
        var prim = _col2730[_ind2730];
        delete gItems[prim.id]
        _ind2730++;
    }
    gPlanes.guides = []
}

function clearShadow(ctx) {
    ctx.shadowColor = "rgba(0, 0, 0, 0)"
}

function close_mac_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var h2 = h * 0.5
    var c0 = x - 3 * h2
    var c1 = x
    var c2 = x + 3 * h2
    
    var m = h2 * Math.cos(Math.PI / 4)
    
    var x0 = c0 - m
    var x1 = c0 + m
    
    var y0 = y - m
    var y1 = y + m
    circlePath(ctx, c0, y, h2)
    ctx.stroke()
    circlePath(ctx, c1, y, h2)
    ctx.stroke()
    circlePath(ctx, c2, y, h2)
    ctx.stroke()
    line1(ctx, x0, y0, x1, y1)
    line1(ctx, x0, y1, x1, y0)
}

function close_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    if (shouldShift(ctx.lineWidth)) {
        x += 0.5
        y += 0.5
    }
    var h2 = Math.round(h * 0.5)
    var c0 = x - 3 * h2
    var c1 = x
    var c2 = x + 3 * h2
    
    var x0 = c0 - h2
    var x1 = c0 + h2
    
    var x2 = c1 - h2
    var x3 = c2 - h2
    var x4 = c2 + h2
    
    var y0 = y - h2
    var y1 = y + h2
    var s = h2 * 2
    ctx.strokeRect(x2, y0, s, s)
    line1(ctx, x0, y, x1, y)
    line1(ctx, x3, y0, x4, y1)
    line1(ctx, x3, y1, x4, y0)
}

function combo_render(ctx, x, y, w, h, format) {
    var xp = w * 0.5
    var yp = h * 0.6
    var x0 = x - w + xp
    var x1 = x + w - xp
    var y0 = y - h + yp
    var y1 = y + h - yp
    setStyleForMore(ctx, format)
    tri(ctx, x0, y0, x1, y0, x, y1)
}

function createCalloutArrow(x, y, w, h, cx, cy, format, layer) {
    var item = {
    	x: x, y: y, w: w, h: h,
    	cx: cx, cy: cy,
    	format: format,
    	draw: drawCalloutArrow
    };
    
    return createItem(item, layer);
}

function createFreeHorizontal(x, y, w, style, format, layer) {
    if (style == "dashed") {
        format.lineStyle = "s-2"
    }
    var item = {
    	x: x, y: y, w: w, h:0,
    	style: style,
    	format: format,
    	draw: drawFreeHorizontal
    };
    
    return createItem(item, layer);
}

function createHCandy(x, y, w, valence, left, right, layer) {
    var item = {
    	x: x, y: y, w: w, h: 10,
    	valence: valence,
    	left: left, right: right,
    	draw: drawHCandy
    };
    
    return createItem(item, layer);
}

function createHorizontal(x, y, w, role, format, layer) {
    var parallel = false
    var thickness = format.lineThickness
    if (role === "arrow") {
        format.arrowStart = "arrow"
        x += thickness
        w -= thickness
    } else {
        if (role === "rarrow") {
            format.arrowEnd = "arrow"
            w -= thickness
        } else {
            if (role === "parallel") {
                parallel = true
            }
        }
    }
    var item = {
    	x: x, y: y, w: w, h:0,
    	format: format,
    	parallel: parallel,
    	draw: drawHorizontal
    };
    
    return createItem(item, layer);
}

function createItem(item, layer) {
    var plane = getPlane(layer);
    var id = nextId();
    item.id = id;
    item.layer = layer;
    plane.push(item);
    gItems[id] = item;
    return id;
}

function createJCandy(x, y, color, layer) {
    var item = {
    	x: x, y: y,
    	color: color,
    	draw: drawJCandy
    };
    
    return createItem(item, layer);
}

function createLine(x, y, w, h, format, layer) {
    var item = {
    	x:x, y:y, w:w, h:h,
    	format: format,
    	draw: drawLinePrim
    };
    
    return createItem(item, layer);
}

function createMoveAll(x, y, layer) {
    var item = {
    	x: x, y: y,
    	draw: drawMoveAll
    };
    
    return createItem(item, layer);
}

function createRCorner(x, y, format, direction, radius, layer) {
    var item = {
    	x: x, y: y,
    	format: format,
    	direction: direction,
    	radius: radius,
    	draw: drawRCorner
    };
    
    return createItem(item, layer);
}

function createRealTexture(x, y, left, top, w, h, layer, angle) {
    var rScale = self.retina
    var width = w + 2 * TEXTURE_BORDER + SHADOW_BORDER;
    var height = h + 2 * TEXTURE_BORDER + SHADOW_BORDER;
    var canvas = document.createElement("canvas");
    canvas.width = width * self.zoom * rScale;
    canvas.height = height * self.zoom * rScale;
    var ctx = canvas.getContext("2d");
    ctx.font =  gFont.font
    //ctx.fillStyle = "red"
    //ctx.fillRect(0, 0, 1000, 1000)
    var scale = self.zoom * rScale;
    ctx.scale(scale, scale);
    ctx.translate(
    	-x - left + TEXTURE_BORDER,
    	-y - top + TEXTURE_BORDER
    );
    var item = {
    	x: x, y: y, 
    	left: left, top: top,
    	width: width, height: height,
    	canvas: canvas, context: ctx,
    	draw: drawTexture,
    	angle: angle
    };
    
    return createItem(item, layer);
}

function createRectangle(x, y, w, h, format, layer) {
    var item = {
    	x:x, y:y, w:w, h:h,
    	format: format,
    	draw: drawRectItem
    };
    
    return createItem(item, layer);
}

function createTexture(x, y, left, top, w, h, layer, angle) {
    if (this.renderToTexture) {
        return createRealTexture(
        	x, y,
        	left, top, w, h,
        	layer, angle
        )
    } else {
        var item = {
        	x: x, y: y, 
        	left: left, top: top,
        	width: w, height: h,
        	primitives: [],
        	draw: drawFakeTexture,
        	font: gFont.font,
        	angle: angle
        }
        return createItem(item, layer)
    }
}

function createVCandy(x, y, h, valence, top, bottom, layer) {
    var item = {
    	x: x, y: y, h: h, valence: valence,
    	top: top, bottom: bottom,
    	draw: drawVCandy
    };
    return createItem(item, layer);
}

function createVertical(x, y, h, role, format, layer) {
    var item = {
    	x: x, y: y, h: h, w:0,
    	role: role,
    	format: format,
    	draw: drawVertical
    };
    
    return createItem(item, layer);
}

function cross_render(ctx, x, y, w, h, format) {
    var xp = w * 0.3
    var yp = h * 0.3
    var x0 = x - w + xp
    var x1 = x + w - xp
    var y0 = y - h + yp
    var y1 = y + h - yp
    setStyleForMore(ctx, format)
    ctx.beginPath();
    ctx.moveTo(x0, y0)
    ctx.lineTo(x1, y1)
    ctx.closePath()
    ctx.stroke()
    ctx.beginPath();
    ctx.moveTo(x1, y0)
    ctx.lineTo(x0, y1)
    ctx.closePath()
    ctx.stroke()
}

function ctrue_render(ctx, x, y, w, h, format) {
    cfalse_render(ctx, x, y, w, h, format)
    var xp = w * 0.6
    var yp = h * 0.6
    var x0 = x - w + xp
    var y0 = y - h + yp
    var x1 = x + w - xp
    var y1 = y + h - yp
    line2(ctx,
    	x0, y0,
    	x, y1,
    	x1, y0
    )
}

function deleteItem(id) {
    if (id in gItems) {
        var item = gItems[id];
        var layer = getPlane(item.layer);
        var length = layer.length;
        delete gItems[id];
        var i = 0;
        while (true) {
            if (i < length) {
                
            } else {
                break;
            }
            if (layer[i].id == id) {
                layer.splice(i, 1);
                break;
            }
            i++;
        }
    }
}

function dots3h_render(ctx, x, y, w, h, format) {
    var h2 = h * 0.6
    var x0 = x - h2
    var x1 = x + h2
    var r = getThickness(format.lineThickness) || 1
    setStyleForMore(ctx, format)
    ctx.beginPath()
    safeEllipse(ctx, x0, y, r, r)
    ctx.fill()
    ctx.beginPath()
    safeEllipse(ctx, x, y, r, r)
    ctx.fill()
    ctx.beginPath()
    safeEllipse(ctx, x1, y, r, r)
    ctx.fill()
}

function dots3v_render(ctx, x, y, w, h, format) {
    var h2 = h * 0.6
    var y0 = y - h2
    var y1 = y + h2
    var r = getThickness(format.lineThickness) || 1
    setStyleForMore(ctx, format)
    ctx.beginPath()
    safeEllipse(ctx, x, y0, r, r, 0, 0, Math.PI * 2)
    ctx.fill()
    ctx.beginPath()
    safeEllipse(ctx, x, y, r, r, 0, 0, Math.PI * 2)
    ctx.fill()
    ctx.beginPath()
    safeEllipse(ctx, x, y1, r, r, 0, 0, Math.PI * 2)
    ctx.fill()
}

function down_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var padding = w * 0.3
    var y0 = y - h / 3
    var y1 = y + h / 3
    var x0 = x - w + padding
    var x1 = x + w - padding
    line2(
    	ctx,
    	x0, y0,
    	x, y1,
    	x1, y0
    )
}

function draw(ctx) {
    try {
    	gContext = ctx
    	drawItems(true)
    	gContext = null
    
    } catch (ex) {
    	CallTrace.error(ex)
    	throw ex
    }
}

function drawActionCore(ctx, x, y, w, h, format) {
    var left = x - w;
    var top = y - h;
    var width = w * 2;
    var height = h * 2;
    
    drawRect(
    	ctx,
    	left,
    	top,
    	width,
    	height,
    	format
    )
}

function drawArrowCap(ctx, format) {
    ctx.setLineDash([])
    ctx.strokeStyle = format.lineColor
    ctx.lineWidth = format.lineThickness
    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    ctx.fillStyle = format.lineColor
    var thick = format.lineThickness
    gContext.beginPath();
    gContext.moveTo(-ARROW_WIDTH, -ARROW_HEIGHT - thick)
    gContext.lineTo(0, 0);
    gContext.lineTo(-ARROW_WIDTH, ARROW_HEIGHT + thick)
    gContext.closePath()
    gContext.fill()
    gContext.stroke();
}

function drawArrowCapOld(ctx, format) {
    ctx.fillStyle = format.lineColor
    var thick = format.lineThickness
    var shift = thick / 2
    gContext.beginPath();
    gContext.moveTo(0, -shift)
    gContext.lineTo(-ARROW_WIDTH, -ARROW_HEIGHT - shift);
    gContext.lineTo(-ARROW_WIDTH, ARROW_HEIGHT + thick - shift);    
    gContext.lineTo(0, thick - shift)
    gContext.closePath();
    gContext.fill();
}

function drawCalloutArrow(item) {
    var fore = item.fore
    var back = item.back
    var cx = item.x + item.cx
    var cy = item.y + item.cy
    var w = item.w
    var h = item.h
    var x = item.cx
    var y = item.cy
    var left = item.x - item.w + 1.5
    var right = item.x + item.w - 1.5
    var top = item.y - item.h + 1.5
    var bottom = item.y + item.h - 1.5
    var a = isAboveNWSE(-w, -h, x, y)
    var b = isAboveNESW(-w,  h, x, y)
    var c = isAboveNESW( w, -h, x, y)
    var d = isAboveNWSE( w,  h, x, y)
    var a, b, c
    var t
    var ex, ey
    if (((a) && (c)) && (y < -item.h)) {
        t = getTHor(item, y)
        ex = getEx(item, x)
        a = {x: ex-t, y:top}
        c = {x: ex+t, y:top}
        a.x = Math.max(a.x, left)
        c.x = Math.min(c.x, right)
    } else {
        if (((c) || (!(d))) || (!(x > item.w))) {
            if (((b) || (d)) || (!(y > item.h))) {
                t = getTVer(item, x)
                ey = getEy(item, y)
                a = {x: left, y:ey-t}
                c = {x: left, y:ey+t}
                a.y = Math.max(a.y, top)
                c.y = Math.min(c.y, bottom)
            } else {
                t = getTHor(item, y)
                ex = getEx(item, x)
                a = {x: ex-t, y:bottom}
                c = {x: ex+t, y:bottom}
                a.x = Math.max(a.x, left)
                c.x = Math.min(c.x, right)
            }
        } else {
            t = getTVer(item, x)
            ey = getEy(item, y)
            a = {x: right, y:ey-t}
            c = {x: right, y:ey+t}
            a.y = Math.max(a.y, top)
            c.y = Math.min(c.y, bottom)
        }
    }
    var fill = getFillColor(item.format.fillColor)
    if (fill) {
        gContext.fillStyle = fill
        gContext.strokeStyle = ""
        gContext.beginPath();
        gContext.moveTo(a.x, a.y)
        gContext.lineTo(cx, cy)
        gContext.lineTo(c.x, c.y)
        gContext.closePath()
        gContext.fill()
    }
    var width = setLineStyle(gContext, item.format)
    if (width == 0) {
        
    } else {
        gContext.beginPath();
        gContext.moveTo(a.x, a.y)
        gContext.lineTo(cx, cy)
        gContext.lineTo(c.x, c.y)
        gContext.stroke();
    }
}

function drawCap(ctx, style, format, x, y, angle) {
    ctx.save()
    ctx.translate(x, y)
    ctx.rotate(angle)
    if (style === "arrow") {
        drawArrowCap(ctx, format)
    } else {
        if (style === "sarrow") {
            drawSArrowCap(ctx, format)
        } else {
            if (style === "warrow") {
                drawWArrow(ctx, format)
            } else {
                if (style === "paw") {
                    drawPaw(ctx, format)
                }
            }
        }
    }
    ctx.restore()
}

function drawCircle(context, centerX, centerY, radius, thickness, back, fore) {
    gContext.beginPath();
    gContext.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
    gContext.fillStyle = back;
    gContext.fill();
    gContext.lineWidth = thickness;
    gContext.strokeStyle = fore;
    gContext.stroke();
}

function drawCompleted(ctx, x, y) {
    ctx.beginPath()
    var size = 24
    var rad = size / 2
    circlePath(
    	ctx,
    	x,
    	y,
    	rad
    )
    ctx.fillStyle = "#00a000"
    ctx.fill()
    ctx.strokeStyle = "#005000"
    ctx.lineWidth = 1
    ctx.setLineDash([])
    ctx.stroke()
    var x0 = x - rad * 0.6
    var y0 = y
    var x1 = x - rad * 0.3
    var y1 = y + rad * 0.3
    var x2 = x + rad * 0.5
    var y2 = y - rad * 0.5
    line2(
    	ctx,
    	x0, y0,
    	x1, y1,
    	x2, y2
    )
    ctx.strokeStyle = "white"
    ctx.lineWidth = 2
    ctx.setLineDash([])
    ctx.stroke()
}

function drawCross(context, centerX, centerY, radius, thickness, color) {
    var size = radius / 2
    var x1 = centerX - size
    var x2 = centerX + size
    var y1 = centerY - size
    var y2 = centerY + size
    context.lineWidth = thickness
    context.strokeStyle = color
    context.beginPath()
    context.moveTo(x1, centerY)
    context.lineTo(x2, centerY)
    context.stroke()
    context.beginPath()
    context.moveTo(centerX, y1)
    context.lineTo(centerX, y2)
    context.stroke()
    context.stroke()
}

function drawDb(ctx, x, y, points, format) {
    drawRectStrategy(
    	ctx,
    	x,
    	y,
    	points,
    	format,
    	buildDbPath
    )
    setStyleForMore(ctx, format)
    var w = points[0]
    var h = points[1]
    buildDbLidPath(ctx, x, y, w, h)
    ctx.stroke()
}

function drawFakeTexture(item) {
    var ctx = getContext()
    ctx.font = item.font
    var left = item.x + item.left - TEXTURE_BORDER
    var top = item.y + item.top - TEXTURE_BORDER
    rotateTexture(ctx, item, left, top)
    var _ind1061 = 0;
    var _col1061 = item.primitives;
    var _len1061 = _col1061.length;
    while (true) {
        if (_ind1061 < _len1061) {
            
        } else {
            break;
        }
        var prim = _col1061[_ind1061];
        prim.draw()
        _ind1061++;
    }
    restoreContext(ctx, item)
}

function drawFreeHorizontal(item) {
    drawLine(
    	gContext,
    	item.x,
    	item.y,
    	item.x + item.w,
    	item.y + item.h,
    	item.format
    )
}

function drawHCandy(item) {
    var x = item.x;
    var y = item.y;
    
    var x1 = x;
    var y1 = y - 2;
    var w1 = item.w;
    var h1 = 6;
    
    var x2 = x + 2;
    var y2 = y;
    var w2 = item.w - 4;
    var h2 = 2;
    
    
    gContext.fillStyle = "black";
    gContext.fillRect(x1, y1, w1, h1);
    
    gContext.fillStyle = "#00ff00";
    gContext.fillRect(x2, y2, w2, h2);
    if (item.valence) {
        var centerX = (item.left + item.right) / 2
        var centerY = y + 1
        
        var radius = Config.SOCKET_RADIUS;
        drawCircle(
        	gContext,
        	centerX,
        	centerY,
        	radius,
        	2,
        	"#00ff00",
        	"black"
        );
    }
}

function drawHorizontal(item) {
    drawLine(
    	gContext,
    	item.x,
    	item.y,
    	item.x + item.w,
    	item.y + item.h,
    	item.format
    )
    if (item.parallel) {
        var y2 = item.y + 5 + item.format.lineThickness
        drawLine(
        	gContext,
        	item.x,
        	y2,
        	item.x + item.w,
        	y2,
        	item.format
        )
    }
}

function drawItems(candies) {
    drawLayer("lines");
    if (candies) {
        drawLayer("line_candies");
    }
    drawLayer("icons");
    if (candies) {
        drawLayer("icon_candies");
        drawLayer("sockets");
    }
    drawLayer("free");
    if (candies) {
        drawLayer("free_candies");
    }
    drawLayer("guides");
}

function drawJCandy(item) {
    var x = item.x;
    var y = item.y;
    var color = item.color
    drawRectAtCenter(x, y, CANDY_SIZE, CANDY_SIZE, color, "black");
}

function drawLayer(layer) {
    var plane = getPlane(layer);
    var _ind166 = 0;
    var _col166 = plane;
    var _len166 = _col166.length;
    while (true) {
        if (_ind166 < _len166) {
            
        } else {
            break;
        }
        var item = _col166[_ind166];
        item.draw(item);
        _ind166++;
    }
}

function drawLine(ctx, x1, y1, x2, y2, format) {
    var width = setLineStyle(ctx, format)
    if (width == 0) {
        
    } else {
        if (shouldShift(width)) {
            x1 += 0.5
            y1 += 0.5
            x2 += 0.5
            y2 += 0.5
        }
        ctx.beginPath()
        ctx.moveTo(x1, y1)
        ctx.lineTo(x2, y2)
        ctx.stroke()
        if ((format.arrowStart) || (format.arrowEnd)) {
            var angle = Utils.findAngle(x1, y1, x2, y2)
            drawCap(
            	ctx,
            	format.arrowStart,
            	format,
            	x1,
            	y1,
            	angle + Math.PI
            )
            drawCap(
            	ctx,
            	format.arrowEnd,
            	format,
            	x2,
            	y2,
            	angle
            )
        }
    }
}

function drawLinePrim(item) {
    drawLine(
    	gContext,
    	item.x,
    	item.y,
    	item.x + item.w,
    	item.y + item.h,
    	item.format
    )
}

function drawLinkIcon(textureId, type, x, y) {
    genericRender(
    	drawLinkIconCore,
    	arguments
    )
}

function drawLinkIconCore(ctx, type, x, y) {
    if (type === "link") {
        drawSimpleLink(ctx, x, y)
    } else {
        if (type === "video") {
            drawVideoIcon(ctx, x, y)
        } else {
            if (type === "completed") {
                drawCompleted(ctx, x, y)
            }
        }
    }
}

function drawMoveAll(item) {
    var SIZE = 30
    var x = Math.floor(item.x)
    var y = Math.floor(item.y)
    drawRectAtCenter(x, y, SIZE, SIZE, "white", "black");
    if (gMoveAllImageReady) {
        gContext.drawImage(
        	gMoveAllImage,
        	x - SIZE / 2 + 1,
        	y - SIZE / 2 + 1,
        	SIZE - 2,
        	SIZE - 2
        )
    }
}

function drawPaw(ctx, format) {
    ctx.setLineDash([])
    ctx.strokeStyle = format.lineColor
    ctx.lineWidth = format.lineThickness
    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    var thick = format.lineThickness
    var height = ARROW_WIDTH / 2
    gContext.beginPath();
    gContext.moveTo(0, - height - thick)
    gContext.lineTo(-ARROW_WIDTH, 0);
    gContext.lineTo(0, height + thick)
    gContext.stroke();
}

function drawRCorner(item) {
    var _sw8930000_ = 0;
    setLineStyle(gContext, item.format)
    var radius = item.radius
    var x = item.x + 0.5
    var y = item.y + 0.5
    gContext.beginPath()
    _sw8930000_ = item.direction;
    if (_sw8930000_ === "left-top") {
        gContext.arc(
        	x + radius,
        	y + radius,
        	radius,
        	Math.PI,
        	Math.PI * 1.5
        )
    } else {
        if (_sw8930000_ === "right-top") {
            gContext.arc(
            	x - radius,
            	y + radius,
            	radius,
            	-Math.PI * 0.5,
            	0
            )
        } else {
            if (_sw8930000_ === "right-bottom") {
                gContext.arc(
                	x - radius,
                	y - radius,
                	radius,
                	0,
                	Math.PI * 0.5
                )
            } else {
                if (_sw8930000_ === "left-bottom") {
                    
                } else {
                    throw "Unexpected switch value: " + _sw8930000_;
                }
                gContext.arc(
                	x + radius,
                	y - radius,
                	radius,
                	Math.PI * 0.5,
                	Math.PI
                )
            }
        }
    }
    gContext.stroke();
}

function drawRect(ctx, x, y, w, h, format) {
    if (format.fillColor) {
        if (self.renderToTexture) {
            setShadow(ctx, format.shadow)
            setFillStyle(
            	ctx,
            	format.fillColor,
            	y,
            	y + h
            )
            ctx.fillRect(x, y, w, h)
            clearShadow(ctx)
        } else {
            simpleShadowRect(
            	ctx,
            	x,
            	y,
            	w,
            	h,
            	format.shadow
            )
            setFillStyle(
            	ctx,
            	format.fillColor,
            	y,
            	y + h
            )
            ctx.fillRect(x, y, w, h)
        }
    }
    var width = setLineStyle(ctx, format)
    if (width == 0) {
        
    } else {
        if (shouldShift(width)) {
            x += 0.5;
            y += 0.5;
        }
        ctx.strokeRect(x, y, w, h);
    }
}

function drawRectAtCenter(cx, cy, w, h, back, fore) {
    gContext.setLineDash([])
    var x = cx - Math.floor(w / 2);
    var y = cy - Math.floor(h / 2);
    // x += 0.5;
    // y += 0.5;
    if (back) {
        gContext.fillStyle = back;
        gContext.fillRect(x, y, w, h);
    }
    if (fore) {
        gContext.strokeStyle = fore;
        gContext.lineWidth = 2;
        gContext.strokeRect(x, y, w, h);
    }
}

function drawRectItem(item) {
    drawRect(
    	gContext,
    	item.x,
    	item.y,
    	item.w,
    	item.h,
    	item.format
    )
}

function drawRectStrategy(ctx, x, y, points, format, makeShape) {
    var w = Math.round(points[0])
    var h = Math.round(points[1])
    var makeShape2 = function(ctx, xx, yy) {
    	makeShape(ctx, xx, yy, w, h, points)
    }
    drawStrategy(
    	ctx,
    	x,
    	y,
    	h,
    	h,
    	format,
    	makeShape2
    )
}

function drawSArrowCap(ctx, format) {
    ctx.setLineDash([])
    ctx.strokeStyle = format.lineColor
    ctx.lineWidth = format.lineThickness
    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    var thick = format.lineThickness
    gContext.beginPath();
    gContext.moveTo(-ARROW_WIDTH, -ARROW_HEIGHT - thick)
    gContext.lineTo(0, 0);
    gContext.lineTo(-ARROW_WIDTH, ARROW_HEIGHT + thick)
    gContext.stroke();
}

function drawShape(textureId, x, y, points, format) {
    genericRender(
    	drawShapeCore,
    	arguments
    )
}

function drawShapeCore(ctx, type, x, y, points, format) {
    if (type === "rectangle") {
        var w = points[0]
        var h = points[1]
        drawActionCore(
        	ctx,
        	x,
        	y,
        	w,
        	h,
        	format
        )
    } else {
        if (type === "db") {
            drawDb(
            	ctx,
            	x,
            	y,
            	points,
            	format
            )
        } else {
            if (type === "beginend") {
                drawRectStrategy(
                	ctx,
                	x,
                	y,
                	points,
                	format,
                	buildBeginPath
                )
            } else {
                if (type === "rounded") {
                    drawRectStrategy(
                    	ctx,
                    	x,
                    	y,
                    	points,
                    	format,
                    	roundedRectShape
                    )
                } else {
                    if (type === "ctrlstart") {
                        drawRectStrategy(
                        	ctx,
                        	x,
                        	y,
                        	points,
                        	format,
                        	buildStartPath
                        )
                    } else {
                        if (type === "ctrlend") {
                            drawRectStrategy(
                            	ctx,
                            	x,
                            	y,
                            	points,
                            	format,
                            	buildEndPath
                            )
                        } else {
                            if (type === "tab") {
                                drawRectStrategy(
                                	ctx,
                                	x,
                                	y,
                                	points,
                                	format,
                                	buildTabPath
                                )
                            } else {
                                if (type === "cloud") {
                                    drawRectStrategy(
                                    	ctx,
                                    	x,
                                    	y,
                                    	points,
                                    	format,
                                    	buildCloudPath
                                    )
                                } else {
                                    if (type === "line") {
                                        var x2 = points[0]
                                        var y2 = points[1]
                                        drawLine(
                                        	ctx,
                                        	x,
                                        	y,
                                        	x2,
                                        	y2,
                                        	format
                                        )
                                    } else {
                                        if (type === "poly") {
                                            var bounds = findTopBottom(points)
                                            var makeShape = function(ctx0, x0, y0) {
                                            	buildPolyPath(
                                            		ctx0,
                                            		x0,
                                            		y0,
                                            		points,
                                            		format
                                            	)
                                            }
                                            drawStrategy(
                                            	ctx,
                                            	x,
                                            	y,
                                            	-bounds.top,
                                            	bounds.bottom,
                                            	format,
                                            	makeShape
                                            )
                                        } else {
                                            if (type === "circle") {
                                                var w = points[0]
                                                var h = points[1]
                                                var makeShape = function(ctx0, x0, y0) {
                                                	buildEllipsePath(
                                                		ctx0,
                                                		x0, y0,
                                                		w, h
                                                	)
                                                }
                                                drawStrategy(
                                                	ctx,
                                                	x,
                                                	y,
                                                	h,
                                                	h,
                                                	format,
                                                	makeShape
                                                )
                                            } else {
                                                if (type === "more") {
                                                    
                                                } else {
                                                    throw "Unexpected switch value: " + type;
                                                }
                                                var w = points[0]
                                                var h = points[1]
                                                var subtype = points[2]
                                                var method = moreCallbacks[subtype]
                                                method(
                                                	ctx,
                                                	x,
                                                	y,
                                                	w,
                                                	h,
                                                	format
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

function drawSimpleLink(ctx, x, y) {
    var size = 24
    var radius = size / 2
    var angle = 3
    var x0 = x - radius
    var x1 = x0 + angle
    var x3 = x + radius
    var x2 = x3 - angle
    var y0 = y - radius
    var y1 = y0 + angle
    var y3 = y + radius
    var y2 = y3 - angle
    ctx.beginPath()
    ctx.moveTo(x0, y1)
    ctx.lineTo(x1, y0)
    ctx.lineTo(x2, y0)
    ctx.lineTo(x3, y1)
    ctx.lineTo(x3, y2)
    ctx.lineTo(x2, y3)
    ctx.lineTo(x1, y3)
    ctx.lineTo(x0, y2)
    ctx.closePath()
    ctx.fillStyle = "#000090"
    ctx.fill()
    var aradius = radius - 7
    var m = aradius * 1.0
    x0 = x - aradius
    x1 = x + aradius - m
    x2 = x + aradius
    y0 = y - aradius
    y1 = y0 + m
    y2 = y + aradius
    ctx.strokeStyle = "white"
    ctx.lineWidth = 3
    ctx.setLineDash([])
    line1(ctx, x0, y2, x2, y0)
    line2(
    	ctx,
    	x, y0,
    	x2, y0,
    	x2, y
    )
}

function drawSocket(item) {
    var border = "black";
    var body = "#ffff00";
    var radius = Config.SOCKET_RADIUS;
    if (item.active) {
        drawCircle(
        	gContext,
        	item.x,
        	item.y,
        	radius,
        	2,
        	border,
        	body
        );
        drawCross(
        	gContext,
        	item.x,
        	item.y,
        	radius,
        	2,
        	body,
        	border
        )
    } else {
        drawCircle(
        	gContext,
        	item.x,
        	item.y,
        	radius,
        	2,
        	body,
        	border
        );
        drawCross(
        	gContext,
        	item.x,
        	item.y,
        	radius,
        	2,
        	border,
        	body
        )
    }
}

function drawStrategy(ctx, x, y, h1, h2, format, makeShape) {
    if (format.fillColor) {
        if (self.renderToTexture) {
            setShadow(ctx, format.shadow)
            fillShape(
            	ctx,
            	x,
            	y,
            	h1,
            	h2,
            	format,
            	makeShape
            )
            clearShadow(ctx)
        } else {
            simpleShadow(
            	ctx,
            	x,
            	y,
            	makeShape,
            	format.shadow
            )
            fillShape(
            	ctx,
            	x,
            	y,
            	h1,
            	h2,
            	format,
            	makeShape
            )
        }
    }
    var width = setLineStyle(ctx, format)
    if (width == 0) {
        
    } else {
        if (shouldShift(width)) {
            x += 0.5
            y += 0.5
        }
        makeShape(ctx, x, y)
        ctx.stroke()
    }
}

function drawText(textureId, text, x, y, color) {
    genericRender(
    	drawTextCore,
    	arguments
    )
}

function drawTextCore(ctx, text, x, y, color, font) {
    if (font) {
        ctx.font = font
    }
    ctx.fillStyle = color;
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";
    ctx.fillText(text, x, y + 1);
}

function drawTexture(item) {
    var left = item.x + item.left - TEXTURE_BORDER
    var top = item.y + item.top - TEXTURE_BORDER
    if ((item.angle) || (self.fast)) {
        rotateTexture(gContext, item, left, top)
        gContext.drawImage(
        	item.canvas,
        	left,
        	top,
        	item.width,
        	item.height
        )
        restoreContext(gContext, item)
    } else {
        gContext.save()
        gContext.setTransform(1, 0, 0, 1, 0, 0)
        var factor = self.zoom * self.retina
        var dx = self.dx * factor
        var dy = self.dy * factor
        var x = Math.round((left + self.dx) * factor)
        var y = Math.round((top + self.dy) * factor)
        gContext.drawImage(
        	item.canvas,
        	x,
        	y
        )
        gContext.restore()
    }
}

function drawVCandy(item) {
    var x = item.x;
    var y = item.y;
    
    var x1 = x - 2;
    var y1 = y;
    var h1 = item.h;
    var w1 = 6;
    
    var x2 = x;
    var y2 = y + 2;
    var h2 = item.h - 4;
    var w2 = 2;
    
    
    gContext.fillStyle = "black";
    gContext.fillRect(x1, y1, w1, h1);
    
    gContext.fillStyle = "#00ff00";
    gContext.fillRect(x2, y2, w2, h2);
    if (item.valence) {
        var centerX = x + 1;
        var centerY = (item.top + item.bottom) / 2;
        
        var radius = Config.SOCKET_RADIUS;
        drawCircle(
        	gContext,
        	centerX,
        	centerY,
        	radius,
        	2,
        	"#00ff00",
        	"black"
        );
    }
}

function drawVertical(item) {
    var thickness
     = item.format.lineThickness
    var dx = Math.floor(thickness / 2)
    gContext.fillStyle = item.format.lineColor
    gContext.fillRect(
    	item.x - dx,
    	item.y,
    	thickness,
    	item.h)
    if (item.role === "par-down-off") {
        drawCap(
        	gContext,
        	"arrow",
        	item.format,
        	item.x,
        	item.y + item.h - thickness,
        	Math.PI / 2
        )
    }
}

function drawVideoIcon(ctx, x, y) {
    ctx.beginPath()
    var size = 24
    var radius = size / 2
    var r2 = radius / 2
    var r4 = r2 / 4
    var x0 = x - r2 + r4
    var x1 = x + r2 + r4
    var y0 = y - r2
    var y1 = y + r2
    circlePath(
    	ctx,
    	x,
    	y,
    	12
    )
    ctx.fillStyle = "#d00000"
    ctx.fill()
    ctx.beginPath()
    ctx.moveTo(x0, y0)
    ctx.lineTo(x1, y)
    ctx.lineTo(x0, y1)
    ctx.fillStyle = "white"
    ctx.fill()
}

function drawWArrow(ctx, format) {
    ctx.setLineDash([])
    ctx.strokeStyle = format.lineColor
    ctx.lineWidth = format.lineThickness
    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    ctx.fillStyle = format.fillColor
    var thick = format.lineThickness
    gContext.beginPath();
    gContext.moveTo(-ARROW_WIDTH, -ARROW_HEIGHT - thick)
    gContext.lineTo(0, 0);
    gContext.lineTo(-ARROW_WIDTH, ARROW_HEIGHT + thick)
    gContext.closePath()
    gContext.fill()
    gContext.stroke();
}

function fillShape(ctx, x, y, h1, h2, format, makeShape) {
    setFillStyle(
    	ctx,
    	format.fillColor,
    	y - h1,
    	y + h2
    )
    makeShape(ctx, x, y)
    ctx.fill()
}

function findTopBottom(points) {
    var top = 0
    var bottom = 0
    var i
    var length = points.length
    i = 1;
    while (true) {
        if (i < length) {
            
        } else {
            break;
        }
        var py = points[i]
        top = Math.min(top, py)
        bottom = Math.max(bottom, py)
        i += 2;
    }
    return {
    	top: top,
    	bottom: bottom
    }
}

function genericRender(method, args) {
    var textureId = args[0]
    var item = gItems[textureId]
    if (self.renderToTexture) {
        var ctx = item.context
        args[0] = ctx
        method.apply(null, args)
    } else {
        var draw = function() {
        	var ctx = getContext()
        	args[0] = ctx
        	method.apply(null, args)
        }
        addDirect(item, draw)
    }
}

function getBackground() {
    return gBackground
}

function getCoarseFontHeight() {
    var body = gDoc.getElementsByTagName("body")[0];
    var dummy = gDoc.createElement("div");
    dummy.setAttribute("style", 
    "position:absolute;top:0;left:0;margin:0px;padding:0px;");
    dummy.innerHTML = 
     "<span style='font:" + gFont.font + "'>Mg</span>";
    
    body.appendChild(dummy);
    var height = dummy.clientHeight;
    
    body.removeChild(dummy);
    return height;
}

function getContext() {
    return gContext
}

function getEx(item, x) {
    var ex
    var midX = Math.abs(x) < item.w / 2
    if (midX) {
        ex = item.x
    } else {
        if (x < 0) {
            ex = item.x - item.w * 2 / 3
        } else {
            ex = item.x + item.w * 2 / 3
        }
    }
    return ex
}

function getEy(item, y) {
    var ey
    var midY = Math.abs(y) < item.h / 2
    if (midY) {
        ey = item.y
    } else {
        if (y < 0) {
            ey = item.y - item.h * 2 / 3
        } else {
            ey = item.y + item.h * 2 / 3
        }
    }
    return ey
}

function getFillColor(color) {
    if (color) {
        if (color.length == 7) {
            return color
        } else {
            var parts = color.split(" ")
            if ((parts.length == 3) && (parts[0] == "gradient")) {
                var bottomColor = parts[2]
                return bottomColor
            } else {
                return ""
            }
        }
    } else {
        return ""
    }
}

function getFineFontHeight(coarseHeight) {
        var h = coarseHeight * 2;    
    
    
        var fontDraw = gDoc.createElement("canvas");
        fontDraw.width = h;
        fontDraw.height = h;
        fontDraw.style.width = h + "px";
        fontDraw.style.height = h + "px";
        var ctx = fontDraw.getContext('2d');
        ctx.fillRect(0, 0, fontDraw.width, fontDraw.height);
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'white';
        ctx.font = gFont.font;
        ctx.fillText('gM', 0, 1);
        var pixels = ctx.getImageData(0, 0, fontDraw.width, fontDraw.height).data;
        var start = -1;
        var end = -1;
        for (var row = 0; row < fontDraw.height; row++) 
        {
          for (var column = 0; column < fontDraw.width; column++) 
          {
            var index = (row * fontDraw.width + column) * 4;
            if (pixels[index] === 0) {
              if (column === fontDraw.width - 1 && start !== -1) {
                end = row;
                row = fontDraw.height;
                break;
              }
              continue;
            }
            else 
            {
              if (start === -1) 
              {
                start = row;
              }
              break;
            }
          }
        }
        return end - start;
}

function getFontHeight() {
    var size = HtmlUtils.getFontHeight(
    	gFont.face,
    	gFont.size,
    	gFont.font
    )
    if (USE_SIMPLE_MEASURE) {
        size = null
    }
    if (size) {
        
    } else {
        size = gFont.size
    }
    return Math.floor(size);
}

function getPlane(name) {
    if (name in gPlanes) {
        return gPlanes[name];
    } else {
        throw "Unknown plane: " + name;
    }
}

function getRayCount(r) {
    var rays
    if (r > 40) {
        rays = r / 3
    } else {
        rays = r
    }
    return Math.max(6, Math.floor(rays))
}

function getTHor(item, y) {
    var t = item.w / 8
    var diff = Math.abs(item.h - Math.abs(y))
    t = Math.min(t, diff / 4)
    t = Math.max(t, 15)
    return t
}

function getTVer(item, x) {
    var t = item.h / 8
    var diff = Math.abs(item.w - Math.abs(x))
    t = Math.min(t, diff / 4)
    t = Math.max(t, 8)
    return t
}

function getThickness(thickness) {
    if (typeof thickness == "number") {
        return thickness
    } else {
        return 1
    }
}

function hscroll_render(ctx, x, y, w, h, format) {
    drawActionCore(
    	ctx,
    	x,
    	y,
    	w,
    	h,
    	format
    )
    ctx.fillStyle = format.lineColor
    var padding = h / 4
    var y0 = y - h + padding
    var y1 = y + h - padding
    var x0 = x - w + padding
    var x1 = x - w + h * 1.5
    var x2 = x + w - h * 1.5
    var x3 = x + w - padding
    ctx.beginPath();
    ctx.moveTo(x0, y)
    ctx.lineTo(x1, y0)
    ctx.lineTo(x1, y1)
    ctx.closePath()
    ctx.fill()
    ctx.beginPath();
    ctx.moveTo(x2, y0)
    ctx.lineTo(x3, y)
    ctx.lineTo(x2, y1)
    ctx.closePath()
    ctx.fill()
}

function human_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    ctx.fillStyle = format.fillColor
    if (shouldShift(ctx.lineWidth)) {
        x += 0.5
        y += 0.5
    }
    var top = y - h
    var bottom = y + h
    var w2 = w * 2
    var h2 = h * 2
    var l = Math.round(h2 * 0.4)
    var m = 0 //Math.round(h / 30)
    var r2 = Math.floor((w2 - m * 3) / 8)
    var r = Math.round(r2 * 1.5)
    var k = Math.round(r * 2.3)
    var ar = Math.round(r2 * 0.8)
    var right = x + r2 * 2 + ar * 2
    var rpdm = right - ar * 2
    var rbok = rpdm - m
    var rc = rbok - r2
    var rgr = rbok - r2 * 2
    var lgr = rgr - m
    var lc = lgr - r2
    var lbok = lgr - r2 * 2
    var lpdm = lbok - m
    var left = lpdm - ar * 2
    var ln = lpdm - r2
    var hx = Math.round((lgr + rgr) / 2)
    var ttop = top + k
    var pdm = ttop + ar * 2
    var ph = bottom - l
    var ld = bottom - r2
    circlePath(ctx, hx, top + r, r)
    ctx.fill()
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(rpdm, ttop)
    ctx.arc(rpdm, pdm, ar * 2, -Math.PI / 2, 0)
    ctx.lineTo(right, ph)
    ctx.arc(right - ar, ph, ar, 0, Math.PI)
    ctx.lineTo(rpdm, pdm)
    ctx.lineTo(rbok, pdm)
    ctx.lineTo(rbok, ld)
    ctx.arc(rc, ld, r2, 0, Math.PI)
    ctx.lineTo(rgr, ph)
    ctx.lineTo(lgr, ph)
    ctx.lineTo(lgr, ld)
    ctx.arc(lc, ld, r2, 0, Math.PI)
    ctx.lineTo(lbok, pdm)
    ctx.lineTo(lpdm, pdm)
    ctx.lineTo(lpdm, ph)
    ctx.arc(lpdm - ar, ph, ar, 0, Math.PI)
    ctx.lineTo(left, ttop + ar * 2)
    ctx.arc(left + ar * 2, ttop + ar * 2, ar * 2, -Math.PI, -Math.PI / 2)
    ctx.closePath()
    ctx.fill()
    ctx.stroke()
}

function initShadows() {
    addShadow("100b", "rgba(255, 255, 255, 0.2)", 8, 0, 0)
    addShadow("100r", "rgba(0, 0, 0, 0.2)", 6, 4, 4)
    addShadow("200r", "rgba(0, 0, 0, 0.4)", 8, 4, 4)
    addShadow("300r", "rgba(0, 0, 0, 0.6)", 10, 4, 4)
    addShadow("400r", "rgba(0, 0, 0, 0.6)", 15, 8, 8)
    addShadow("50", "rgba(0, 0, 0, 0.2)", 6, 0, 0)
    addShadow("100", "rgba(0, 0, 0, 0.3)", 8, 0, 0)
    addShadow("200", "rgba(0, 0, 0, 0.4)", 10, 0, 0)
    addShadow("300", "rgba(0, 0, 0, 0.6)", 15, 0, 0)
    addShadow("400", "rgba(0, 0, 0, 0.6)", 20, 0, 0)
}

function isAboveNESW(bx, by, x, y) {
    x -= bx
    y -= by
    var value = x - bx + by - y
    return -x > y
}

function isAboveNWSE(bx, by, x, y) {
    x -= bx
    y -= by
    var value = x - bx + by - y
    return x > y
}

function left_angle(ctx, x, y, w, h) {
    var padding = h * 0.3
    var x0 = x - w / 3
    var x1 = x + w / 3
    var y0 = y - h + padding
    var y1 = y + h - padding
    line2(
    	ctx,
    	x1, y0,
    	x0, y,
    	x1, y1
    )
}

function left_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    left_angle(ctx, x, y, w, h)
}

function left_render2(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var dx = w / 3
    left_angle(ctx, x - dx, y, w, h)
    left_angle(ctx, x + dx, y, w, h)
}

function line1(ctx, x0, y0, x1, y1) {
    ctx.beginPath();
    ctx.moveTo(x0, y0)
    ctx.lineTo(x1, y1)
    ctx.stroke()
}

function line2(ctx, x0, y0, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x0, y0)
    ctx.lineTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.stroke()
}

function makeCylinderHeight(w) {
    return Math.round(w * 10)
}

function makeDirty() {
    this.dirty = true;
}

function makePlanes() {
    return {
    	lines: [],
    	line_candies: [],
    	icons: [],
    	icon_candies: [],
    	sockets: [],
    	free: [],
    	free_candies: [],
    	guides: []
    };
}

function measureTextWidth(text) {
    var width = gTextContext.measureText(text).width;
    return Math.round(width);
}

function menu_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    if (shouldShift(ctx.lineWidth)) {
        x += 0.5
        y += 0.5
    }
    var xp = Math.round(w * 0.5)
    var yp = Math.round(h * 0.5)
    var x0 = x - w + xp
    var x1 = x + w - xp
    var y0 = y - h + yp
    var y1 = y + h - yp
    line1(ctx, x0, y0, x1, y0)
    line1(ctx, x0, y, x1, y)
    line1(ctx, x0, y1, x1, y1)
}

function moveItem(id, x, y) {
    var item = gItems[id];
    item.x = x;
    item.y = y;
}

function nextId() {
    gNextItem++;
    return gNextItem;
}

function notebook_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var border = Math.round(h / 5)
    var tp = Math.round(w / 5)
    var r = border
    roundedRectShape(
    	ctx,
    	x,
    	y,
    	w - border * 2,
    	h,
    	[0, 0, r, 0]
    )
    ctx.fill()
    ctx.fillRect(
    	x - w,
    	y + h - border,
    	w * 2,
    	border
    )
    ctx.fillStyle = format.fillColor
    ctx.fillRect(
    	x - w + border * 3,
    	y - h + border,
    	w * 2 - border * 6,
    	h * 2 - border * 2
    )
    ctx.fillRect(
    	x - tp,
    	y + h - border,
    	tp * 2,
    	border / 2
    )
}

function pc_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var x0 = x - w
    var y0 = y - h
    var w2 = w * 2
    var h2 = h * 2
    
    var p = Math.ceil(h / 10)
    var m = Math.round(h2 * 0.8)
    var n = Math.round(w2 * 0.2)
    
    var y1 = y0 + p
    var y3 = x + h - p
    ctx.fillStyle = format.lineColor
    ctx.fillRect(x0, y0, w2, m)
    ctx.fillStyle = format.fillColor
    ctx.fillRect(x0 + p, y0 + p, w2 - p * 2, m - p * 2)
    ctx.fillStyle = format.lineColor
    ctx.fillRect(x - n / 2, y0 + m, n, h2 - m - p)
    ctx.fillStyle = format.lineColor
    ctx.fillRect(x - n, y + h - p, n * 2, p)
}

function phone_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var r = w / 5
    var border = h / 4
    var m = w / 4
    var button = Math.round(y + h - border / 2)
    if (shouldShift(ctx.lineWidth)) {
        button += 0.5
    }
    roundedRectShape(
    	ctx,
    	x,
    	y,
    	w,
    	h,
    	[0, 0, r, 0]
    )
    ctx.fill()
    ctx.fillStyle = format.fillColor
    ctx.fillRect(
    	x - w + ctx.lineWidth,
    	y - h + border,
    	w * 2 - ctx.lineWidth * 2,
    	h * 2 - border * 2
    )
    ctx.strokeStyle = format.fillColor
    line1(
    	ctx,
    	x - m,
    	button,
    	x + m,
    	button
    )
}

function portrait_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    ctx.fillStyle = format.fillColor
    if (shouldShift(ctx.lineWidth)) {
        x += 0.5
        y += 0.5
    }
    var left = x - w
    var right = x + w
    var top = y - h
    var bottom = y + h
    var g = 0.3
    var r = h / (2 + g)
    var b = r * 0.4
    
    var nh = r * 0.8
    var ux = x + nh
    var uy = y + 0.2 * h
    var mx = x - nh
    var wy = y + 0.6 * h
    var vy = (uy + wy) / 2
    ctx.beginPath()
    ctx.moveTo(x - r, top + r)
    ctx.arc(x, top + r, r, -Math.PI, 0)
    ctx.lineTo(x + r, top + r + b)
    ctx.arc(x, top + r + b, r, 0, Math.PI)
    ctx.closePath()
    ctx.fill()
    ctx.stroke()
    ctx.beginPath()
    ctx.moveTo(x, wy)
    ctx.lineTo(ux, uy)
    ctx.lineTo(right, vy)
    ctx.lineTo(right, bottom)
    ctx.lineTo(left, bottom)
    ctx.lineTo(left, vy)
    ctx.lineTo(mx, uy)
    ctx.closePath()
    ctx.fill()
    ctx.stroke()
}

function restoreContext(context, item) {
    if (item.angle) {
        context.restore()
    }
}

function rfalse_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    ctx.fillStyle = format.fillColor
    var xr = w * 0.8
    var yr = h * 0.8
    circlePath(ctx, x, y, xr)
    
    ctx.fill()
    ctx.stroke()
}

function right_angle(ctx, x, y, w, h) {
    var padding = h * 0.3
    var x0 = x - w / 3
    var x1 = x + w / 3
    var y0 = y - h + padding
    var y1 = y + h - padding
    line2(
    	ctx,
    	x0, y0,
    	x1, y,
    	x0, y1
    )
}

function right_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    right_angle(ctx, x, y, w, h)
}

function right_render2(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var dx = w / 3
    right_angle(ctx, x - dx, y, w, h)
    right_angle(ctx, x + dx, y, w, h)
}

function rotateTexture(context, item, left, top) {
    if (item.angle) {
        var cx = left + item.width / 2 - SHADOW_BORDER / 2
        var cy = top + item.height / 2 - SHADOW_BORDER / 2
        context.save()
        context.translate(cx, cy)
        context.rotate(item.angle)
        context.translate(-cx, -cy)
    }
}

function roundedRectShape(ctx, x, y, w, h, points) {
    var radius = points[2]
    var border = points[3]
    var left = x - w
    var right = x + w
    var top = y - h
    var bottom = y + h
    var width = w * 2
    var height = h * 2
    var x0 = left + border;
    var x1 = x0 + radius;
    var x3 = right - border;
    var x2 = x3 - radius;
    var y0 = top + border;
    var y1 = y0 + radius;
    var y3 = bottom - border;
    var y2 = y3 - radius;
    ctx.beginPath();
    ctx.arc(x1, y1, radius, Math.PI * 1.0, Math.PI * 1.5);
    ctx.lineTo(x2, y0);
    ctx.arc(x2, y1, radius, Math.PI * 1.5, Math.PI * 0);
    ctx.lineTo(x3, y2);
    ctx.arc(x2, y2, radius, Math.PI * 0, Math.PI * 0.5);
    ctx.lineTo(x1, y3);
    ctx.arc(x1, y2, radius, Math.PI * 0.5, Math.PI * 1.0);
    ctx.closePath();
}

function rtrue_render(ctx, x, y, w, h, format) {
    rfalse_render(ctx, x, y, w, h, format)
    setStyleForMore(ctx, format)
    var xr = w * 0.3
    var yr = h * 0.3
    ctx.beginPath()
    safeEllipse(ctx, x, y, xr, yr, 0, 0, Math.PI * 2)
    ctx.fill()
}

function safeEllipse(ctx, cx, cy, rx, ry) {
    if (ctx.ellipse) {
        ctx.ellipse(
        	cx,
        	cy,
        	rx,
        	ry,
        	0,
        	0,
        	Math.PI * 2
        )
    } else {
        var r, scaleX, scaleY
        if (ry > rx) {
            r = rx
            scaleX = 1
            scaleY = ry / rx
        } else {
            r = ry
            scaleY = 1
            scaleX = rx / ry
        }
        var sp = new SafePath(
        	ctx,
        	cx, cy,
        	scaleX, scaleY
        )
        sp.arc(
        	cx,
        	cy,
        	r,
        	0,
        	2 * Math.PI
        )
    }
}

function search_render(ctx, x, y, w, h, format) {
    var h2 = h * 0.6
    var w2 = h2
    var r = h2 * 0.8
    var cx = x - w2 + r
    var cy = y - h2 + r
    var x2 = x + w2
    var y2 = y + h2
    var mx = Math.cos(Math.PI / 4) * r
    var x1 = cx + mx
    var y1 = cy + mx
    setStyleForMore(ctx, format)
    ctx.beginPath()
    safeEllipse(ctx, cx, cy, r, r)
    ctx.stroke()
    line1(ctx, x1, y1, x2, y2)
}

function server1_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    ctx.fillStyle = format.fillColor
    if (shouldShift(ctx.lineWidth)) {
        x += 0.5
        y += 0.5
    }
    var r = w / 5
    roundedRectShape(
    	ctx,
    	x,
    	y,
    	w,
    	h,
    	[0, 0, r, 0]
    )
    ctx.fill()
    ctx.stroke()
    var border = Math.round(h / 6)
    var left = x - w + border
    var right = x + w - border
    var cy = y - h + border
    var w2 = w * 2 - border * 2
    ctx.strokeRect(left, cy, w2, border)
    cy += border * 2
    line1(ctx, left, cy, right, cy)
    cy += border
    line1(ctx, left, cy, right, cy)
    cy += border
    line1(ctx, left, cy, right, cy)
    cy += border
    cy = y + h - border * 3
    line1(ctx, left, cy, right, cy)
    circlePath(ctx, x, cy, border)
    ctx.fill()
    ctx.stroke()
}

function server2_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    ctx.fillStyle = format.fillColor
    if (shouldShift(ctx.lineWidth)) {
        x += 0.5
        y += 0.5
    }
    var x0 = x - w
    var y0 = y - h
    var w2 = w * 2
    var h2 = h * 2
    ctx.fillRect(x0, y0, w2, h2)
    ctx.strokeRect(x0, y0, w2, h2)
    var b = Math.round(w / 8)
    var vx = x - w + b * 2
    var i
    i = 0;
    while (true) {
        if (i < 4) {
            
        } else {
            break;
        }
        line1(ctx, vx, y - h, vx, y + h)
        vx += b
        i++;
    }
    var top = y - b
    ctx.strokeRect(
    	x + w - b * 4,
    	top,
    	b,
    	b
    )
    ctx.strokeRect(
    	x + w - b * 2,
    	top,
    	b,
    	b
    )
    line1(
    	ctx,
    	x - w, y + b,
    	x + w, y + b
    )
}

function setBackground(color) {
    gBackground = color
}

function setDefaultFont(font) {
    var italic, bold, size, family
    if (font) {
        var parsed = Utils.parseFontString(font)
        italic = parsed.italic
        bold = parsed.bold
        size = parsed.size
        family = parsed.family
    } else {
        italic = false
        bold = false
        size = Config.FONT_SIZE_1
        family = Config.FONT_FAMILY_1
        font = Utils.buildFontString(
        	italic,
        	bold,
        	size,
        	family
        )
    }
    gDefaultFont = new FontRecord(
    	font,
    	italic,
    	bold,
    	size,
    	family
    )
    gFont = gDefaultFont
    gTextContext.font = font
}

function setFillStyle(ctx, color, top, bottom) {
    var style
    if (color) {
        if (color.length == 7) {
            style = color
        } else {
            var parts = color.split(" ")
            if ((parts.length == 3) && (parts[0] == "gradient")) {
                var topColor = parts[1]
                var bottomColor = parts[2]
                var grad = ctx.createLinearGradient(0, top, 0, bottom)
                grad.addColorStop(0, topColor)
                grad.addColorStop(1, bottomColor)
                style = grad
            } else {
                style = ""
            }
        }
    } else {
        style = ""
    }
    ctx.fillStyle = style
}

function setFont(font) {
    if (font) {
        var parsed = Utils.parseFontString(font)
        gFont = new FontRecord(
        	font,
        	parsed.italic,
        	parsed.bold,
        	parsed.size,
        	parsed.family
        )
    } else {
        gFont = gDefaultFont
    }
    gTextContext.font = gFont.font
}

function setItemProperty(id, name, value) {
    var item = gItems[id];
    item[name] = value;
}

function setLineStyle(ctx, format) {
    var color = format.lineColor
    var thickness = format.lineThickness
    var style = format.lineStyle
    if (((thickness == 0) || (!(color))) || (color == "none")) {
        return 0
    } else {
        var width = getThickness(thickness)
        ctx.strokeStyle = color
        ctx.lineWidth = width
        ctx.lineCap = "round"
        setStyle(ctx, style, thickness)
        return width
    }
}

function setShadow(ctx, shadow) {
    if ((shadow) && (!(shadow == "none"))) {
        var values = gShadows[shadow]
        var offsetX = values.offsetX * self.zoom * self.retina
        var offsetY = values.offsetY * self.zoom * self.retina
        ctx.shadowColor = values.color
        ctx.shadowBlur = values.blur * self.zoom * self.retina
        ctx.shadowOffsetX = offsetX
        ctx.shadowOffsetY = offsetY
    }
}

function setStyle(ctx, style, thickness) {
    var segments
    var i
    if (style === "solid") {
        segments = []
    } else {
        if (style === "s-1") {
            segments = [1, 2]
            i = 0;
            while (true) {
                if (i < segments.length) {
                    
                } else {
                    break;
                }
                segments[i] *= thickness
                i++;
            }
        } else {
            if (style === "s-2") {
                segments = [3, 4]
                i = 0;
                while (true) {
                    if (i < segments.length) {
                        
                    } else {
                        break;
                    }
                    segments[i] *= thickness
                    i++;
                }
            } else {
                if (style === "s-3") {
                    segments = [7, 8]
                    i = 0;
                    while (true) {
                        if (i < segments.length) {
                            
                        } else {
                            break;
                        }
                        segments[i] *= thickness
                        i++;
                    }
                } else {
                    if (style === "s-4") {
                        segments = [16, 16]
                        i = 0;
                        while (true) {
                            if (i < segments.length) {
                                
                            } else {
                                break;
                            }
                            segments[i] *= thickness
                            i++;
                        }
                    } else {
                        segments = []
                    }
                }
            }
        }
    }
    ctx.setLineDash(segments)
}

function setStyleForMore(ctx, format) {
    var thickness = format.lineThickness
    ctx.fillStyle = format.lineColor
    ctx.strokeStyle = format.lineColor
    ctx.lineWidth = getThickness(thickness) || 1
}

function setTitle(title) {
    
}

function setTransform(dx, dy, zoom, retina) {
    self.dx = dx
    self.dy = dy
    self.zoom = zoom
    self.retina = retina
}

function shouldShift(width) {
    return width % 2 == 1
}

function simpleShadow(ctx, x, y, makeShape, shadow) {
    if ((shadow) && (!(shadow == "none"))) {
        ctx.fillStyle = SHADOW_STYLE
        var sx = SHADOW_SHIFT_X * self.zoom
        var sy = SHADOW_SHIFT_Y * self.zoom
        makeShape(
        	ctx,
        	x + sx,
        	y + sy
        )
        ctx.fill()
    }
}

function simpleShadowRect(ctx, x, y, w, h, shadow) {
    if ((shadow) && (!(shadow == "none"))) {
        ctx.fillStyle = SHADOW_STYLE
        ctx.fillRect(
        	x + SHADOW_SHIFT_X,
        	y + SHADOW_SHIFT_Y,
        	w,
        	h
        )
    }
}

function sp_arc(cx, cy, r, start, end) {
    var cos = Math.cos
    var sin = Math.sin
    var ctx = this.ctx
    var count = getRayCount(r)
    var diff = end - start
    var i
    i = 0;
    while (true) {
        if (i <= count) {
            
        } else {
            break;
        }
        var angle
        if (i == count) {
            angle = end
        } else {
            angle = start + diff * i / count
        }
        var x = cos(angle) * r + cx
        var y = sin(angle) * r + cy
        var x1 = this.transformX(x)
        var y1 = this.transformY(y)
        this.ctx.lineTo(x1, y1)
        i++;
    }
}

function sp_lineTo(x, y) {
    var x1 = this.transformX(x)
    var y1 = this.transformY(y)
    this.ctx.lineTo(x1, y1)
}

function sp_moveTo(x, y) {
    var x1 = this.transformX(x)
    var y1 = this.transformY(y)
    this.ctx.moveTo(x1, y1)
}

function sp_x(x) {
    var origin = this.ox
    var x2 = (x - origin) * this.scaleX + origin
    return x2
}

function sp_y(y) {
    var origin = this.oy
    var y2 = (y - origin) * this.scaleY + origin
    return y2
}

function tablet_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var r = w / 5
    var border = h / 4
    var m = w / 4
    roundedRectShape(
    	ctx,
    	x,
    	y,
    	w,
    	h,
    	[0, 0, r, 0]
    )
    ctx.fill()
    ctx.fillStyle = format.fillColor
    ctx.fillRect(
    	x - w + ctx.lineWidth,
    	y - h + border,
    	w * 2 - ctx.lineWidth * 2,
    	h * 2 - border * 2
    )
    circlePath(
    	ctx,
    	x,
    	y - h + border / 2,
    	border / 4
    )
    ctx.fill()
}

function tri(ctx, x0, y0, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x0, y0)
    ctx.lineTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.closePath()
    ctx.fill()
    ctx.stroke()
}

function up_render(ctx, x, y, w, h, format) {
    setStyleForMore(ctx, format)
    var padding = w * 0.3
    var y0 = y - h / 3
    var y1 = y + h / 3
    var x0 = x - w + padding
    var x1 = x + w - padding
    line2(
    	ctx,
    	x0, y1,
    	x, y0,
    	x1, y1
    )
}

function updateFontMetrics() {
    var height0 = getCoarseFontHeight();
    var height = getFineFontHeight(height0);
    var isFirefox = typeof InstallTrigger !== 'undefined';
    console.log("font height", height);
    //gFontHeight = height;
    gTextContext.font = gFont.font
}

function vscroll_render(ctx, x, y, w, h, format) {
    drawActionCore(
    	ctx,
    	x,
    	y,
    	w,
    	h,
    	format
    )
    ctx.fillStyle = format.lineColor
    var padding = w / 4
    var x0 = x - w + padding
    var x1 = x + w - padding
    var y0 = y - h + padding
    var y1 = y - h + w * 1.5
    var y2 = y + h - w * 1.5
    var y3 = y + h - padding
    ctx.beginPath();
    ctx.moveTo(x0, y1)
    ctx.lineTo(x, y0)
    ctx.lineTo(x1, y1)
    ctx.closePath()
    ctx.fill()
    ctx.beginPath();
    ctx.moveTo(x, y3)
    ctx.lineTo(x0, y2)
    ctx.lineTo(x1, y2)
    ctx.closePath()
    ctx.fill()
}


initShadows()

var tfont = Utils.buildFontString(
	false,
	false,
	Config.FONT_SIZE,
	Config.FONT_FAMILY
)
setFont(tfont)

	gMoveAllImage = new Image()
	gMoveAllImage.onload = function() {
		gMoveAllImageReady = true
	}
	gMoveAllImage.src = "/static/images/4-way-pan.png"

	gVideoImage = new Image()
	gLinkImage = new Image()
	gPictureImage = new Image()
	gVideoImage.src = "/static/images/video-s.png"
	gLinkImage.src = "/static/images/link-s.png"
	gPictureImage.src = "/static/images/picture-s.png"



	moreCallbacks.f_ui_vscroll = vscroll_render
	moreCallbacks.f_ui_hscroll = 	hscroll_render
	moreCallbacks.f_ui_cross = 	cross_render
	moreCallbacks.f_ui_check = 	check_render
	moreCallbacks.f_ui_menu = 	menu_render
	moreCallbacks.f_ui_combo = 	combo_render
	moreCallbacks.f_ui_left = 	left_render
	moreCallbacks.f_ui_left2 = 	left_render2
	moreCallbacks.f_ui_right = 	right_render
	moreCallbacks.f_ui_right2 = 	right_render2
	moreCallbacks.f_ui_radio_false = rfalse_render
	moreCallbacks.f_ui_radio_true = rtrue_render
	moreCallbacks.f_ui_check_false = cfalse_render
	moreCallbacks.f_ui_check_true = ctrue_render
	moreCallbacks.f_ui_search = search_render
	moreCallbacks.f_ui_dots3h = dots3h_render
	moreCallbacks.f_ui_dots3v = dots3v_render
	moreCallbacks.f_ui_close = close_render
	moreCallbacks.f_ui_close_mac = close_mac_render
	moreCallbacks.f_ui_up = up_render
	moreCallbacks.f_ui_down = down_render


	moreCallbacks.f_ar_pc = pc_render
	moreCallbacks.f_ar_human = human_render
	moreCallbacks.f_ar_server1 = server1_render
	moreCallbacks.f_ar_server2 = server2_render
	moreCallbacks.f_ar_phone = phone_render
	moreCallbacks.f_ar_tablet = tablet_render
	moreCallbacks.f_ar_notebook = notebook_render
	moreCallbacks.f_ar_portrait = portrait_render


	this.getFontHeight = getFontHeight;
	this.measureTextWidth = measureTextWidth;
	this.setFont = setFont;

	this.createVertical = createVertical;
	this.createHorizontal = createHorizontal;
	this.createVCandy = createVCandy;
	this.createHCandy = createHCandy;
	this.createJCandy = createJCandy;
	this.addSocket = addSocket;
	this.createRCorner = createRCorner
	this.createFreeHorizontal = createFreeHorizontal
	this.createCalloutArrow = createCalloutArrow

	this.deleteItem = deleteItem;
	this.setItemProperty = setItemProperty;
	this.moveItem = moveItem;

	this.draw = draw;
	this.clear = clear;
	this.makeDirty = makeDirty;
	this.cleanDirty = cleanDirty;
	this.setTitle = setTitle;

	this.createTexture = createTexture;
	this.drawText = drawText;

	this.setBackground = setBackground
	this.getBackground = getBackground

	this.setDefaultFont = setDefaultFont
	this.drawShape = drawShape

	this.createLine = createLine
	this.createMoveAll= createMoveAll
	this.clearGuides = clearGuides
	this.drawLinkIcon = drawLinkIcon

	this.setTransform = setTransform
	this.createRectangle = createRectangle
}
